import {
  styled_default
} from "./chunk-5M2OJVOS.js";
import {
  require_react
} from "./chunk-VGMXIX3P.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// ../../node_modules/.pnpm/orderedmap@1.1.8/node_modules/orderedmap/dist/index-es.js
function OrderedMap(content2) {
  this.content = content2;
}
var index_es_default;
var init_index_es = __esm({
  "../../node_modules/.pnpm/orderedmap@1.1.8/node_modules/orderedmap/dist/index-es.js"() {
    OrderedMap.prototype = {
      constructor: OrderedMap,
      find: function(key) {
        for (var i = 0; i < this.content.length; i += 2)
          if (this.content[i] === key) return i;
        return -1;
      },
      // :: (string) → ?any
      // Retrieve the value stored under `key`, or return undefined when
      // no such key exists.
      get: function(key) {
        var found2 = this.find(key);
        return found2 == -1 ? void 0 : this.content[found2 + 1];
      },
      // :: (string, any, ?string) → OrderedMap
      // Create a new map by replacing the value of `key` with a new
      // value, or adding a binding to the end of the map. If `newKey` is
      // given, the key of the binding will be replaced with that key.
      update: function(key, value, newKey) {
        var self2 = newKey && newKey != key ? this.remove(newKey) : this;
        var found2 = self2.find(key), content2 = self2.content.slice();
        if (found2 == -1) {
          content2.push(newKey || key, value);
        } else {
          content2[found2 + 1] = value;
          if (newKey) content2[found2] = newKey;
        }
        return new OrderedMap(content2);
      },
      // :: (string) → OrderedMap
      // Return a map with the given key removed, if it existed.
      remove: function(key) {
        var found2 = this.find(key);
        if (found2 == -1) return this;
        var content2 = this.content.slice();
        content2.splice(found2, 2);
        return new OrderedMap(content2);
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the start of the map.
      addToStart: function(key, value) {
        return new OrderedMap([key, value].concat(this.remove(key).content));
      },
      // :: (string, any) → OrderedMap
      // Add a new key to the end of the map.
      addToEnd: function(key, value) {
        var content2 = this.remove(key).content.slice();
        content2.push(key, value);
        return new OrderedMap(content2);
      },
      // :: (string, string, any) → OrderedMap
      // Add a key after the given key. If `place` is not found, the new
      // key is added to the end.
      addBefore: function(place, key, value) {
        var without = this.remove(key), content2 = without.content.slice();
        var found2 = without.find(place);
        content2.splice(found2 == -1 ? content2.length : found2, 0, key, value);
        return new OrderedMap(content2);
      },
      // :: ((key: string, value: any))
      // Call the given function for each key/value pair in the map, in
      // order.
      forEach: function(f) {
        for (var i = 0; i < this.content.length; i += 2)
          f(this.content[i], this.content[i + 1]);
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by prepending the keys in this map that don't
      // appear in `map` before the keys in `map`.
      prepend: function(map14) {
        map14 = OrderedMap.from(map14);
        if (!map14.size) return this;
        return new OrderedMap(map14.content.concat(this.subtract(map14).content));
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a new map by appending the keys in this map that don't
      // appear in `map` after the keys in `map`.
      append: function(map14) {
        map14 = OrderedMap.from(map14);
        if (!map14.size) return this;
        return new OrderedMap(this.subtract(map14).content.concat(map14.content));
      },
      // :: (union<Object, OrderedMap>) → OrderedMap
      // Create a map containing all the keys in this map that don't
      // appear in `map`.
      subtract: function(map14) {
        var result2 = this;
        map14 = OrderedMap.from(map14);
        for (var i = 0; i < map14.content.length; i += 2)
          result2 = result2.remove(map14.content[i]);
        return result2;
      },
      // :: number
      // The amount of keys in this map.
      get size() {
        return this.content.length >> 1;
      }
    };
    OrderedMap.from = function(value) {
      if (value instanceof OrderedMap) return value;
      var content2 = [];
      if (value) for (var prop2 in value) content2.push(prop2, value[prop2]);
      return new OrderedMap(content2);
    };
    index_es_default = OrderedMap;
  }
});

// ../../node_modules/.pnpm/prosemirror-model@1.14.3/node_modules/prosemirror-model/dist/index.es.js
var index_es_exports = {};
__export(index_es_exports, {
  ContentMatch: () => ContentMatch,
  DOMParser: () => DOMParser,
  DOMSerializer: () => DOMSerializer,
  Fragment: () => Fragment,
  Mark: () => Mark,
  MarkType: () => MarkType,
  Node: () => Node2,
  NodeRange: () => NodeRange,
  NodeType: () => NodeType,
  ReplaceError: () => ReplaceError,
  ResolvedPos: () => ResolvedPos,
  Schema: () => Schema,
  Slice: () => Slice
});
function findDiffStart(a, b, pos) {
  for (var i = 0; ; i++) {
    if (i == a.childCount || i == b.childCount) {
      return a.childCount == b.childCount ? null : pos;
    }
    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return pos;
    }
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) {
        return inner;
      }
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount; ; ) {
    if (iA == 0 || iB == 0) {
      return iA == iB ? null : { a: posA, b: posB };
    }
    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) {
      return { a: posA, b: posB };
    }
    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) {
        return inner;
      }
    }
    posA -= size;
    posB -= size;
  }
}
function retIndex(index3, offset2) {
  found.index = index3;
  found.offset = offset2;
  return found;
}
function compareDeep(a, b) {
  if (a === b) {
    return true;
  }
  if (!(a && typeof a == "object") || !(b && typeof b == "object")) {
    return false;
  }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) {
    return false;
  }
  if (array) {
    if (a.length != b.length) {
      return false;
    }
    for (var i = 0; i < a.length; i++) {
      if (!compareDeep(a[i], b[i])) {
        return false;
      }
    }
  } else {
    for (var p in a) {
      if (!(p in b) || !compareDeep(a[p], b[p])) {
        return false;
      }
    }
    for (var p$1 in b) {
      if (!(p$1 in a)) {
        return false;
      }
    }
  }
  return true;
}
function ReplaceError(message) {
  var err2 = Error.call(this, message);
  err2.__proto__ = ReplaceError.prototype;
  return err2;
}
function removeRange(content2, from4, to) {
  var ref = content2.findIndex(from4);
  var index3 = ref.index;
  var offset2 = ref.offset;
  var child3 = content2.maybeChild(index3);
  var ref$1 = content2.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset2 == from4 || child3.isText) {
    if (offsetTo != to && !content2.child(indexTo).isText) {
      throw new RangeError("Removing non-flat range");
    }
    return content2.cut(0, from4).append(content2.cut(to));
  }
  if (index3 != indexTo) {
    throw new RangeError("Removing non-flat range");
  }
  return content2.replaceChild(index3, child3.copy(removeRange(child3.content, from4 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content2, dist, insert, parent) {
  var ref = content2.findIndex(dist);
  var index3 = ref.index;
  var offset2 = ref.offset;
  var child3 = content2.maybeChild(index3);
  if (offset2 == dist || child3.isText) {
    if (parent && !parent.canReplace(index3, index3, insert)) {
      return null;
    }
    return content2.cut(0, dist).append(insert).append(content2.cut(dist));
  }
  var inner = insertInto(child3.content, dist - offset2 - 1, insert);
  return inner && content2.replaceChild(index3, child3.copy(inner));
}
function replace($from, $to, slice4) {
  if (slice4.openStart > $from.depth) {
    throw new ReplaceError("Inserted content deeper than insertion position");
  }
  if ($from.depth - slice4.openStart != $to.depth - slice4.openEnd) {
    throw new ReplaceError("Inconsistent open depths");
  }
  return replaceOuter($from, $to, slice4, 0);
}
function replaceOuter($from, $to, slice4, depth) {
  var index3 = $from.index(depth), node4 = $from.node(depth);
  if (index3 == $to.index(depth) && depth < $from.depth - slice4.openStart) {
    var inner = replaceOuter($from, $to, slice4, depth + 1);
    return node4.copy(node4.content.replaceChild(index3, inner));
  } else if (!slice4.content.size) {
    return close(node4, replaceTwoWay($from, $to, depth));
  } else if (!slice4.openStart && !slice4.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent, content2 = parent.content;
    return close(parent, content2.cut(0, $from.parentOffset).append(slice4.content).append(content2.cut($to.parentOffset)));
  } else {
    var ref = prepareSliceForReplace(slice4, $from);
    var start3 = ref.start;
    var end2 = ref.end;
    return close(node4, replaceThreeWay($from, start3, end2, $to, depth));
  }
}
function checkJoin(main, sub2) {
  if (!sub2.type.compatibleContent(main.type)) {
    throw new ReplaceError("Cannot join " + sub2.type.name + " onto " + main.type.name);
  }
}
function joinable($before, $after, depth) {
  var node4 = $before.node(depth);
  checkJoin(node4, $after.node(depth));
  return node4;
}
function addNode(child3, target2) {
  var last2 = target2.length - 1;
  if (last2 >= 0 && child3.isText && child3.sameMarkup(target2[last2])) {
    target2[last2] = child3.withText(target2[last2].text + child3.text);
  } else {
    target2.push(child3);
  }
}
function addRange($start, $end, depth, target2) {
  var node4 = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node4.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target2);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) {
    addNode(node4.child(i), target2);
  }
  if ($end && $end.depth == depth && $end.textOffset) {
    addNode($end.nodeBefore, target2);
  }
}
function close(node4, content2) {
  if (!node4.type.validContent(content2)) {
    throw new ReplaceError("Invalid content for node " + node4.type.name);
  }
  return node4.copy(content2);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  var content2 = [];
  addRange(null, $from, depth, content2);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content2);
  } else {
    if (openStart) {
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content2);
    }
    addRange($start, $end, depth, content2);
    if (openEnd) {
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content2);
    }
  }
  addRange($to, null, depth, content2);
  return new Fragment(content2);
}
function replaceTwoWay($from, $to, depth) {
  var content2 = [];
  addRange(null, $from, depth, content2);
  if ($from.depth > depth) {
    var type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content2);
  }
  addRange($to, null, depth, content2);
  return new Fragment(content2);
}
function prepareSliceForReplace(slice4, $along) {
  var extra = $along.depth - slice4.openStart, parent = $along.node(extra);
  var node4 = parent.copy(slice4.content);
  for (var i = extra - 1; i >= 0; i--) {
    node4 = $along.node(i).copy(Fragment.from(node4));
  }
  return {
    start: node4.resolveNoCache(slice4.openStart + extra),
    end: node4.resolveNoCache(node4.content.size - slice4.openEnd - extra)
  };
}
function wrapMarks(marks2, str) {
  for (var i = marks2.length - 1; i >= 0; i--) {
    str = marks2[i].type.name + "(" + str + ")";
  }
  return str;
}
function parseExpr(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+")) {
      expr = { type: "plus", expr };
    } else if (stream.eat("*")) {
      expr = { type: "star", expr };
    } else if (stream.eat("?")) {
      expr = { type: "opt", expr };
    } else if (stream.eat("{")) {
      expr = parseExprRange(stream, expr);
    } else {
      break;
    }
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next)) {
    stream.err("Expected number, got '" + stream.next + "'");
  }
  var result2 = Number(stream.next);
  stream.pos++;
  return result2;
}
function parseExprRange(stream, expr) {
  var min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}") {
      max2 = parseNum(stream);
    } else {
      max2 = -1;
    }
  }
  if (!stream.eat("}")) {
    stream.err("Unclosed braced range");
  }
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) {
    return [type];
  }
  var result2 = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) {
      result2.push(type$1);
    }
  }
  if (result2.length == 0) {
    stream.err("No node type or group '" + name + "' found");
  }
  return result2;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) {
      stream.err("Missing closing paren");
    }
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function(type) {
      if (stream.inline == null) {
        stream.inline = type.isInline;
      } else if (stream.inline != type.isInline) {
        stream.err("Mixing inline and block content");
      }
      return { type: "name", value: type };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  var nfa2 = [[]];
  connect(compile3(expr, 0), node4());
  return nfa2;
  function node4() {
    return nfa2.push([]) - 1;
  }
  function edge2(from4, to, term) {
    var edge3 = { term, to };
    nfa2[from4].push(edge3);
    return edge3;
  }
  function connect(edges, to) {
    edges.forEach(function(edge3) {
      return edge3.to = to;
    });
  }
  function compile3(expr2, from4) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce(function(out, expr3) {
        return out.concat(compile3(expr3, from4));
      }, []);
    } else if (expr2.type == "seq") {
      for (var i = 0; ; i++) {
        var next = compile3(expr2.exprs[i], from4);
        if (i == expr2.exprs.length - 1) {
          return next;
        }
        connect(next, from4 = node4());
      }
    } else if (expr2.type == "star") {
      var loop = node4();
      edge2(from4, loop);
      connect(compile3(expr2.expr, loop), loop);
      return [edge2(loop)];
    } else if (expr2.type == "plus") {
      var loop$1 = node4();
      connect(compile3(expr2.expr, from4), loop$1);
      connect(compile3(expr2.expr, loop$1), loop$1);
      return [edge2(loop$1)];
    } else if (expr2.type == "opt") {
      return [edge2(from4)].concat(compile3(expr2.expr, from4));
    } else if (expr2.type == "range") {
      var cur = from4;
      for (var i$1 = 0; i$1 < expr2.min; i$1++) {
        var next$1 = node4();
        connect(compile3(expr2.expr, cur), next$1);
        cur = next$1;
      }
      if (expr2.max == -1) {
        connect(compile3(expr2.expr, cur), cur);
      } else {
        for (var i$2 = expr2.min; i$2 < expr2.max; i$2++) {
          var next$2 = node4();
          edge2(cur, next$2);
          connect(compile3(expr2.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge2(cur)];
    } else if (expr2.type == "name") {
      return [edge2(from4, null, expr2.value)];
    }
  }
}
function cmp(a, b) {
  return b - a;
}
function nullFrom(nfa2, node4) {
  var result2 = [];
  scan(node4);
  return result2.sort(cmp);
  function scan(node5) {
    var edges = nfa2[node5];
    if (edges.length == 1 && !edges[0].term) {
      return scan(edges[0].to);
    }
    result2.push(node5);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result2.indexOf(to) == -1) {
        scan(to);
      }
    }
  }
}
function dfa(nfa2) {
  var labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    var out = [];
    states.forEach(function(node4) {
      nfa2[node4].forEach(function(ref) {
        var term = ref.term;
        var to = ref.to;
        if (!term) {
          return;
        }
        var known = out.indexOf(term), set2 = known > -1 && out[known + 1];
        nullFrom(nfa2, to).forEach(function(node5) {
          if (!set2) {
            out.push(term, set2 = []);
          }
          if (set2.indexOf(node5) == -1) {
            set2.push(node5);
          }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node4 = state.next[j], next = state.next[j + 1];
      nodes.push(node4.name);
      if (dead && !(node4.isText || node4.hasRequiredAttrs())) {
        dead = false;
      }
      if (work.indexOf(next) == -1) {
        work.push(next);
      }
    }
    if (dead) {
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
}
function defaultAttrs(attrs) {
  var defaults = /* @__PURE__ */ Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) {
      return null;
    }
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  var built = /* @__PURE__ */ Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === void 0) {
      var attr = attrs[name];
      if (attr.hasDefault) {
        given = attr.default;
      } else {
        throw new RangeError("No value supplied for attribute " + name);
      }
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  var result2 = /* @__PURE__ */ Object.create(null);
  if (attrs) {
    for (var name in attrs) {
      result2[name] = new Attribute(attrs[name]);
    }
  }
  return result2;
}
function gatherMarks(schema, marks2) {
  var found2 = [];
  for (var i = 0; i < marks2.length; i++) {
    var name = marks2[i], mark3 = schema.marks[name], ok2 = mark3;
    if (mark3) {
      found2.push(mark3);
    } else {
      for (var prop2 in schema.marks) {
        var mark$1 = schema.marks[prop2];
        if (name == "_" || mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1) {
          found2.push(ok2 = mark$1);
        }
      }
    }
    if (!ok2) {
      throw new SyntaxError("Unknown mark type: '" + marks2[i] + "'");
    }
  }
  return found2;
}
function wsOptionsFor(preserveWhitespace) {
  return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
}
function normalizeList(dom) {
  for (var child3 = dom.firstChild, prevItem = null; child3; child3 = child3.nextSibling) {
    var name = child3.nodeType == 1 ? child3.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child3);
      child3 = prevItem;
    } else if (name == "li") {
      prevItem = child3;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches2(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function parseStyles(style) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result2 = [];
  while (m = re.exec(style)) {
    result2.push(m[1], m[2].trim());
  }
  return result2;
}
function copy2(obj) {
  var copy6 = {};
  for (var prop2 in obj) {
    copy6[prop2] = obj[prop2];
  }
  return copy6;
}
function markMayApply(markType, nodeType2) {
  var nodes = nodeType2.schema.nodes;
  var loop = function(name2) {
    var parent = nodes[name2];
    if (!parent.allowsMarkType(markType)) {
      return;
    }
    var seen = [], scan = function(match) {
      seen.push(match);
      for (var i = 0; i < match.edgeCount; i++) {
        var ref = match.edge(i);
        var type = ref.type;
        var next = ref.next;
        if (type == nodeType2) {
          return true;
        }
        if (seen.indexOf(next) < 0 && scan(next)) {
          return true;
        }
      }
    };
    if (scan(parent.contentMatch)) {
      return { v: true };
    }
  };
  for (var name in nodes) {
    var returned = loop(name);
    if (returned) return returned.v;
  }
}
function findSameMarkInSet(mark3, set2) {
  for (var i = 0; i < set2.length; i++) {
    if (mark3.eq(set2[i])) {
      return set2[i];
    }
  }
}
function gatherToDOM(obj) {
  var result2 = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) {
      result2[name] = toDOM;
    }
  }
  return result2;
}
function doc(options) {
  return options.document || window.document;
}
var Fragment, prototypeAccessors, found, Mark, Slice, prototypeAccessors$1, ResolvedPos, prototypeAccessors$2, resolveCache, resolveCachePos, resolveCacheSize, NodeRange, prototypeAccessors$1$1, emptyAttrs, Node2, prototypeAccessors$3, TextNode, ContentMatch, prototypeAccessors$4, TokenStream, prototypeAccessors$1$2, NodeType, prototypeAccessors$5, Attribute, prototypeAccessors$1$3, MarkType, Schema, DOMParser, blockTags, ignoreTags, listTags, OPT_PRESERVE_WS, OPT_PRESERVE_WS_FULL, OPT_OPEN_LEFT, NodeContext, ParseContext, prototypeAccessors$6, DOMSerializer;
var init_index_es2 = __esm({
  "../../node_modules/.pnpm/prosemirror-model@1.14.3/node_modules/prosemirror-model/dist/index.es.js"() {
    init_index_es();
    Fragment = function Fragment2(content2, size) {
      this.content = content2;
      this.size = size || 0;
      if (size == null) {
        for (var i = 0; i < content2.length; i++) {
          this.size += content2[i].nodeSize;
        }
      }
    };
    prototypeAccessors = { firstChild: { configurable: true }, lastChild: { configurable: true }, childCount: { configurable: true } };
    Fragment.prototype.nodesBetween = function nodesBetween(from4, to, f, nodeStart, parent) {
      if (nodeStart === void 0) nodeStart = 0;
      for (var i = 0, pos = 0; pos < to; i++) {
        var child3 = this.content[i], end2 = pos + child3.nodeSize;
        if (end2 > from4 && f(child3, nodeStart + pos, parent, i) !== false && child3.content.size) {
          var start3 = pos + 1;
          child3.nodesBetween(
            Math.max(0, from4 - start3),
            Math.min(child3.content.size, to - start3),
            f,
            nodeStart + start3
          );
        }
        pos = end2;
      }
    };
    Fragment.prototype.descendants = function descendants(f) {
      this.nodesBetween(0, this.size, f);
    };
    Fragment.prototype.textBetween = function textBetween(from4, to, blockSeparator, leafText) {
      var text3 = "", separated = true;
      this.nodesBetween(from4, to, function(node4, pos) {
        if (node4.isText) {
          text3 += node4.text.slice(Math.max(from4, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node4.isLeaf && leafText) {
          text3 += leafText;
          separated = !blockSeparator;
        } else if (!separated && node4.isBlock) {
          text3 += blockSeparator;
          separated = true;
        }
      }, 0);
      return text3;
    };
    Fragment.prototype.append = function append(other) {
      if (!other.size) {
        return this;
      }
      if (!this.size) {
        return other;
      }
      var last2 = this.lastChild, first = other.firstChild, content2 = this.content.slice(), i = 0;
      if (last2.isText && last2.sameMarkup(first)) {
        content2[content2.length - 1] = last2.withText(last2.text + first.text);
        i = 1;
      }
      for (; i < other.content.length; i++) {
        content2.push(other.content[i]);
      }
      return new Fragment(content2, this.size + other.size);
    };
    Fragment.prototype.cut = function cut(from4, to) {
      if (to == null) {
        to = this.size;
      }
      if (from4 == 0 && to == this.size) {
        return this;
      }
      var result2 = [], size = 0;
      if (to > from4) {
        for (var i = 0, pos = 0; pos < to; i++) {
          var child3 = this.content[i], end2 = pos + child3.nodeSize;
          if (end2 > from4) {
            if (pos < from4 || end2 > to) {
              if (child3.isText) {
                child3 = child3.cut(Math.max(0, from4 - pos), Math.min(child3.text.length, to - pos));
              } else {
                child3 = child3.cut(Math.max(0, from4 - pos - 1), Math.min(child3.content.size, to - pos - 1));
              }
            }
            result2.push(child3);
            size += child3.nodeSize;
          }
          pos = end2;
        }
      }
      return new Fragment(result2, size);
    };
    Fragment.prototype.cutByIndex = function cutByIndex(from4, to) {
      if (from4 == to) {
        return Fragment.empty;
      }
      if (from4 == 0 && to == this.content.length) {
        return this;
      }
      return new Fragment(this.content.slice(from4, to));
    };
    Fragment.prototype.replaceChild = function replaceChild(index3, node4) {
      var current = this.content[index3];
      if (current == node4) {
        return this;
      }
      var copy6 = this.content.slice();
      var size = this.size + node4.nodeSize - current.nodeSize;
      copy6[index3] = node4;
      return new Fragment(copy6, size);
    };
    Fragment.prototype.addToStart = function addToStart(node4) {
      return new Fragment([node4].concat(this.content), this.size + node4.nodeSize);
    };
    Fragment.prototype.addToEnd = function addToEnd(node4) {
      return new Fragment(this.content.concat(node4), this.size + node4.nodeSize);
    };
    Fragment.prototype.eq = function eq(other) {
      if (this.content.length != other.content.length) {
        return false;
      }
      for (var i = 0; i < this.content.length; i++) {
        if (!this.content[i].eq(other.content[i])) {
          return false;
        }
      }
      return true;
    };
    prototypeAccessors.firstChild.get = function() {
      return this.content.length ? this.content[0] : null;
    };
    prototypeAccessors.lastChild.get = function() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    };
    prototypeAccessors.childCount.get = function() {
      return this.content.length;
    };
    Fragment.prototype.child = function child(index3) {
      var found2 = this.content[index3];
      if (!found2) {
        throw new RangeError("Index " + index3 + " out of range for " + this);
      }
      return found2;
    };
    Fragment.prototype.maybeChild = function maybeChild(index3) {
      return this.content[index3];
    };
    Fragment.prototype.forEach = function forEach(f) {
      for (var i = 0, p = 0; i < this.content.length; i++) {
        var child3 = this.content[i];
        f(child3, p, i);
        p += child3.nodeSize;
      }
    };
    Fragment.prototype.findDiffStart = function findDiffStart$1(other, pos) {
      if (pos === void 0) pos = 0;
      return findDiffStart(this, other, pos);
    };
    Fragment.prototype.findDiffEnd = function findDiffEnd$1(other, pos, otherPos) {
      if (pos === void 0) pos = this.size;
      if (otherPos === void 0) otherPos = other.size;
      return findDiffEnd(this, other, pos, otherPos);
    };
    Fragment.prototype.findIndex = function findIndex(pos, round) {
      if (round === void 0) round = -1;
      if (pos == 0) {
        return retIndex(0, pos);
      }
      if (pos == this.size) {
        return retIndex(this.content.length, pos);
      }
      if (pos > this.size || pos < 0) {
        throw new RangeError("Position " + pos + " outside of fragment (" + this + ")");
      }
      for (var i = 0, curPos = 0; ; i++) {
        var cur = this.child(i), end2 = curPos + cur.nodeSize;
        if (end2 >= pos) {
          if (end2 == pos || round > 0) {
            return retIndex(i + 1, end2);
          }
          return retIndex(i, curPos);
        }
        curPos = end2;
      }
    };
    Fragment.prototype.toString = function toString() {
      return "<" + this.toStringInner() + ">";
    };
    Fragment.prototype.toStringInner = function toStringInner() {
      return this.content.join(", ");
    };
    Fragment.prototype.toJSON = function toJSON() {
      return this.content.length ? this.content.map(function(n) {
        return n.toJSON();
      }) : null;
    };
    Fragment.fromJSON = function fromJSON(schema, value) {
      if (!value) {
        return Fragment.empty;
      }
      if (!Array.isArray(value)) {
        throw new RangeError("Invalid input for Fragment.fromJSON");
      }
      return new Fragment(value.map(schema.nodeFromJSON));
    };
    Fragment.fromArray = function fromArray(array) {
      if (!array.length) {
        return Fragment.empty;
      }
      var joined, size = 0;
      for (var i = 0; i < array.length; i++) {
        var node4 = array[i];
        size += node4.nodeSize;
        if (i && node4.isText && array[i - 1].sameMarkup(node4)) {
          if (!joined) {
            joined = array.slice(0, i);
          }
          joined[joined.length - 1] = node4.withText(joined[joined.length - 1].text + node4.text);
        } else if (joined) {
          joined.push(node4);
        }
      }
      return new Fragment(joined || array, size);
    };
    Fragment.from = function from(nodes) {
      if (!nodes) {
        return Fragment.empty;
      }
      if (nodes instanceof Fragment) {
        return nodes;
      }
      if (Array.isArray(nodes)) {
        return this.fromArray(nodes);
      }
      if (nodes.attrs) {
        return new Fragment([nodes], nodes.nodeSize);
      }
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    };
    Object.defineProperties(Fragment.prototype, prototypeAccessors);
    found = { index: 0, offset: 0 };
    Fragment.empty = new Fragment([], 0);
    Mark = function Mark2(type, attrs) {
      this.type = type;
      this.attrs = attrs;
    };
    Mark.prototype.addToSet = function addToSet(set2) {
      var copy6, placed = false;
      for (var i = 0; i < set2.length; i++) {
        var other = set2[i];
        if (this.eq(other)) {
          return set2;
        }
        if (this.type.excludes(other.type)) {
          if (!copy6) {
            copy6 = set2.slice(0, i);
          }
        } else if (other.type.excludes(this.type)) {
          return set2;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy6) {
              copy6 = set2.slice(0, i);
            }
            copy6.push(this);
            placed = true;
          }
          if (copy6) {
            copy6.push(other);
          }
        }
      }
      if (!copy6) {
        copy6 = set2.slice();
      }
      if (!placed) {
        copy6.push(this);
      }
      return copy6;
    };
    Mark.prototype.removeFromSet = function removeFromSet(set2) {
      for (var i = 0; i < set2.length; i++) {
        if (this.eq(set2[i])) {
          return set2.slice(0, i).concat(set2.slice(i + 1));
        }
      }
      return set2;
    };
    Mark.prototype.isInSet = function isInSet(set2) {
      for (var i = 0; i < set2.length; i++) {
        if (this.eq(set2[i])) {
          return true;
        }
      }
      return false;
    };
    Mark.prototype.eq = function eq2(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    };
    Mark.prototype.toJSON = function toJSON2() {
      var obj = { type: this.type.name };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    };
    Mark.fromJSON = function fromJSON2(schema, json) {
      if (!json) {
        throw new RangeError("Invalid input for Mark.fromJSON");
      }
      var type = schema.marks[json.type];
      if (!type) {
        throw new RangeError("There is no mark type " + json.type + " in this schema");
      }
      return type.create(json.attrs);
    };
    Mark.sameSet = function sameSet(a, b) {
      if (a == b) {
        return true;
      }
      if (a.length != b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!a[i].eq(b[i])) {
          return false;
        }
      }
      return true;
    };
    Mark.setFrom = function setFrom(marks2) {
      if (!marks2 || marks2.length == 0) {
        return Mark.none;
      }
      if (marks2 instanceof Mark) {
        return [marks2];
      }
      var copy6 = marks2.slice();
      copy6.sort(function(a, b) {
        return a.type.rank - b.type.rank;
      });
      return copy6;
    };
    Mark.none = [];
    ReplaceError.prototype = Object.create(Error.prototype);
    ReplaceError.prototype.constructor = ReplaceError;
    ReplaceError.prototype.name = "ReplaceError";
    Slice = function Slice2(content2, openStart, openEnd) {
      this.content = content2;
      this.openStart = openStart;
      this.openEnd = openEnd;
    };
    prototypeAccessors$1 = { size: { configurable: true } };
    prototypeAccessors$1.size.get = function() {
      return this.content.size - this.openStart - this.openEnd;
    };
    Slice.prototype.insertAt = function insertAt(pos, fragment) {
      var content2 = insertInto(this.content, pos + this.openStart, fragment, null);
      return content2 && new Slice(content2, this.openStart, this.openEnd);
    };
    Slice.prototype.removeBetween = function removeBetween(from4, to) {
      return new Slice(removeRange(this.content, from4 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    };
    Slice.prototype.eq = function eq3(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    };
    Slice.prototype.toString = function toString2() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    };
    Slice.prototype.toJSON = function toJSON3() {
      if (!this.content.size) {
        return null;
      }
      var json = { content: this.content.toJSON() };
      if (this.openStart > 0) {
        json.openStart = this.openStart;
      }
      if (this.openEnd > 0) {
        json.openEnd = this.openEnd;
      }
      return json;
    };
    Slice.fromJSON = function fromJSON3(schema, json) {
      if (!json) {
        return Slice.empty;
      }
      var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number") {
        throw new RangeError("Invalid input for Slice.fromJSON");
      }
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    };
    Slice.maxOpen = function maxOpen(fragment, openIsolating) {
      if (openIsolating === void 0) openIsolating = true;
      var openStart = 0, openEnd = 0;
      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
        openStart++;
      }
      for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) {
        openEnd++;
      }
      return new Slice(fragment, openStart, openEnd);
    };
    Object.defineProperties(Slice.prototype, prototypeAccessors$1);
    Slice.empty = new Slice(Fragment.empty, 0, 0);
    ResolvedPos = function ResolvedPos2(pos, path, parentOffset) {
      this.pos = pos;
      this.path = path;
      this.depth = path.length / 3 - 1;
      this.parentOffset = parentOffset;
    };
    prototypeAccessors$2 = { parent: { configurable: true }, doc: { configurable: true }, textOffset: { configurable: true }, nodeAfter: { configurable: true }, nodeBefore: { configurable: true } };
    ResolvedPos.prototype.resolveDepth = function resolveDepth(val) {
      if (val == null) {
        return this.depth;
      }
      if (val < 0) {
        return this.depth + val;
      }
      return val;
    };
    prototypeAccessors$2.parent.get = function() {
      return this.node(this.depth);
    };
    prototypeAccessors$2.doc.get = function() {
      return this.node(0);
    };
    ResolvedPos.prototype.node = function node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    };
    ResolvedPos.prototype.index = function index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    };
    ResolvedPos.prototype.indexAfter = function indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    };
    ResolvedPos.prototype.start = function start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    };
    ResolvedPos.prototype.end = function end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    };
    ResolvedPos.prototype.before = function before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) {
        throw new RangeError("There is no position before the top-level node");
      }
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    };
    ResolvedPos.prototype.after = function after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) {
        throw new RangeError("There is no position after the top-level node");
      }
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    };
    prototypeAccessors$2.textOffset.get = function() {
      return this.pos - this.path[this.path.length - 1];
    };
    prototypeAccessors$2.nodeAfter.get = function() {
      var parent = this.parent, index3 = this.index(this.depth);
      if (index3 == parent.childCount) {
        return null;
      }
      var dOff = this.pos - this.path[this.path.length - 1], child3 = parent.child(index3);
      return dOff ? parent.child(index3).cut(dOff) : child3;
    };
    prototypeAccessors$2.nodeBefore.get = function() {
      var index3 = this.index(this.depth);
      var dOff = this.pos - this.path[this.path.length - 1];
      if (dOff) {
        return this.parent.child(index3).cut(0, dOff);
      }
      return index3 == 0 ? null : this.parent.child(index3 - 1);
    };
    ResolvedPos.prototype.posAtIndex = function posAtIndex(index3, depth) {
      depth = this.resolveDepth(depth);
      var node4 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (var i = 0; i < index3; i++) {
        pos += node4.child(i).nodeSize;
      }
      return pos;
    };
    ResolvedPos.prototype.marks = function marks() {
      var parent = this.parent, index3 = this.index();
      if (parent.content.size == 0) {
        return Mark.none;
      }
      if (this.textOffset) {
        return parent.child(index3).marks;
      }
      var main = parent.maybeChild(index3 - 1), other = parent.maybeChild(index3);
      if (!main) {
        var tmp = main;
        main = other;
        other = tmp;
      }
      var marks2 = main.marks;
      for (var i = 0; i < marks2.length; i++) {
        if (marks2[i].type.spec.inclusive === false && (!other || !marks2[i].isInSet(other.marks))) {
          marks2 = marks2[i--].removeFromSet(marks2);
        }
      }
      return marks2;
    };
    ResolvedPos.prototype.marksAcross = function marksAcross($end) {
      var after2 = this.parent.maybeChild(this.index());
      if (!after2 || !after2.isInline) {
        return null;
      }
      var marks2 = after2.marks, next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks2.length; i++) {
        if (marks2[i].type.spec.inclusive === false && (!next || !marks2[i].isInSet(next.marks))) {
          marks2 = marks2[i--].removeFromSet(marks2);
        }
      }
      return marks2;
    };
    ResolvedPos.prototype.sharedDepth = function sharedDepth(pos) {
      for (var depth = this.depth; depth > 0; depth--) {
        if (this.start(depth) <= pos && this.end(depth) >= pos) {
          return depth;
        }
      }
      return 0;
    };
    ResolvedPos.prototype.blockRange = function blockRange(other, pred) {
      if (other === void 0) other = this;
      if (other.pos < this.pos) {
        return other.blockRange(this);
      }
      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) {
          return new NodeRange(this, other, d);
        }
      }
    };
    ResolvedPos.prototype.sameParent = function sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    };
    ResolvedPos.prototype.max = function max(other) {
      return other.pos > this.pos ? other : this;
    };
    ResolvedPos.prototype.min = function min(other) {
      return other.pos < this.pos ? other : this;
    };
    ResolvedPos.prototype.toString = function toString3() {
      var str = "";
      for (var i = 1; i <= this.depth; i++) {
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      }
      return str + ":" + this.parentOffset;
    };
    ResolvedPos.resolve = function resolve(doc2, pos) {
      if (!(pos >= 0 && pos <= doc2.content.size)) {
        throw new RangeError("Position " + pos + " out of range");
      }
      var path = [];
      var start3 = 0, parentOffset = pos;
      for (var node4 = doc2; ; ) {
        var ref = node4.content.findIndex(parentOffset);
        var index3 = ref.index;
        var offset2 = ref.offset;
        var rem = parentOffset - offset2;
        path.push(node4, index3, start3 + offset2);
        if (!rem) {
          break;
        }
        node4 = node4.child(index3);
        if (node4.isText) {
          break;
        }
        parentOffset = rem - 1;
        start3 += offset2 + 1;
      }
      return new ResolvedPos(pos, path, parentOffset);
    };
    ResolvedPos.resolveCached = function resolveCached(doc2, pos) {
      for (var i = 0; i < resolveCache.length; i++) {
        var cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc2) {
          return cached;
        }
      }
      var result2 = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc2, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result2;
    };
    Object.defineProperties(ResolvedPos.prototype, prototypeAccessors$2);
    resolveCache = [];
    resolveCachePos = 0;
    resolveCacheSize = 12;
    NodeRange = function NodeRange2($from, $to, depth) {
      this.$from = $from;
      this.$to = $to;
      this.depth = depth;
    };
    prototypeAccessors$1$1 = { start: { configurable: true }, end: { configurable: true }, parent: { configurable: true }, startIndex: { configurable: true }, endIndex: { configurable: true } };
    prototypeAccessors$1$1.start.get = function() {
      return this.$from.before(this.depth + 1);
    };
    prototypeAccessors$1$1.end.get = function() {
      return this.$to.after(this.depth + 1);
    };
    prototypeAccessors$1$1.parent.get = function() {
      return this.$from.node(this.depth);
    };
    prototypeAccessors$1$1.startIndex.get = function() {
      return this.$from.index(this.depth);
    };
    prototypeAccessors$1$1.endIndex.get = function() {
      return this.$to.indexAfter(this.depth);
    };
    Object.defineProperties(NodeRange.prototype, prototypeAccessors$1$1);
    emptyAttrs = /* @__PURE__ */ Object.create(null);
    Node2 = function Node3(type, attrs, content2, marks2) {
      this.type = type;
      this.attrs = attrs;
      this.content = content2 || Fragment.empty;
      this.marks = marks2 || Mark.none;
    };
    prototypeAccessors$3 = { nodeSize: { configurable: true }, childCount: { configurable: true }, textContent: { configurable: true }, firstChild: { configurable: true }, lastChild: { configurable: true }, isBlock: { configurable: true }, isTextblock: { configurable: true }, inlineContent: { configurable: true }, isInline: { configurable: true }, isText: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
    prototypeAccessors$3.nodeSize.get = function() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    };
    prototypeAccessors$3.childCount.get = function() {
      return this.content.childCount;
    };
    Node2.prototype.child = function child2(index3) {
      return this.content.child(index3);
    };
    Node2.prototype.maybeChild = function maybeChild2(index3) {
      return this.content.maybeChild(index3);
    };
    Node2.prototype.forEach = function forEach2(f) {
      this.content.forEach(f);
    };
    Node2.prototype.nodesBetween = function nodesBetween2(from4, to, f, startPos) {
      if (startPos === void 0) startPos = 0;
      this.content.nodesBetween(from4, to, f, startPos, this);
    };
    Node2.prototype.descendants = function descendants2(f) {
      this.nodesBetween(0, this.content.size, f);
    };
    prototypeAccessors$3.textContent.get = function() {
      return this.textBetween(0, this.content.size, "");
    };
    Node2.prototype.textBetween = function textBetween2(from4, to, blockSeparator, leafText) {
      return this.content.textBetween(from4, to, blockSeparator, leafText);
    };
    prototypeAccessors$3.firstChild.get = function() {
      return this.content.firstChild;
    };
    prototypeAccessors$3.lastChild.get = function() {
      return this.content.lastChild;
    };
    Node2.prototype.eq = function eq4(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    };
    Node2.prototype.sameMarkup = function sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    };
    Node2.prototype.hasMarkup = function hasMarkup(type, attrs, marks2) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks2 || Mark.none);
    };
    Node2.prototype.copy = function copy(content2) {
      if (content2 === void 0) content2 = null;
      if (content2 == this.content) {
        return this;
      }
      return new this.constructor(this.type, this.attrs, content2, this.marks);
    };
    Node2.prototype.mark = function mark(marks2) {
      return marks2 == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks2);
    };
    Node2.prototype.cut = function cut2(from4, to) {
      if (from4 == 0 && to == this.content.size) {
        return this;
      }
      return this.copy(this.content.cut(from4, to));
    };
    Node2.prototype.slice = function slice(from4, to, includeParents) {
      if (to === void 0) to = this.content.size;
      if (includeParents === void 0) includeParents = false;
      if (from4 == to) {
        return Slice.empty;
      }
      var $from = this.resolve(from4), $to = this.resolve(to);
      var depth = includeParents ? 0 : $from.sharedDepth(to);
      var start3 = $from.start(depth), node4 = $from.node(depth);
      var content2 = node4.content.cut($from.pos - start3, $to.pos - start3);
      return new Slice(content2, $from.depth - depth, $to.depth - depth);
    };
    Node2.prototype.replace = function replace$1(from4, to, slice4) {
      return replace(this.resolve(from4), this.resolve(to), slice4);
    };
    Node2.prototype.nodeAt = function nodeAt(pos) {
      for (var node4 = this; ; ) {
        var ref = node4.content.findIndex(pos);
        var index3 = ref.index;
        var offset2 = ref.offset;
        node4 = node4.maybeChild(index3);
        if (!node4) {
          return null;
        }
        if (offset2 == pos || node4.isText) {
          return node4;
        }
        pos -= offset2 + 1;
      }
    };
    Node2.prototype.childAfter = function childAfter(pos) {
      var ref = this.content.findIndex(pos);
      var index3 = ref.index;
      var offset2 = ref.offset;
      return { node: this.content.maybeChild(index3), index: index3, offset: offset2 };
    };
    Node2.prototype.childBefore = function childBefore(pos) {
      if (pos == 0) {
        return { node: null, index: 0, offset: 0 };
      }
      var ref = this.content.findIndex(pos);
      var index3 = ref.index;
      var offset2 = ref.offset;
      if (offset2 < pos) {
        return { node: this.content.child(index3), index: index3, offset: offset2 };
      }
      var node4 = this.content.child(index3 - 1);
      return { node: node4, index: index3 - 1, offset: offset2 - node4.nodeSize };
    };
    Node2.prototype.resolve = function resolve2(pos) {
      return ResolvedPos.resolveCached(this, pos);
    };
    Node2.prototype.resolveNoCache = function resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    };
    Node2.prototype.rangeHasMark = function rangeHasMark(from4, to, type) {
      var found2 = false;
      if (to > from4) {
        this.nodesBetween(from4, to, function(node4) {
          if (type.isInSet(node4.marks)) {
            found2 = true;
          }
          return !found2;
        });
      }
      return found2;
    };
    prototypeAccessors$3.isBlock.get = function() {
      return this.type.isBlock;
    };
    prototypeAccessors$3.isTextblock.get = function() {
      return this.type.isTextblock;
    };
    prototypeAccessors$3.inlineContent.get = function() {
      return this.type.inlineContent;
    };
    prototypeAccessors$3.isInline.get = function() {
      return this.type.isInline;
    };
    prototypeAccessors$3.isText.get = function() {
      return this.type.isText;
    };
    prototypeAccessors$3.isLeaf.get = function() {
      return this.type.isLeaf;
    };
    prototypeAccessors$3.isAtom.get = function() {
      return this.type.isAtom;
    };
    Node2.prototype.toString = function toString4() {
      if (this.type.spec.toDebugString) {
        return this.type.spec.toDebugString(this);
      }
      var name = this.type.name;
      if (this.content.size) {
        name += "(" + this.content.toStringInner() + ")";
      }
      return wrapMarks(this.marks, name);
    };
    Node2.prototype.contentMatchAt = function contentMatchAt(index3) {
      var match = this.type.contentMatch.matchFragment(this.content, 0, index3);
      if (!match) {
        throw new Error("Called contentMatchAt on a node with invalid content");
      }
      return match;
    };
    Node2.prototype.canReplace = function canReplace(from4, to, replacement, start3, end2) {
      if (replacement === void 0) replacement = Fragment.empty;
      if (start3 === void 0) start3 = 0;
      if (end2 === void 0) end2 = replacement.childCount;
      var one = this.contentMatchAt(from4).matchFragment(replacement, start3, end2);
      var two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd) {
        return false;
      }
      for (var i = start3; i < end2; i++) {
        if (!this.type.allowsMarks(replacement.child(i).marks)) {
          return false;
        }
      }
      return true;
    };
    Node2.prototype.canReplaceWith = function canReplaceWith(from4, to, type, marks2) {
      if (marks2 && !this.type.allowsMarks(marks2)) {
        return false;
      }
      var start3 = this.contentMatchAt(from4).matchType(type);
      var end2 = start3 && start3.matchFragment(this.content, to);
      return end2 ? end2.validEnd : false;
    };
    Node2.prototype.canAppend = function canAppend(other) {
      if (other.content.size) {
        return this.canReplace(this.childCount, this.childCount, other.content);
      } else {
        return this.type.compatibleContent(other.type);
      }
    };
    Node2.prototype.check = function check() {
      if (!this.type.validContent(this.content)) {
        throw new RangeError("Invalid content for node " + this.type.name + ": " + this.content.toString().slice(0, 50));
      }
      var copy6 = Mark.none;
      for (var i = 0; i < this.marks.length; i++) {
        copy6 = this.marks[i].addToSet(copy6);
      }
      if (!Mark.sameSet(copy6, this.marks)) {
        throw new RangeError("Invalid collection of marks for node " + this.type.name + ": " + this.marks.map(function(m) {
          return m.type.name;
        }));
      }
      this.content.forEach(function(node4) {
        return node4.check();
      });
    };
    Node2.prototype.toJSON = function toJSON4() {
      var obj = { type: this.type.name };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size) {
        obj.content = this.content.toJSON();
      }
      if (this.marks.length) {
        obj.marks = this.marks.map(function(n) {
          return n.toJSON();
        });
      }
      return obj;
    };
    Node2.fromJSON = function fromJSON4(schema, json) {
      if (!json) {
        throw new RangeError("Invalid input for Node.fromJSON");
      }
      var marks2 = null;
      if (json.marks) {
        if (!Array.isArray(json.marks)) {
          throw new RangeError("Invalid mark data for Node.fromJSON");
        }
        marks2 = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string") {
          throw new RangeError("Invalid text node in JSON");
        }
        return schema.text(json.text, marks2);
      }
      var content2 = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content2, marks2);
    };
    Object.defineProperties(Node2.prototype, prototypeAccessors$3);
    TextNode = (function(Node4) {
      function TextNode2(type, attrs, content2, marks2) {
        Node4.call(this, type, attrs, null, marks2);
        if (!content2) {
          throw new RangeError("Empty text nodes are not allowed");
        }
        this.text = content2;
      }
      if (Node4) TextNode2.__proto__ = Node4;
      TextNode2.prototype = Object.create(Node4 && Node4.prototype);
      TextNode2.prototype.constructor = TextNode2;
      var prototypeAccessors$15 = { textContent: { configurable: true }, nodeSize: { configurable: true } };
      TextNode2.prototype.toString = function toString7() {
        if (this.type.spec.toDebugString) {
          return this.type.spec.toDebugString(this);
        }
        return wrapMarks(this.marks, JSON.stringify(this.text));
      };
      prototypeAccessors$15.textContent.get = function() {
        return this.text;
      };
      TextNode2.prototype.textBetween = function textBetween3(from4, to) {
        return this.text.slice(from4, to);
      };
      prototypeAccessors$15.nodeSize.get = function() {
        return this.text.length;
      };
      TextNode2.prototype.mark = function mark3(marks2) {
        return marks2 == this.marks ? this : new TextNode2(this.type, this.attrs, this.text, marks2);
      };
      TextNode2.prototype.withText = function withText(text3) {
        if (text3 == this.text) {
          return this;
        }
        return new TextNode2(this.type, this.attrs, text3, this.marks);
      };
      TextNode2.prototype.cut = function cut3(from4, to) {
        if (from4 === void 0) from4 = 0;
        if (to === void 0) to = this.text.length;
        if (from4 == 0 && to == this.text.length) {
          return this;
        }
        return this.withText(this.text.slice(from4, to));
      };
      TextNode2.prototype.eq = function eq12(other) {
        return this.sameMarkup(other) && this.text == other.text;
      };
      TextNode2.prototype.toJSON = function toJSON7() {
        var base2 = Node4.prototype.toJSON.call(this);
        base2.text = this.text;
        return base2;
      };
      Object.defineProperties(TextNode2.prototype, prototypeAccessors$15);
      return TextNode2;
    })(Node2);
    ContentMatch = function ContentMatch2(validEnd) {
      this.validEnd = validEnd;
      this.next = [];
      this.wrapCache = [];
    };
    prototypeAccessors$4 = { inlineContent: { configurable: true }, defaultType: { configurable: true }, edgeCount: { configurable: true } };
    ContentMatch.parse = function parse(string, nodeTypes) {
      var stream = new TokenStream(string, nodeTypes);
      if (stream.next == null) {
        return ContentMatch.empty;
      }
      var expr = parseExpr(stream);
      if (stream.next) {
        stream.err("Unexpected trailing text");
      }
      var match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    };
    ContentMatch.prototype.matchType = function matchType(type) {
      for (var i = 0; i < this.next.length; i += 2) {
        if (this.next[i] == type) {
          return this.next[i + 1];
        }
      }
      return null;
    };
    ContentMatch.prototype.matchFragment = function matchFragment(frag, start3, end2) {
      if (start3 === void 0) start3 = 0;
      if (end2 === void 0) end2 = frag.childCount;
      var cur = this;
      for (var i = start3; cur && i < end2; i++) {
        cur = cur.matchType(frag.child(i).type);
      }
      return cur;
    };
    prototypeAccessors$4.inlineContent.get = function() {
      var first = this.next[0];
      return first ? first.isInline : false;
    };
    prototypeAccessors$4.defaultType.get = function() {
      for (var i = 0; i < this.next.length; i += 2) {
        var type = this.next[i];
        if (!(type.isText || type.hasRequiredAttrs())) {
          return type;
        }
      }
    };
    ContentMatch.prototype.compatible = function compatible(other) {
      for (var i = 0; i < this.next.length; i += 2) {
        for (var j = 0; j < other.next.length; j += 2) {
          if (this.next[i] == other.next[j]) {
            return true;
          }
        }
      }
      return false;
    };
    ContentMatch.prototype.fillBefore = function fillBefore(after2, toEnd, startIndex) {
      if (toEnd === void 0) toEnd = false;
      if (startIndex === void 0) startIndex = 0;
      var seen = [this];
      function search(match, types) {
        var finished = match.matchFragment(after2, startIndex);
        if (finished && (!toEnd || finished.validEnd)) {
          return Fragment.from(types.map(function(tp) {
            return tp.createAndFill();
          }));
        }
        for (var i = 0; i < match.next.length; i += 2) {
          var type = match.next[i], next = match.next[i + 1];
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            var found2 = search(next, types.concat(type));
            if (found2) {
              return found2;
            }
          }
        }
      }
      return search(this, []);
    };
    ContentMatch.prototype.findWrapping = function findWrapping(target2) {
      for (var i = 0; i < this.wrapCache.length; i += 2) {
        if (this.wrapCache[i] == target2) {
          return this.wrapCache[i + 1];
        }
      }
      var computed = this.computeWrapping(target2);
      this.wrapCache.push(target2, computed);
      return computed;
    };
    ContentMatch.prototype.computeWrapping = function computeWrapping(target2) {
      var seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
      while (active.length) {
        var current = active.shift(), match = current.match;
        if (match.matchType(target2)) {
          var result2 = [];
          for (var obj = current; obj.type; obj = obj.via) {
            result2.push(obj.type);
          }
          return result2.reverse();
        }
        for (var i = 0; i < match.next.length; i += 2) {
          var type = match.next[i];
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
            active.push({ match: type.contentMatch, type, via: current });
            seen[type.name] = true;
          }
        }
      }
    };
    prototypeAccessors$4.edgeCount.get = function() {
      return this.next.length >> 1;
    };
    ContentMatch.prototype.edge = function edge(n) {
      var i = n << 1;
      if (i >= this.next.length) {
        throw new RangeError("There's no " + n + "th edge in this content match");
      }
      return { type: this.next[i], next: this.next[i + 1] };
    };
    ContentMatch.prototype.toString = function toString5() {
      var seen = [];
      function scan(m) {
        seen.push(m);
        for (var i = 1; i < m.next.length; i += 2) {
          if (seen.indexOf(m.next[i]) == -1) {
            scan(m.next[i]);
          }
        }
      }
      scan(this);
      return seen.map(function(m, i) {
        var out = i + (m.validEnd ? "*" : " ") + " ";
        for (var i$1 = 0; i$1 < m.next.length; i$1 += 2) {
          out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]);
        }
        return out;
      }).join("\n");
    };
    Object.defineProperties(ContentMatch.prototype, prototypeAccessors$4);
    ContentMatch.empty = new ContentMatch(true);
    TokenStream = function TokenStream2(string, nodeTypes) {
      this.string = string;
      this.nodeTypes = nodeTypes;
      this.inline = null;
      this.pos = 0;
      this.tokens = string.split(/\s*(?=\b|\W|$)/);
      if (this.tokens[this.tokens.length - 1] == "") {
        this.tokens.pop();
      }
      if (this.tokens[0] == "") {
        this.tokens.shift();
      }
    };
    prototypeAccessors$1$2 = { next: { configurable: true } };
    prototypeAccessors$1$2.next.get = function() {
      return this.tokens[this.pos];
    };
    TokenStream.prototype.eat = function eat(tok) {
      return this.next == tok && (this.pos++ || true);
    };
    TokenStream.prototype.err = function err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    };
    Object.defineProperties(TokenStream.prototype, prototypeAccessors$1$2);
    NodeType = function NodeType2(name, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.groups = spec.group ? spec.group.split(" ") : [];
      this.attrs = initAttrs(spec.attrs);
      this.defaultAttrs = defaultAttrs(this.attrs);
      this.contentMatch = null;
      this.markSet = null;
      this.inlineContent = null;
      this.isBlock = !(spec.inline || name == "text");
      this.isText = name == "text";
    };
    prototypeAccessors$5 = { isInline: { configurable: true }, isTextblock: { configurable: true }, isLeaf: { configurable: true }, isAtom: { configurable: true } };
    prototypeAccessors$5.isInline.get = function() {
      return !this.isBlock;
    };
    prototypeAccessors$5.isTextblock.get = function() {
      return this.isBlock && this.inlineContent;
    };
    prototypeAccessors$5.isLeaf.get = function() {
      return this.contentMatch == ContentMatch.empty;
    };
    prototypeAccessors$5.isAtom.get = function() {
      return this.isLeaf || this.spec.atom;
    };
    NodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs() {
      for (var n in this.attrs) {
        if (this.attrs[n].isRequired) {
          return true;
        }
      }
      return false;
    };
    NodeType.prototype.compatibleContent = function compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    };
    NodeType.prototype.computeAttrs = function computeAttrs$1(attrs) {
      if (!attrs && this.defaultAttrs) {
        return this.defaultAttrs;
      } else {
        return computeAttrs(this.attrs, attrs);
      }
    };
    NodeType.prototype.create = function create(attrs, content2, marks2) {
      if (this.isText) {
        throw new Error("NodeType.create can't construct text nodes");
      }
      return new Node2(this, this.computeAttrs(attrs), Fragment.from(content2), Mark.setFrom(marks2));
    };
    NodeType.prototype.createChecked = function createChecked(attrs, content2, marks2) {
      content2 = Fragment.from(content2);
      if (!this.validContent(content2)) {
        throw new RangeError("Invalid content for node " + this.name);
      }
      return new Node2(this, this.computeAttrs(attrs), content2, Mark.setFrom(marks2));
    };
    NodeType.prototype.createAndFill = function createAndFill(attrs, content2, marks2) {
      attrs = this.computeAttrs(attrs);
      content2 = Fragment.from(content2);
      if (content2.size) {
        var before2 = this.contentMatch.fillBefore(content2);
        if (!before2) {
          return null;
        }
        content2 = before2.append(content2);
      }
      var after2 = this.contentMatch.matchFragment(content2).fillBefore(Fragment.empty, true);
      if (!after2) {
        return null;
      }
      return new Node2(this, attrs, content2.append(after2), Mark.setFrom(marks2));
    };
    NodeType.prototype.validContent = function validContent(content2) {
      var result2 = this.contentMatch.matchFragment(content2);
      if (!result2 || !result2.validEnd) {
        return false;
      }
      for (var i = 0; i < content2.childCount; i++) {
        if (!this.allowsMarks(content2.child(i).marks)) {
          return false;
        }
      }
      return true;
    };
    NodeType.prototype.allowsMarkType = function allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    };
    NodeType.prototype.allowsMarks = function allowsMarks(marks2) {
      if (this.markSet == null) {
        return true;
      }
      for (var i = 0; i < marks2.length; i++) {
        if (!this.allowsMarkType(marks2[i].type)) {
          return false;
        }
      }
      return true;
    };
    NodeType.prototype.allowedMarks = function allowedMarks(marks2) {
      if (this.markSet == null) {
        return marks2;
      }
      var copy6;
      for (var i = 0; i < marks2.length; i++) {
        if (!this.allowsMarkType(marks2[i].type)) {
          if (!copy6) {
            copy6 = marks2.slice(0, i);
          }
        } else if (copy6) {
          copy6.push(marks2[i]);
        }
      }
      return !copy6 ? marks2 : copy6.length ? copy6 : Mark.empty;
    };
    NodeType.compile = function compile(nodes, schema) {
      var result2 = /* @__PURE__ */ Object.create(null);
      nodes.forEach(function(name, spec) {
        return result2[name] = new NodeType(name, schema, spec);
      });
      var topType = schema.spec.topNode || "doc";
      if (!result2[topType]) {
        throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      }
      if (!result2.text) {
        throw new RangeError("Every schema needs a 'text' type");
      }
      for (var _ in result2.text.attrs) {
        throw new RangeError("The text node type should not have attributes");
      }
      return result2;
    };
    Object.defineProperties(NodeType.prototype, prototypeAccessors$5);
    Attribute = function Attribute2(options) {
      this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
      this.default = options.default;
    };
    prototypeAccessors$1$3 = { isRequired: { configurable: true } };
    prototypeAccessors$1$3.isRequired.get = function() {
      return !this.hasDefault;
    };
    Object.defineProperties(Attribute.prototype, prototypeAccessors$1$3);
    MarkType = function MarkType2(name, rank, schema, spec) {
      this.name = name;
      this.schema = schema;
      this.spec = spec;
      this.attrs = initAttrs(spec.attrs);
      this.rank = rank;
      this.excluded = null;
      var defaults = defaultAttrs(this.attrs);
      this.instance = defaults && new Mark(this, defaults);
    };
    MarkType.prototype.create = function create2(attrs) {
      if (!attrs && this.instance) {
        return this.instance;
      }
      return new Mark(this, computeAttrs(this.attrs, attrs));
    };
    MarkType.compile = function compile2(marks2, schema) {
      var result2 = /* @__PURE__ */ Object.create(null), rank = 0;
      marks2.forEach(function(name, spec) {
        return result2[name] = new MarkType(name, rank++, schema, spec);
      });
      return result2;
    };
    MarkType.prototype.removeFromSet = function removeFromSet2(set2) {
      for (var i = 0; i < set2.length; i++) {
        if (set2[i].type == this) {
          set2 = set2.slice(0, i).concat(set2.slice(i + 1));
          i--;
        }
      }
      return set2;
    };
    MarkType.prototype.isInSet = function isInSet2(set2) {
      for (var i = 0; i < set2.length; i++) {
        if (set2[i].type == this) {
          return set2[i];
        }
      }
    };
    MarkType.prototype.excludes = function excludes(other) {
      return this.excluded.indexOf(other) > -1;
    };
    Schema = function Schema2(spec) {
      this.spec = {};
      for (var prop2 in spec) {
        this.spec[prop2] = spec[prop2];
      }
      this.spec.nodes = index_es_default.from(spec.nodes);
      this.spec.marks = index_es_default.from(spec.marks);
      this.nodes = NodeType.compile(this.spec.nodes, this);
      this.marks = MarkType.compile(this.spec.marks, this);
      var contentExprCache = /* @__PURE__ */ Object.create(null);
      for (var prop$1 in this.nodes) {
        if (prop$1 in this.marks) {
          throw new RangeError(prop$1 + " can not be both a node and a mark");
        }
        var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
        type.inlineContent = type.contentMatch.inlineContent;
        type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
      }
      for (var prop$2 in this.marks) {
        var type$1 = this.marks[prop$2], excl2 = type$1.spec.excludes;
        type$1.excluded = excl2 == null ? [type$1] : excl2 == "" ? [] : gatherMarks(this, excl2.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this);
      this.markFromJSON = this.markFromJSON.bind(this);
      this.topNodeType = this.nodes[this.spec.topNode || "doc"];
      this.cached = /* @__PURE__ */ Object.create(null);
      this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    };
    Schema.prototype.node = function node2(type, attrs, content2, marks2) {
      if (typeof type == "string") {
        type = this.nodeType(type);
      } else if (!(type instanceof NodeType)) {
        throw new RangeError("Invalid node type: " + type);
      } else if (type.schema != this) {
        throw new RangeError("Node type from different schema used (" + type.name + ")");
      }
      return type.createChecked(attrs, content2, marks2);
    };
    Schema.prototype.text = function text(text$12, marks2) {
      var type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, text$12, Mark.setFrom(marks2));
    };
    Schema.prototype.mark = function mark2(type, attrs) {
      if (typeof type == "string") {
        type = this.marks[type];
      }
      return type.create(attrs);
    };
    Schema.prototype.nodeFromJSON = function nodeFromJSON(json) {
      return Node2.fromJSON(this, json);
    };
    Schema.prototype.markFromJSON = function markFromJSON(json) {
      return Mark.fromJSON(this, json);
    };
    Schema.prototype.nodeType = function nodeType(name) {
      var found2 = this.nodes[name];
      if (!found2) {
        throw new RangeError("Unknown node type: " + name);
      }
      return found2;
    };
    DOMParser = function DOMParser2(schema, rules) {
      var this$1 = this;
      this.schema = schema;
      this.rules = rules;
      this.tags = [];
      this.styles = [];
      rules.forEach(function(rule) {
        if (rule.tag) {
          this$1.tags.push(rule);
        } else if (rule.style) {
          this$1.styles.push(rule);
        }
      });
      this.normalizeLists = !this.tags.some(function(r) {
        if (!/^(ul|ol)\b/.test(r.tag) || !r.node) {
          return false;
        }
        var node4 = schema.nodes[r.node];
        return node4.contentMatch.matchType(node4);
      });
    };
    DOMParser.prototype.parse = function parse2(dom, options) {
      if (options === void 0) options = {};
      var context = new ParseContext(this, options, false);
      context.addAll(dom, null, options.from, options.to);
      return context.finish();
    };
    DOMParser.prototype.parseSlice = function parseSlice(dom, options) {
      if (options === void 0) options = {};
      var context = new ParseContext(this, options, true);
      context.addAll(dom, null, options.from, options.to);
      return Slice.maxOpen(context.finish());
    };
    DOMParser.prototype.matchTag = function matchTag(dom, context, after2) {
      for (var i = after2 ? this.tags.indexOf(after2) + 1 : 0; i < this.tags.length; i++) {
        var rule = this.tags[i];
        if (matches2(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            var result2 = rule.getAttrs(dom);
            if (result2 === false) {
              continue;
            }
            rule.attrs = result2;
          }
          return rule;
        }
      }
    };
    DOMParser.prototype.matchStyle = function matchStyle(prop2, value, context, after2) {
      for (var i = after2 ? this.styles.indexOf(after2) + 1 : 0; i < this.styles.length; i++) {
        var rule = this.styles[i];
        if (rule.style.indexOf(prop2) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        rule.style.length > prop2.length && (rule.style.charCodeAt(prop2.length) != 61 || rule.style.slice(prop2.length + 1) != value)) {
          continue;
        }
        if (rule.getAttrs) {
          var result2 = rule.getAttrs(value);
          if (result2 === false) {
            continue;
          }
          rule.attrs = result2;
        }
        return rule;
      }
    };
    DOMParser.schemaRules = function schemaRules(schema) {
      var result2 = [];
      function insert(rule) {
        var priority = rule.priority == null ? 50 : rule.priority, i = 0;
        for (; i < result2.length; i++) {
          var next = result2[i], nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) {
            break;
          }
        }
        result2.splice(i, 0, rule);
      }
      var loop = function(name2) {
        var rules = schema.marks[name2].spec.parseDOM;
        if (rules) {
          rules.forEach(function(rule) {
            insert(rule = copy2(rule));
            rule.mark = name2;
          });
        }
      };
      for (var name in schema.marks) loop(name);
      var loop$1 = function(name2) {
        var rules$1 = schema.nodes[name$1].spec.parseDOM;
        if (rules$1) {
          rules$1.forEach(function(rule) {
            insert(rule = copy2(rule));
            rule.node = name$1;
          });
        }
      };
      for (var name$1 in schema.nodes) loop$1();
      return result2;
    };
    DOMParser.fromSchema = function fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
    };
    blockTags = {
      address: true,
      article: true,
      aside: true,
      blockquote: true,
      canvas: true,
      dd: true,
      div: true,
      dl: true,
      fieldset: true,
      figcaption: true,
      figure: true,
      footer: true,
      form: true,
      h1: true,
      h2: true,
      h3: true,
      h4: true,
      h5: true,
      h6: true,
      header: true,
      hgroup: true,
      hr: true,
      li: true,
      noscript: true,
      ol: true,
      output: true,
      p: true,
      pre: true,
      section: true,
      table: true,
      tfoot: true,
      ul: true
    };
    ignoreTags = {
      head: true,
      noscript: true,
      object: true,
      script: true,
      style: true,
      title: true
    };
    listTags = { ol: true, ul: true };
    OPT_PRESERVE_WS = 1;
    OPT_PRESERVE_WS_FULL = 2;
    OPT_OPEN_LEFT = 4;
    NodeContext = function NodeContext2(type, attrs, marks2, pendingMarks, solid, match, options) {
      this.type = type;
      this.attrs = attrs;
      this.solid = solid;
      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
      this.options = options;
      this.content = [];
      this.marks = marks2;
      this.activeMarks = Mark.none;
      this.pendingMarks = pendingMarks;
      this.stashMarks = [];
    };
    NodeContext.prototype.findWrapping = function findWrapping2(node4) {
      if (!this.match) {
        if (!this.type) {
          return [];
        }
        var fill = this.type.contentMatch.fillBefore(Fragment.from(node4));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          var start3 = this.type.contentMatch, wrap;
          if (wrap = start3.findWrapping(node4.type)) {
            this.match = start3;
            return wrap;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node4.type);
    };
    NodeContext.prototype.finish = function finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        var last2 = this.content[this.content.length - 1], m;
        if (last2 && last2.isText && (m = /[ \t\r\n\u000c]+$/.exec(last2.text))) {
          if (last2.text.length == m[0].length) {
            this.content.pop();
          } else {
            this.content[this.content.length - 1] = last2.withText(last2.text.slice(0, last2.text.length - m[0].length));
          }
        }
      }
      var content2 = Fragment.from(this.content);
      if (!openEnd && this.match) {
        content2 = content2.append(this.match.fillBefore(Fragment.empty, true));
      }
      return this.type ? this.type.create(this.attrs, content2, this.marks) : content2;
    };
    NodeContext.prototype.popFromStashMark = function popFromStashMark(mark3) {
      for (var i = this.stashMarks.length - 1; i >= 0; i--) {
        if (mark3.eq(this.stashMarks[i])) {
          return this.stashMarks.splice(i, 1)[0];
        }
      }
    };
    NodeContext.prototype.applyPending = function applyPending(nextType) {
      for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        var mark3 = pending[i];
        if ((this.type ? this.type.allowsMarkType(mark3.type) : markMayApply(mark3.type, nextType)) && !mark3.isInSet(this.activeMarks)) {
          this.activeMarks = mark3.addToSet(this.activeMarks);
          this.pendingMarks = mark3.removeFromSet(this.pendingMarks);
        }
      }
    };
    NodeContext.prototype.inlineContext = function inlineContext(node4) {
      if (this.type) {
        return this.type.inlineContent;
      }
      if (this.content.length) {
        return this.content[0].isInline;
      }
      return node4.parentNode && !blockTags.hasOwnProperty(node4.parentNode.nodeName.toLowerCase());
    };
    ParseContext = function ParseContext2(parser, options, open) {
      this.parser = parser;
      this.options = options;
      this.isOpen = open;
      var topNode = options.topNode, topContext;
      var topOptions = wsOptionsFor(options.preserveWhitespace) | (open ? OPT_OPEN_LEFT : 0);
      if (topNode) {
        topContext = new NodeContext(
          topNode.type,
          topNode.attrs,
          Mark.none,
          Mark.none,
          true,
          options.topMatch || topNode.type.contentMatch,
          topOptions
        );
      } else if (open) {
        topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);
      } else {
        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
      }
      this.nodes = [topContext];
      this.open = 0;
      this.find = options.findPositions;
      this.needsBlock = false;
    };
    prototypeAccessors$6 = { top: { configurable: true }, currentPos: { configurable: true } };
    prototypeAccessors$6.top.get = function() {
      return this.nodes[this.open];
    };
    ParseContext.prototype.addDOM = function addDOM(dom) {
      if (dom.nodeType == 3) {
        this.addTextNode(dom);
      } else if (dom.nodeType == 1) {
        var style = dom.getAttribute("style");
        var marks2 = style ? this.readStyles(parseStyles(style)) : null, top2 = this.top;
        if (marks2 != null) {
          for (var i = 0; i < marks2.length; i++) {
            this.addPendingMark(marks2[i]);
          }
        }
        this.addElement(dom);
        if (marks2 != null) {
          for (var i$1 = 0; i$1 < marks2.length; i$1++) {
            this.removePendingMark(marks2[i$1], top2);
          }
        }
      }
    };
    ParseContext.prototype.addTextNode = function addTextNode(dom) {
      var value = dom.nodeValue;
      var top2 = this.top;
      if (top2.options & OPT_PRESERVE_WS_FULL || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top2.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            var nodeBefore = top2.content[top2.content.length - 1];
            var domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) {
              value = value.slice(1);
            }
          }
        } else if (!(top2.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value) {
          this.insertNode(this.parser.schema.text(value));
        }
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    };
    ParseContext.prototype.addElement = function addElement(dom, matchAfter) {
      var name = dom.nodeName.toLowerCase(), ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) {
        normalizeList(dom);
      }
      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) {
          this.open = Math.max(0, this.open - 1);
        } else if (rule && rule.skip.nodeType) {
          dom = rule.skip;
        }
        var sync2, top2 = this.top, oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          sync2 = true;
          if (!top2.type) {
            this.needsBlock = true;
          }
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }
        this.addAll(dom);
        if (sync2) {
          this.sync(top2);
        }
        this.needsBlock = oldNeedsBlock;
      } else {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
      }
    };
    ParseContext.prototype.leafFallback = function leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) {
        this.addTextNode(dom.ownerDocument.createTextNode("\n"));
      }
    };
    ParseContext.prototype.ignoreFallback = function ignoreFallback(dom) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) {
        this.findPlace(this.parser.schema.text("-"));
      }
    };
    ParseContext.prototype.readStyles = function readStyles(styles) {
      var marks2 = Mark.none;
      style: for (var i = 0; i < styles.length; i += 2) {
        for (var after2 = null; ; ) {
          var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after2);
          if (!rule) {
            continue style;
          }
          if (rule.ignore) {
            return null;
          }
          marks2 = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks2);
          if (rule.consuming === false) {
            after2 = rule;
          } else {
            break;
          }
        }
      }
      return marks2;
    };
    ParseContext.prototype.addElementByRule = function addElementByRule(dom, rule, continueAfter) {
      var this$1 = this;
      var sync2, nodeType2, markType, mark3;
      if (rule.node) {
        nodeType2 = this.parser.schema.nodes[rule.node];
        if (!nodeType2.isLeaf) {
          sync2 = this.enter(nodeType2, rule.attrs, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType2.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        markType = this.parser.schema.marks[rule.mark];
        mark3 = markType.create(rule.attrs);
        this.addPendingMark(mark3);
      }
      var startIn = this.top;
      if (nodeType2 && nodeType2.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach(function(node4) {
          return this$1.insertNode(node4);
        });
      } else {
        var contentDOM = rule.contentElement;
        if (typeof contentDOM == "string") {
          contentDOM = dom.querySelector(contentDOM);
        } else if (typeof contentDOM == "function") {
          contentDOM = contentDOM(dom);
        }
        if (!contentDOM) {
          contentDOM = dom;
        }
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM, sync2);
      }
      if (sync2) {
        this.sync(startIn);
        this.open--;
      }
      if (mark3) {
        this.removePendingMark(mark3, startIn);
      }
    };
    ParseContext.prototype.addAll = function addAll(parent, sync2, startIndex, endIndex) {
      var index3 = startIndex || 0;
      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index3) {
        this.findAtPoint(parent, index3);
        this.addDOM(dom);
        if (sync2 && blockTags.hasOwnProperty(dom.nodeName.toLowerCase())) {
          this.sync(sync2);
        }
      }
      this.findAtPoint(parent, index3);
    };
    ParseContext.prototype.findPlace = function findPlace(node4) {
      var route, sync2;
      for (var depth = this.open; depth >= 0; depth--) {
        var cx = this.nodes[depth];
        var found2 = cx.findWrapping(node4);
        if (found2 && (!route || route.length > found2.length)) {
          route = found2;
          sync2 = cx;
          if (!found2.length) {
            break;
          }
        }
        if (cx.solid) {
          break;
        }
      }
      if (!route) {
        return false;
      }
      this.sync(sync2);
      for (var i = 0; i < route.length; i++) {
        this.enterInner(route[i], null, false);
      }
      return true;
    };
    ParseContext.prototype.insertNode = function insertNode(node4) {
      if (node4.isInline && this.needsBlock && !this.top.type) {
        var block2 = this.textblockFromContext();
        if (block2) {
          this.enterInner(block2);
        }
      }
      if (this.findPlace(node4)) {
        this.closeExtra();
        var top2 = this.top;
        top2.applyPending(node4.type);
        if (top2.match) {
          top2.match = top2.match.matchType(node4.type);
        }
        var marks2 = top2.activeMarks;
        for (var i = 0; i < node4.marks.length; i++) {
          if (!top2.type || top2.type.allowsMarkType(node4.marks[i].type)) {
            marks2 = node4.marks[i].addToSet(marks2);
          }
        }
        top2.content.push(node4.mark(marks2));
        return true;
      }
      return false;
    };
    ParseContext.prototype.enter = function enter(type, attrs, preserveWS) {
      var ok2 = this.findPlace(type.create(attrs));
      if (ok2) {
        this.enterInner(type, attrs, true, preserveWS);
      }
      return ok2;
    };
    ParseContext.prototype.enterInner = function enterInner(type, attrs, solid, preserveWS) {
      this.closeExtra();
      var top2 = this.top;
      top2.applyPending(type);
      top2.match = top2.match && top2.match.matchType(type, attrs);
      var options = preserveWS == null ? top2.options & ~OPT_OPEN_LEFT : wsOptionsFor(preserveWS);
      if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0) {
        options |= OPT_OPEN_LEFT;
      }
      this.nodes.push(new NodeContext(type, attrs, top2.activeMarks, top2.pendingMarks, solid, null, options));
      this.open++;
    };
    ParseContext.prototype.closeExtra = function closeExtra(openEnd) {
      var i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--) {
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        }
        this.nodes.length = this.open + 1;
      }
    };
    ParseContext.prototype.finish = function finish2() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    };
    ParseContext.prototype.sync = function sync(to) {
      for (var i = this.open; i >= 0; i--) {
        if (this.nodes[i] == to) {
          this.open = i;
          return;
        }
      }
    };
    prototypeAccessors$6.currentPos.get = function() {
      this.closeExtra();
      var pos = 0;
      for (var i = this.open; i >= 0; i--) {
        var content2 = this.nodes[i].content;
        for (var j = content2.length - 1; j >= 0; j--) {
          pos += content2[j].nodeSize;
        }
        if (i) {
          pos++;
        }
      }
      return pos;
    };
    ParseContext.prototype.findAtPoint = function findAtPoint(parent, offset2) {
      if (this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].node == parent && this.find[i].offset == offset2) {
            this.find[i].pos = this.currentPos;
          }
        }
      }
    };
    ParseContext.prototype.findInside = function findInside(parent) {
      if (this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            this.find[i].pos = this.currentPos;
          }
        }
      }
    };
    ParseContext.prototype.findAround = function findAround(parent, content2, before2) {
      if (parent != content2 && this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
            var pos = content2.compareDocumentPosition(this.find[i].node);
            if (pos & (before2 ? 2 : 4)) {
              this.find[i].pos = this.currentPos;
            }
          }
        }
      }
    };
    ParseContext.prototype.findInText = function findInText(textNode) {
      if (this.find) {
        for (var i = 0; i < this.find.length; i++) {
          if (this.find[i].node == textNode) {
            this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
          }
        }
      }
    };
    ParseContext.prototype.matchesContext = function matchesContext(context) {
      var this$1 = this;
      if (context.indexOf("|") > -1) {
        return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      }
      var parts = context.split("/");
      var option = this.options.context;
      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      var match = function(i, depth) {
        for (; i >= 0; i--) {
          var part2 = parts[i];
          if (part2 == "") {
            if (i == parts.length - 1 || i == 0) {
              continue;
            }
            for (; depth >= minDepth; depth--) {
              if (match(i - 1, depth)) {
                return true;
              }
            }
            return false;
          } else {
            var next = depth > 0 || depth == 0 && useRoot ? this$1.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part2 && next.groups.indexOf(part2) == -1) {
              return false;
            }
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    };
    ParseContext.prototype.textblockFromContext = function textblockFromContext() {
      var $context = this.options.context;
      if ($context) {
        for (var d = $context.depth; d >= 0; d--) {
          var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
          if (deflt && deflt.isTextblock && deflt.defaultAttrs) {
            return deflt;
          }
        }
      }
      for (var name in this.parser.schema.nodes) {
        var type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) {
          return type;
        }
      }
    };
    ParseContext.prototype.addPendingMark = function addPendingMark(mark3) {
      var found2 = findSameMarkInSet(mark3, this.top.pendingMarks);
      if (found2) {
        this.top.stashMarks.push(found2);
      }
      this.top.pendingMarks = mark3.addToSet(this.top.pendingMarks);
    };
    ParseContext.prototype.removePendingMark = function removePendingMark(mark3, upto) {
      for (var depth = this.open; depth >= 0; depth--) {
        var level = this.nodes[depth];
        var found2 = level.pendingMarks.lastIndexOf(mark3);
        if (found2 > -1) {
          level.pendingMarks = mark3.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark3.removeFromSet(level.activeMarks);
          var stashMark = level.popFromStashMark(mark3);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) {
            level.activeMarks = stashMark.addToSet(level.activeMarks);
          }
        }
        if (level == upto) {
          break;
        }
      }
    };
    Object.defineProperties(ParseContext.prototype, prototypeAccessors$6);
    DOMSerializer = function DOMSerializer2(nodes, marks2) {
      this.nodes = nodes || {};
      this.marks = marks2 || {};
    };
    DOMSerializer.prototype.serializeFragment = function serializeFragment(fragment, options, target2) {
      var this$1 = this;
      if (options === void 0) options = {};
      if (!target2) {
        target2 = doc(options).createDocumentFragment();
      }
      var top2 = target2, active = null;
      fragment.forEach(function(node4) {
        if (active || node4.marks.length) {
          if (!active) {
            active = [];
          }
          var keep = 0, rendered = 0;
          while (keep < active.length && rendered < node4.marks.length) {
            var next = node4.marks[rendered];
            if (!this$1.marks[next.type.name]) {
              rendered++;
              continue;
            }
            if (!next.eq(active[keep]) || next.type.spec.spanning === false) {
              break;
            }
            keep += 2;
            rendered++;
          }
          while (keep < active.length) {
            top2 = active.pop();
            active.pop();
          }
          while (rendered < node4.marks.length) {
            var add2 = node4.marks[rendered++];
            var markDOM = this$1.serializeMark(add2, node4.isInline, options);
            if (markDOM) {
              active.push(add2, top2);
              top2.appendChild(markDOM.dom);
              top2 = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top2.appendChild(this$1.serializeNodeInner(node4, options));
      });
      return target2;
    };
    DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner(node4, options) {
      if (options === void 0) options = {};
      var ref = DOMSerializer.renderSpec(doc(options), this.nodes[node4.type.name](node4));
      var dom = ref.dom;
      var contentDOM = ref.contentDOM;
      if (contentDOM) {
        if (node4.isLeaf) {
          throw new RangeError("Content hole not allowed in a leaf node spec");
        }
        if (options.onContent) {
          options.onContent(node4, contentDOM, options);
        } else {
          this.serializeFragment(node4.content, options, contentDOM);
        }
      }
      return dom;
    };
    DOMSerializer.prototype.serializeNode = function serializeNode(node4, options) {
      if (options === void 0) options = {};
      var dom = this.serializeNodeInner(node4, options);
      for (var i = node4.marks.length - 1; i >= 0; i--) {
        var wrap = this.serializeMark(node4.marks[i], node4.isInline, options);
        if (wrap) {
          (wrap.contentDOM || wrap.dom).appendChild(dom);
          dom = wrap.dom;
        }
      }
      return dom;
    };
    DOMSerializer.prototype.serializeMark = function serializeMark(mark3, inline2, options) {
      if (options === void 0) options = {};
      var toDOM = this.marks[mark3.type.name];
      return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark3, inline2));
    };
    DOMSerializer.renderSpec = function renderSpec(doc2, structure, xmlNS) {
      if (xmlNS === void 0) xmlNS = null;
      if (typeof structure == "string") {
        return { dom: doc2.createTextNode(structure) };
      }
      if (structure.nodeType != null) {
        return { dom: structure };
      }
      if (structure.dom && structure.dom.nodeType != null) {
        return structure;
      }
      var tagName = structure[0], space = tagName.indexOf(" ");
      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }
      var contentDOM = null, dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
      var attrs = structure[1], start3 = 1;
      if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start3 = 2;
        for (var name in attrs) {
          if (attrs[name] != null) {
            var space$1 = name.indexOf(" ");
            if (space$1 > 0) {
              dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]);
            } else {
              dom.setAttribute(name, attrs[name]);
            }
          }
        }
      }
      for (var i = start3; i < structure.length; i++) {
        var child3 = structure[i];
        if (child3 === 0) {
          if (i < structure.length - 1 || i > start3) {
            throw new RangeError("Content hole must be the only child of its parent node");
          }
          return { dom, contentDOM: dom };
        } else {
          var ref = DOMSerializer.renderSpec(doc2, child3, xmlNS);
          var inner = ref.dom;
          var innerContent = ref.contentDOM;
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM) {
              throw new RangeError("Multiple content holes");
            }
            contentDOM = innerContent;
          }
        }
      }
      return { dom, contentDOM };
    };
    DOMSerializer.fromSchema = function fromSchema2(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    };
    DOMSerializer.nodesFromSchema = function nodesFromSchema(schema) {
      var result2 = gatherToDOM(schema.nodes);
      if (!result2.text) {
        result2.text = function(node4) {
          return node4.text;
        };
      }
      return result2;
    };
    DOMSerializer.marksFromSchema = function marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    };
  }
});

// ../../node_modules/.pnpm/prosemirror-transform@1.3.4/node_modules/prosemirror-transform/dist/index.es.js
function makeRecover(index3, offset2) {
  return index3 + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
function TransformError(message) {
  var err2 = Error.call(this, message);
  err2.__proto__ = TransformError.prototype;
  return err2;
}
function mustOverride() {
  throw new Error("Override me");
}
function contentBetween(doc2, from4, to) {
  var $from = doc2.resolve(from4), dist = to - from4, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) {
        return true;
      }
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function canCut(node4, start3, end2) {
  return (start3 == 0 || node4.canReplace(start3, node4.childCount)) && (end2 == node4.childCount || node4.canReplace(0, end2));
}
function liftTarget(range2) {
  var parent = range2.parent;
  var content2 = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
  for (var depth = range2.depth; ; --depth) {
    var node4 = range2.$from.node(depth);
    var index3 = range2.$from.index(depth), endIndex = range2.$to.indexAfter(depth);
    if (depth < range2.depth && node4.canReplace(index3, endIndex, content2)) {
      return depth;
    }
    if (depth == 0 || node4.type.spec.isolating || !canCut(node4, index3, endIndex)) {
      break;
    }
  }
}
function findWrapping3(range2, nodeType2, attrs, innerRange) {
  if (innerRange === void 0) innerRange = range2;
  var around = findWrappingOutside(range2, nodeType2);
  var inner = around && findWrappingInside(innerRange, nodeType2);
  if (!inner) {
    return null;
  }
  return around.map(withAttrs).concat({ type: nodeType2, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return { type, attrs: null };
}
function findWrappingOutside(range2, type) {
  var parent = range2.parent;
  var startIndex = range2.startIndex;
  var endIndex = range2.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) {
    return null;
  }
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range2, type) {
  var parent = range2.parent;
  var startIndex = range2.startIndex;
  var endIndex = range2.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) {
    return null;
  }
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;
  for (var i = startIndex; innerMatch && i < endIndex; i++) {
    innerMatch = innerMatch.matchType(parent.child(i).type);
  }
  if (!innerMatch || !innerMatch.validEnd) {
    return null;
  }
  return inside;
}
function canChangeType(doc2, pos, type) {
  var $pos = doc2.resolve(pos), index3 = $pos.index();
  return $pos.parent.canReplaceWith(index3, index3 + 1, type);
}
function canSplit(doc2, pos, depth, typesAfter) {
  if (depth === void 0) depth = 1;
  var $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) {
    return false;
  }
  for (var d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {
    var node4 = $pos.node(d), index$1 = $pos.index(d);
    if (node4.type.spec.isolating) {
      return false;
    }
    var rest = node4.content.cutByIndex(index$1, node4.childCount);
    var after2 = typesAfter && typesAfter[i] || node4;
    if (after2 != node4) {
      rest = rest.replaceChild(0, after2.type.create(after2.attrs));
    }
    if (!node4.canReplace(index$1 + 1, node4.childCount) || !after2.type.validContent(rest)) {
      return false;
    }
  }
  var index3 = $pos.indexAfter(base2);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index3, index3, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function canJoin(doc2, pos) {
  var $pos = doc2.resolve(pos), index3 = $pos.index();
  return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index3, index3 + 1);
}
function joinable2(a, b) {
  return a && b && !a.isLeaf && a.canAppend(b);
}
function insertPoint(doc2, pos, nodeType2) {
  var $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType2)) {
    return pos;
  }
  if ($pos.parentOffset == 0) {
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index3 = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index3, index3, nodeType2)) {
        return $pos.before(d + 1);
      }
      if (index3 > 0) {
        return null;
      }
    }
  }
  if ($pos.parentOffset == $pos.parent.content.size) {
    for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType2)) {
        return $pos.after(d$1 + 1);
      }
      if (index$1 < $pos.node(d$1).childCount) {
        return null;
      }
    }
  }
}
function dropPoint(doc2, pos, slice4) {
  var $pos = doc2.resolve(pos);
  if (!slice4.content.size) {
    return pos;
  }
  var content2 = slice4.content;
  for (var i = 0; i < slice4.openStart; i++) {
    content2 = content2.firstChild.content;
  }
  for (var pass = 1; pass <= (slice4.openStart == 0 && slice4.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content2);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content2.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits) {
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
      }
    }
  }
  return null;
}
function mapFragment(fragment, f, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child3 = fragment.child(i);
    if (child3.content.size) {
      child3 = child3.copy(mapFragment(child3.content, f, child3));
    }
    if (child3.isInline) {
      child3 = f(child3, parent, i);
    }
    mapped.push(child3);
  }
  return Fragment.fromArray(mapped);
}
function replaceStep(doc2, from4, to, slice4) {
  if (to === void 0) to = from4;
  if (slice4 === void 0) slice4 = Slice.empty;
  if (from4 == to && !slice4.size) {
    return null;
  }
  var $from = doc2.resolve(from4), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice4)) {
    return new ReplaceStep(from4, to, slice4);
  }
  return new Fitter($from, $to, slice4).fit();
}
function fitsTrivially($from, $to, slice4) {
  return !slice4.openStart && !slice4.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice4.content);
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0) {
    return fragment.cutByIndex(count);
  }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content2) {
  if (depth == 0) {
    return fragment.append(content2);
  }
  return fragment.replaceChild(
    fragment.childCount - 1,
    fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content2))
  );
}
function contentAt(fragment, depth) {
  for (var i = 0; i < depth; i++) {
    fragment = fragment.firstChild.content;
  }
  return fragment;
}
function closeNodeStart(node4, openStart, openEnd) {
  if (openStart <= 0) {
    return node4;
  }
  var frag = node4.content;
  if (openStart > 1) {
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  }
  if (openStart > 0) {
    frag = node4.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) {
      frag = frag.append(node4.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
    }
  }
  return node4.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  var node4 = $to.node(depth), index3 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index3 == node4.childCount && !type.compatibleContent(node4.type)) {
    return null;
  }
  var fit2 = match.fillBefore(node4.content, true, index3);
  return fit2 && !invalidMarks(type, node4.content, index3) ? fit2 : null;
}
function invalidMarks(type, fragment, start3) {
  for (var i = start3; i < fragment.childCount; i++) {
    if (!type.allowsMarks(fragment.child(i).marks)) {
      return true;
    }
  }
  return false;
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start3 = match.fillBefore(fragment).append(fragment);
    fragment = start3.append(match.matchFragment(start3).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function coveredDepths($from, $to) {
  var result2 = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start3 = $from.start(d);
    if (start3 < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) {
      break;
    }
    if (start3 == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start3 - 1) {
      result2.push(d);
    }
  }
  return result2;
}
var lower16, factor16, MapResult, StepMap, Mapping, Transform, prototypeAccessors2, stepsByID, Step, StepResult, ReplaceStep, ReplaceAroundStep, AddMarkStep, RemoveMarkStep, Fitter, prototypeAccessors$12;
var init_index_es3 = __esm({
  "../../node_modules/.pnpm/prosemirror-transform@1.3.4/node_modules/prosemirror-transform/dist/index.es.js"() {
    init_index_es2();
    lower16 = 65535;
    factor16 = Math.pow(2, 16);
    MapResult = function MapResult2(pos, deleted, recover2) {
      if (deleted === void 0) deleted = false;
      if (recover2 === void 0) recover2 = null;
      this.pos = pos;
      this.deleted = deleted;
      this.recover = recover2;
    };
    StepMap = function StepMap2(ranges, inverted) {
      if (inverted === void 0) inverted = false;
      if (!ranges.length && StepMap2.empty) {
        return StepMap2.empty;
      }
      this.ranges = ranges;
      this.inverted = inverted;
    };
    StepMap.prototype.recover = function recover(value) {
      var diff2 = 0, index3 = recoverIndex(value);
      if (!this.inverted) {
        for (var i = 0; i < index3; i++) {
          diff2 += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
        }
      }
      return this.ranges[index3 * 3] + diff2 + recoverOffset(value);
    };
    StepMap.prototype.mapResult = function mapResult(pos, assoc) {
      if (assoc === void 0) assoc = 1;
      return this._map(pos, assoc, false);
    };
    StepMap.prototype.map = function map(pos, assoc) {
      if (assoc === void 0) assoc = 1;
      return this._map(pos, assoc, true);
    };
    StepMap.prototype._map = function _map(pos, assoc, simple) {
      var diff2 = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (var i = 0; i < this.ranges.length; i += 3) {
        var start3 = this.ranges[i] - (this.inverted ? diff2 : 0);
        if (start3 > pos) {
          break;
        }
        var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end2 = start3 + oldSize;
        if (pos <= end2) {
          var side = !oldSize ? assoc : pos == start3 ? -1 : pos == end2 ? 1 : assoc;
          var result2 = start3 + diff2 + (side < 0 ? 0 : newSize);
          if (simple) {
            return result2;
          }
          var recover2 = pos == (assoc < 0 ? start3 : end2) ? null : makeRecover(i / 3, pos - start3);
          return new MapResult(result2, assoc < 0 ? pos != start3 : pos != end2, recover2);
        }
        diff2 += newSize - oldSize;
      }
      return simple ? pos + diff2 : new MapResult(pos + diff2);
    };
    StepMap.prototype.touches = function touches(pos, recover2) {
      var diff2 = 0, index3 = recoverIndex(recover2);
      var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (var i = 0; i < this.ranges.length; i += 3) {
        var start3 = this.ranges[i] - (this.inverted ? diff2 : 0);
        if (start3 > pos) {
          break;
        }
        var oldSize = this.ranges[i + oldIndex], end2 = start3 + oldSize;
        if (pos <= end2 && i == index3 * 3) {
          return true;
        }
        diff2 += this.ranges[i + newIndex] - oldSize;
      }
      return false;
    };
    StepMap.prototype.forEach = function forEach3(f) {
      var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
      for (var i = 0, diff2 = 0; i < this.ranges.length; i += 3) {
        var start3 = this.ranges[i], oldStart = start3 - (this.inverted ? diff2 : 0), newStart = start3 + (this.inverted ? 0 : diff2);
        var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff2 += newSize - oldSize;
      }
    };
    StepMap.prototype.invert = function invert() {
      return new StepMap(this.ranges, !this.inverted);
    };
    StepMap.prototype.toString = function toString6() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    };
    StepMap.offset = function offset(n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    };
    StepMap.empty = new StepMap([]);
    Mapping = function Mapping2(maps, mirror, from4, to) {
      this.maps = maps || [];
      this.from = from4 || 0;
      this.to = to == null ? this.maps.length : to;
      this.mirror = mirror;
    };
    Mapping.prototype.slice = function slice2(from4, to) {
      if (from4 === void 0) from4 = 0;
      if (to === void 0) to = this.maps.length;
      return new Mapping(this.maps, this.mirror, from4, to);
    };
    Mapping.prototype.copy = function copy3() {
      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    };
    Mapping.prototype.appendMap = function appendMap(map14, mirrors) {
      this.to = this.maps.push(map14);
      if (mirrors != null) {
        this.setMirror(this.maps.length - 1, mirrors);
      }
    };
    Mapping.prototype.appendMapping = function appendMapping(mapping) {
      for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
      }
    };
    Mapping.prototype.getMirror = function getMirror(n) {
      if (this.mirror) {
        for (var i = 0; i < this.mirror.length; i++) {
          if (this.mirror[i] == n) {
            return this.mirror[i + (i % 2 ? -1 : 1)];
          }
        }
      }
    };
    Mapping.prototype.setMirror = function setMirror(n, m) {
      if (!this.mirror) {
        this.mirror = [];
      }
      this.mirror.push(n, m);
    };
    Mapping.prototype.appendMappingInverted = function appendMappingInverted(mapping) {
      for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
      }
    };
    Mapping.prototype.invert = function invert2() {
      var inverse = new Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    };
    Mapping.prototype.map = function map2(pos, assoc) {
      if (assoc === void 0) assoc = 1;
      if (this.mirror) {
        return this._map(pos, assoc, true);
      }
      for (var i = this.from; i < this.to; i++) {
        pos = this.maps[i].map(pos, assoc);
      }
      return pos;
    };
    Mapping.prototype.mapResult = function mapResult2(pos, assoc) {
      if (assoc === void 0) assoc = 1;
      return this._map(pos, assoc, false);
    };
    Mapping.prototype._map = function _map2(pos, assoc, simple) {
      var deleted = false;
      for (var i = this.from; i < this.to; i++) {
        var map14 = this.maps[i], result2 = map14.mapResult(pos, assoc);
        if (result2.recover != null) {
          var corr = this.getMirror(i);
          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this.maps[corr].recover(result2.recover);
            continue;
          }
        }
        if (result2.deleted) {
          deleted = true;
        }
        pos = result2.pos;
      }
      return simple ? pos : new MapResult(pos, deleted);
    };
    TransformError.prototype = Object.create(Error.prototype);
    TransformError.prototype.constructor = TransformError;
    TransformError.prototype.name = "TransformError";
    Transform = function Transform2(doc2) {
      this.doc = doc2;
      this.steps = [];
      this.docs = [];
      this.mapping = new Mapping();
    };
    prototypeAccessors2 = { before: { configurable: true }, docChanged: { configurable: true } };
    prototypeAccessors2.before.get = function() {
      return this.docs.length ? this.docs[0] : this.doc;
    };
    Transform.prototype.step = function step(object) {
      var result2 = this.maybeStep(object);
      if (result2.failed) {
        throw new TransformError(result2.failed);
      }
      return this;
    };
    Transform.prototype.maybeStep = function maybeStep(step2) {
      var result2 = step2.apply(this.doc);
      if (!result2.failed) {
        this.addStep(step2, result2.doc);
      }
      return result2;
    };
    prototypeAccessors2.docChanged.get = function() {
      return this.steps.length > 0;
    };
    Transform.prototype.addStep = function addStep(step2, doc2) {
      this.docs.push(this.doc);
      this.steps.push(step2);
      this.mapping.appendMap(step2.getMap());
      this.doc = doc2;
    };
    Object.defineProperties(Transform.prototype, prototypeAccessors2);
    stepsByID = /* @__PURE__ */ Object.create(null);
    Step = function Step2() {
    };
    Step.prototype.apply = function apply(_doc) {
      return mustOverride();
    };
    Step.prototype.getMap = function getMap() {
      return StepMap.empty;
    };
    Step.prototype.invert = function invert3(_doc) {
      return mustOverride();
    };
    Step.prototype.map = function map3(_mapping) {
      return mustOverride();
    };
    Step.prototype.merge = function merge(_other) {
      return null;
    };
    Step.prototype.toJSON = function toJSON5() {
      return mustOverride();
    };
    Step.fromJSON = function fromJSON5(schema, json) {
      if (!json || !json.stepType) {
        throw new RangeError("Invalid input for Step.fromJSON");
      }
      var type = stepsByID[json.stepType];
      if (!type) {
        throw new RangeError("No step type " + json.stepType + " defined");
      }
      return type.fromJSON(schema, json);
    };
    Step.jsonID = function jsonID(id, stepClass) {
      if (id in stepsByID) {
        throw new RangeError("Duplicate use of step JSON ID " + id);
      }
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    };
    StepResult = function StepResult2(doc2, failed) {
      this.doc = doc2;
      this.failed = failed;
    };
    StepResult.ok = function ok(doc2) {
      return new StepResult(doc2, null);
    };
    StepResult.fail = function fail(message) {
      return new StepResult(null, message);
    };
    StepResult.fromReplace = function fromReplace(doc2, from4, to, slice4) {
      try {
        return StepResult.ok(doc2.replace(from4, to, slice4));
      } catch (e) {
        if (e instanceof ReplaceError) {
          return StepResult.fail(e.message);
        }
        throw e;
      }
    };
    ReplaceStep = (function(Step3) {
      function ReplaceStep2(from4, to, slice4, structure) {
        Step3.call(this);
        this.from = from4;
        this.to = to;
        this.slice = slice4;
        this.structure = !!structure;
      }
      if (Step3) ReplaceStep2.__proto__ = Step3;
      ReplaceStep2.prototype = Object.create(Step3 && Step3.prototype);
      ReplaceStep2.prototype.constructor = ReplaceStep2;
      ReplaceStep2.prototype.apply = function apply9(doc2) {
        if (this.structure && contentBetween(doc2, this.from, this.to)) {
          return StepResult.fail("Structure replace would overwrite content");
        }
        return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
      };
      ReplaceStep2.prototype.getMap = function getMap2() {
        return new StepMap([this.from, this.to - this.from, this.slice.size]);
      };
      ReplaceStep2.prototype.invert = function invert4(doc2) {
        return new ReplaceStep2(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
      };
      ReplaceStep2.prototype.map = function map14(mapping) {
        var from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from4.deleted && to.deleted) {
          return null;
        }
        return new ReplaceStep2(from4.pos, Math.max(from4.pos, to.pos), this.slice);
      };
      ReplaceStep2.prototype.merge = function merge3(other) {
        if (!(other instanceof ReplaceStep2) || other.structure || this.structure) {
          return null;
        }
        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
          var slice4 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
          return new ReplaceStep2(this.from, this.to + (other.to - other.from), slice4, this.structure);
        } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
          var slice$1 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
          return new ReplaceStep2(other.from, this.to, slice$1, this.structure);
        } else {
          return null;
        }
      };
      ReplaceStep2.prototype.toJSON = function toJSON7() {
        var json = { stepType: "replace", from: this.from, to: this.to };
        if (this.slice.size) {
          json.slice = this.slice.toJSON();
        }
        if (this.structure) {
          json.structure = true;
        }
        return json;
      };
      ReplaceStep2.fromJSON = function fromJSON8(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number") {
          throw new RangeError("Invalid input for ReplaceStep.fromJSON");
        }
        return new ReplaceStep2(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
      };
      return ReplaceStep2;
    })(Step);
    Step.jsonID("replace", ReplaceStep);
    ReplaceAroundStep = (function(Step3) {
      function ReplaceAroundStep2(from4, to, gapFrom, gapTo, slice4, insert, structure) {
        Step3.call(this);
        this.from = from4;
        this.to = to;
        this.gapFrom = gapFrom;
        this.gapTo = gapTo;
        this.slice = slice4;
        this.insert = insert;
        this.structure = !!structure;
      }
      if (Step3) ReplaceAroundStep2.__proto__ = Step3;
      ReplaceAroundStep2.prototype = Object.create(Step3 && Step3.prototype);
      ReplaceAroundStep2.prototype.constructor = ReplaceAroundStep2;
      ReplaceAroundStep2.prototype.apply = function apply9(doc2) {
        if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to))) {
          return StepResult.fail("Structure gap-replace would overwrite content");
        }
        var gap2 = doc2.slice(this.gapFrom, this.gapTo);
        if (gap2.openStart || gap2.openEnd) {
          return StepResult.fail("Gap is not a flat range");
        }
        var inserted = this.slice.insertAt(this.insert, gap2.content);
        if (!inserted) {
          return StepResult.fail("Content does not fit in gap");
        }
        return StepResult.fromReplace(doc2, this.from, this.to, inserted);
      };
      ReplaceAroundStep2.prototype.getMap = function getMap2() {
        return new StepMap([
          this.from,
          this.gapFrom - this.from,
          this.insert,
          this.gapTo,
          this.to - this.gapTo,
          this.slice.size - this.insert
        ]);
      };
      ReplaceAroundStep2.prototype.invert = function invert4(doc2) {
        var gap2 = this.gapTo - this.gapFrom;
        return new ReplaceAroundStep2(
          this.from,
          this.from + this.slice.size + gap2,
          this.from + this.insert,
          this.from + this.insert + gap2,
          doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
          this.gapFrom - this.from,
          this.structure
        );
      };
      ReplaceAroundStep2.prototype.map = function map14(mapping) {
        var from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
        if (from4.deleted && to.deleted || gapFrom < from4.pos || gapTo > to.pos) {
          return null;
        }
        return new ReplaceAroundStep2(from4.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
      };
      ReplaceAroundStep2.prototype.toJSON = function toJSON7() {
        var json = {
          stepType: "replaceAround",
          from: this.from,
          to: this.to,
          gapFrom: this.gapFrom,
          gapTo: this.gapTo,
          insert: this.insert
        };
        if (this.slice.size) {
          json.slice = this.slice.toJSON();
        }
        if (this.structure) {
          json.structure = true;
        }
        return json;
      };
      ReplaceAroundStep2.fromJSON = function fromJSON8(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") {
          throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
        }
        return new ReplaceAroundStep2(
          json.from,
          json.to,
          json.gapFrom,
          json.gapTo,
          Slice.fromJSON(schema, json.slice),
          json.insert,
          !!json.structure
        );
      };
      return ReplaceAroundStep2;
    })(Step);
    Step.jsonID("replaceAround", ReplaceAroundStep);
    Transform.prototype.lift = function(range2, target2) {
      var $from = range2.$from;
      var $to = range2.$to;
      var depth = range2.depth;
      var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
      var start3 = gapStart, end2 = gapEnd;
      var before2 = Fragment.empty, openStart = 0;
      for (var d = depth, splitting = false; d > target2; d--) {
        if (splitting || $from.index(d) > 0) {
          splitting = true;
          before2 = Fragment.from($from.node(d).copy(before2));
          openStart++;
        } else {
          start3--;
        }
      }
      var after2 = Fragment.empty, openEnd = 0;
      for (var d$1 = depth, splitting$1 = false; d$1 > target2; d$1--) {
        if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
          splitting$1 = true;
          after2 = Fragment.from($to.node(d$1).copy(after2));
          openEnd++;
        } else {
          end2++;
        }
      }
      return this.step(new ReplaceAroundStep(
        start3,
        end2,
        gapStart,
        gapEnd,
        new Slice(before2.append(after2), openStart, openEnd),
        before2.size - openStart,
        true
      ));
    };
    Transform.prototype.wrap = function(range2, wrappers) {
      var content2 = Fragment.empty;
      for (var i = wrappers.length - 1; i >= 0; i--) {
        if (content2.size) {
          var match = wrappers[i].type.contentMatch.matchFragment(content2);
          if (!match || !match.validEnd) {
            throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
          }
        }
        content2 = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content2));
      }
      var start3 = range2.start, end2 = range2.end;
      return this.step(new ReplaceAroundStep(start3, end2, start3, end2, new Slice(content2, 0, 0), wrappers.length, true));
    };
    Transform.prototype.setBlockType = function(from4, to, type, attrs) {
      var this$1 = this;
      if (to === void 0) to = from4;
      if (!type.isTextblock) {
        throw new RangeError("Type given to setBlockType should be a textblock");
      }
      var mapFrom = this.steps.length;
      this.doc.nodesBetween(from4, to, function(node4, pos) {
        if (node4.isTextblock && !node4.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {
          this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);
          var mapping = this$1.mapping.slice(mapFrom);
          var startM = mapping.map(pos, 1), endM = mapping.map(pos + node4.nodeSize, 1);
          this$1.step(new ReplaceAroundStep(
            startM,
            endM,
            startM + 1,
            endM - 1,
            new Slice(Fragment.from(type.create(attrs, null, node4.marks)), 0, 0),
            1,
            true
          ));
          return false;
        }
      });
      return this;
    };
    Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks2) {
      var node4 = this.doc.nodeAt(pos);
      if (!node4) {
        throw new RangeError("No node at given position");
      }
      if (!type) {
        type = node4.type;
      }
      var newNode = type.create(attrs, null, marks2 || node4.marks);
      if (node4.isLeaf) {
        return this.replaceWith(pos, pos + node4.nodeSize, newNode);
      }
      if (!type.validContent(node4.content)) {
        throw new RangeError("Invalid content for node type " + type.name);
      }
      return this.step(new ReplaceAroundStep(
        pos,
        pos + node4.nodeSize,
        pos + 1,
        pos + node4.nodeSize - 1,
        new Slice(Fragment.from(newNode), 0, 0),
        1,
        true
      ));
    };
    Transform.prototype.split = function(pos, depth, typesAfter) {
      if (depth === void 0) depth = 1;
      var $pos = this.doc.resolve(pos), before2 = Fragment.empty, after2 = Fragment.empty;
      for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
        before2 = Fragment.from($pos.node(d).copy(before2));
        var typeAfter = typesAfter && typesAfter[i];
        after2 = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after2) : $pos.node(d).copy(after2));
      }
      return this.step(new ReplaceStep(pos, pos, new Slice(before2.append(after2), depth, depth), true));
    };
    Transform.prototype.join = function(pos, depth) {
      if (depth === void 0) depth = 1;
      var step2 = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);
      return this.step(step2);
    };
    AddMarkStep = (function(Step3) {
      function AddMarkStep2(from4, to, mark3) {
        Step3.call(this);
        this.from = from4;
        this.to = to;
        this.mark = mark3;
      }
      if (Step3) AddMarkStep2.__proto__ = Step3;
      AddMarkStep2.prototype = Object.create(Step3 && Step3.prototype);
      AddMarkStep2.prototype.constructor = AddMarkStep2;
      AddMarkStep2.prototype.apply = function apply9(doc2) {
        var this$1 = this;
        var oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
        var parent = $from.node($from.sharedDepth(this.to));
        var slice4 = new Slice(mapFragment(oldSlice.content, function(node4, parent2) {
          if (!node4.isAtom || !parent2.type.allowsMarkType(this$1.mark.type)) {
            return node4;
          }
          return node4.mark(this$1.mark.addToSet(node4.marks));
        }, parent), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc2, this.from, this.to, slice4);
      };
      AddMarkStep2.prototype.invert = function invert4() {
        return new RemoveMarkStep(this.from, this.to, this.mark);
      };
      AddMarkStep2.prototype.map = function map14(mapping) {
        var from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from4.deleted && to.deleted || from4.pos >= to.pos) {
          return null;
        }
        return new AddMarkStep2(from4.pos, to.pos, this.mark);
      };
      AddMarkStep2.prototype.merge = function merge3(other) {
        if (other instanceof AddMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
          return new AddMarkStep2(
            Math.min(this.from, other.from),
            Math.max(this.to, other.to),
            this.mark
          );
        }
      };
      AddMarkStep2.prototype.toJSON = function toJSON7() {
        return {
          stepType: "addMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      };
      AddMarkStep2.fromJSON = function fromJSON8(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number") {
          throw new RangeError("Invalid input for AddMarkStep.fromJSON");
        }
        return new AddMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
      };
      return AddMarkStep2;
    })(Step);
    Step.jsonID("addMark", AddMarkStep);
    RemoveMarkStep = (function(Step3) {
      function RemoveMarkStep2(from4, to, mark3) {
        Step3.call(this);
        this.from = from4;
        this.to = to;
        this.mark = mark3;
      }
      if (Step3) RemoveMarkStep2.__proto__ = Step3;
      RemoveMarkStep2.prototype = Object.create(Step3 && Step3.prototype);
      RemoveMarkStep2.prototype.constructor = RemoveMarkStep2;
      RemoveMarkStep2.prototype.apply = function apply9(doc2) {
        var this$1 = this;
        var oldSlice = doc2.slice(this.from, this.to);
        var slice4 = new Slice(mapFragment(oldSlice.content, function(node4) {
          return node4.mark(this$1.mark.removeFromSet(node4.marks));
        }), oldSlice.openStart, oldSlice.openEnd);
        return StepResult.fromReplace(doc2, this.from, this.to, slice4);
      };
      RemoveMarkStep2.prototype.invert = function invert4() {
        return new AddMarkStep(this.from, this.to, this.mark);
      };
      RemoveMarkStep2.prototype.map = function map14(mapping) {
        var from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
        if (from4.deleted && to.deleted || from4.pos >= to.pos) {
          return null;
        }
        return new RemoveMarkStep2(from4.pos, to.pos, this.mark);
      };
      RemoveMarkStep2.prototype.merge = function merge3(other) {
        if (other instanceof RemoveMarkStep2 && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) {
          return new RemoveMarkStep2(
            Math.min(this.from, other.from),
            Math.max(this.to, other.to),
            this.mark
          );
        }
      };
      RemoveMarkStep2.prototype.toJSON = function toJSON7() {
        return {
          stepType: "removeMark",
          mark: this.mark.toJSON(),
          from: this.from,
          to: this.to
        };
      };
      RemoveMarkStep2.fromJSON = function fromJSON8(schema, json) {
        if (typeof json.from != "number" || typeof json.to != "number") {
          throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
        }
        return new RemoveMarkStep2(json.from, json.to, schema.markFromJSON(json.mark));
      };
      return RemoveMarkStep2;
    })(Step);
    Step.jsonID("removeMark", RemoveMarkStep);
    Transform.prototype.addMark = function(from4, to, mark3) {
      var this$1 = this;
      var removed = [], added = [], removing = null, adding = null;
      this.doc.nodesBetween(from4, to, function(node4, pos, parent) {
        if (!node4.isInline) {
          return;
        }
        var marks2 = node4.marks;
        if (!mark3.isInSet(marks2) && parent.type.allowsMarkType(mark3.type)) {
          var start3 = Math.max(pos, from4), end2 = Math.min(pos + node4.nodeSize, to);
          var newSet = mark3.addToSet(marks2);
          for (var i = 0; i < marks2.length; i++) {
            if (!marks2[i].isInSet(newSet)) {
              if (removing && removing.to == start3 && removing.mark.eq(marks2[i])) {
                removing.to = end2;
              } else {
                removed.push(removing = new RemoveMarkStep(start3, end2, marks2[i]));
              }
            }
          }
          if (adding && adding.to == start3) {
            adding.to = end2;
          } else {
            added.push(adding = new AddMarkStep(start3, end2, mark3));
          }
        }
      });
      removed.forEach(function(s) {
        return this$1.step(s);
      });
      added.forEach(function(s) {
        return this$1.step(s);
      });
      return this;
    };
    Transform.prototype.removeMark = function(from4, to, mark3) {
      var this$1 = this;
      if (mark3 === void 0) mark3 = null;
      var matched = [], step2 = 0;
      this.doc.nodesBetween(from4, to, function(node4, pos) {
        if (!node4.isInline) {
          return;
        }
        step2++;
        var toRemove = null;
        if (mark3 instanceof MarkType) {
          var set2 = node4.marks, found2;
          while (found2 = mark3.isInSet(set2)) {
            (toRemove || (toRemove = [])).push(found2);
            set2 = found2.removeFromSet(set2);
          }
        } else if (mark3) {
          if (mark3.isInSet(node4.marks)) {
            toRemove = [mark3];
          }
        } else {
          toRemove = node4.marks;
        }
        if (toRemove && toRemove.length) {
          var end2 = Math.min(pos + node4.nodeSize, to);
          for (var i = 0; i < toRemove.length; i++) {
            var style = toRemove[i], found$1 = void 0;
            for (var j = 0; j < matched.length; j++) {
              var m = matched[j];
              if (m.step == step2 - 1 && style.eq(matched[j].style)) {
                found$1 = m;
              }
            }
            if (found$1) {
              found$1.to = end2;
              found$1.step = step2;
            } else {
              matched.push({ style, from: Math.max(pos, from4), to: end2, step: step2 });
            }
          }
        }
      });
      matched.forEach(function(m) {
        return this$1.step(new RemoveMarkStep(m.from, m.to, m.style));
      });
      return this;
    };
    Transform.prototype.clearIncompatible = function(pos, parentType, match) {
      if (match === void 0) match = parentType.contentMatch;
      var node4 = this.doc.nodeAt(pos);
      var delSteps = [], cur = pos + 1;
      for (var i = 0; i < node4.childCount; i++) {
        var child3 = node4.child(i), end2 = cur + child3.nodeSize;
        var allowed = match.matchType(child3.type, child3.attrs);
        if (!allowed) {
          delSteps.push(new ReplaceStep(cur, end2, Slice.empty));
        } else {
          match = allowed;
          for (var j = 0; j < child3.marks.length; j++) {
            if (!parentType.allowsMarkType(child3.marks[j].type)) {
              this.step(new RemoveMarkStep(cur, end2, child3.marks[j]));
            }
          }
        }
        cur = end2;
      }
      if (!match.validEnd) {
        var fill = match.fillBefore(Fragment.empty, true);
        this.replace(cur, cur, new Slice(fill, 0, 0));
      }
      for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) {
        this.step(delSteps[i$1]);
      }
      return this;
    };
    Transform.prototype.replace = function(from4, to, slice4) {
      if (to === void 0) to = from4;
      if (slice4 === void 0) slice4 = Slice.empty;
      var step2 = replaceStep(this.doc, from4, to, slice4);
      if (step2) {
        this.step(step2);
      }
      return this;
    };
    Transform.prototype.replaceWith = function(from4, to, content2) {
      return this.replace(from4, to, new Slice(Fragment.from(content2), 0, 0));
    };
    Transform.prototype.delete = function(from4, to) {
      return this.replace(from4, to, Slice.empty);
    };
    Transform.prototype.insert = function(pos, content2) {
      return this.replaceWith(pos, pos, content2);
    };
    Fitter = function Fitter2($from, $to, slice4) {
      this.$to = $to;
      this.$from = $from;
      this.unplaced = slice4;
      this.frontier = [];
      for (var i = 0; i <= $from.depth; i++) {
        var node4 = $from.node(i);
        this.frontier.push({
          type: node4.type,
          match: node4.contentMatchAt($from.indexAfter(i))
        });
      }
      this.placed = Fragment.empty;
      for (var i$1 = $from.depth; i$1 > 0; i$1--) {
        this.placed = Fragment.from($from.node(i$1).copy(this.placed));
      }
    };
    prototypeAccessors$12 = { depth: { configurable: true } };
    prototypeAccessors$12.depth.get = function() {
      return this.frontier.length - 1;
    };
    Fitter.prototype.fit = function fit() {
      while (this.unplaced.size) {
        var fit2 = this.findFittable();
        if (fit2) {
          this.placeNodes(fit2);
        } else {
          this.openMore() || this.dropNode();
        }
      }
      var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
      var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to) {
        return null;
      }
      var content2 = this.placed, openStart = $from.depth, openEnd = $to.depth;
      while (openStart && openEnd && content2.childCount == 1) {
        content2 = content2.firstChild.content;
        openStart--;
        openEnd--;
      }
      var slice4 = new Slice(content2, openStart, openEnd);
      if (moveInline > -1) {
        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice4, placedSize);
      }
      if (slice4.size || $from.pos != this.$to.pos) {
        return new ReplaceStep($from.pos, $to.pos, slice4);
      }
    };
    Fitter.prototype.findFittable = function findFittable() {
      for (var pass = 1; pass <= 2; pass++) {
        for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          var fragment = void 0, parent = void 0;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          var first = fragment.firstChild;
          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            var ref = this.frontier[frontierDepth];
            var type = ref.type;
            var match = ref.match;
            var wrap = void 0, inject = void 0;
            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : type.compatibleContent(parent.type))) {
              return { sliceDepth, frontierDepth, parent, inject };
            } else if (pass == 2 && first && (wrap = match.findWrapping(first.type))) {
              return { sliceDepth, frontierDepth, parent, wrap };
            }
            if (parent && match.matchType(parent.type)) {
              break;
            }
          }
        }
      }
    };
    Fitter.prototype.openMore = function openMore() {
      var ref = this.unplaced;
      var content2 = ref.content;
      var openStart = ref.openStart;
      var openEnd = ref.openEnd;
      var inner = contentAt(content2, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf) {
        return false;
      }
      this.unplaced = new Slice(
        content2,
        openStart + 1,
        Math.max(openEnd, inner.size + openStart >= content2.size - openEnd ? openStart + 1 : 0)
      );
      return true;
    };
    Fitter.prototype.dropNode = function dropNode() {
      var ref = this.unplaced;
      var content2 = ref.content;
      var openStart = ref.openStart;
      var openEnd = ref.openEnd;
      var inner = contentAt(content2, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        var openAtEnd = content2.size - openStart <= openStart + inner.size;
        this.unplaced = new Slice(
          dropFromFragment(content2, openStart - 1, 1),
          openStart - 1,
          openAtEnd ? openStart - 1 : openEnd
        );
      } else {
        this.unplaced = new Slice(dropFromFragment(content2, openStart, 1), openStart, openEnd);
      }
    };
    Fitter.prototype.placeNodes = function placeNodes(ref) {
      var sliceDepth = ref.sliceDepth;
      var frontierDepth = ref.frontierDepth;
      var parent = ref.parent;
      var inject = ref.inject;
      var wrap = ref.wrap;
      while (this.depth > frontierDepth) {
        this.closeFrontierNode();
      }
      if (wrap) {
        for (var i = 0; i < wrap.length; i++) {
          this.openFrontierNode(wrap[i]);
        }
      }
      var slice4 = this.unplaced, fragment = parent ? parent.content : slice4.content;
      var openStart = slice4.openStart - sliceDepth;
      var taken = 0, add2 = [];
      var ref$1 = this.frontier[frontierDepth];
      var match = ref$1.match;
      var type = ref$1.type;
      if (inject) {
        for (var i$1 = 0; i$1 < inject.childCount; i$1++) {
          add2.push(inject.child(i$1));
        }
        match = match.matchFragment(inject);
      }
      var openEndCount = fragment.size + sliceDepth - (slice4.content.size - slice4.openEnd);
      while (taken < fragment.childCount) {
        var next = fragment.child(taken), matches4 = match.matchType(next.type);
        if (!matches4) {
          break;
        }
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches4;
          add2.push(closeNodeStart(
            next.mark(type.allowedMarks(next.marks)),
            taken == 1 ? openStart : 0,
            taken == fragment.childCount ? openEndCount : -1
          ));
        }
      }
      var toEnd = taken == fragment.childCount;
      if (!toEnd) {
        openEndCount = -1;
      }
      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) {
        this.closeFrontierNode();
      }
      for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
        var node4 = cur.lastChild;
        this.frontier.push({ type: node4.type, match: node4.contentMatchAt(node4.childCount) });
        cur = node4.content;
      }
      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice4.content, sliceDepth, taken), slice4.openStart, slice4.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(
        dropFromFragment(slice4.content, sliceDepth - 1, 1),
        sliceDepth - 1,
        openEndCount < 0 ? slice4.openEnd : sliceDepth - 1
      );
    };
    Fitter.prototype.mustMoveInline = function mustMoveInline() {
      if (!this.$to.parent.isTextblock || this.$to.end() == this.$to.pos) {
        return -1;
      }
      var top2 = this.frontier[this.depth], level;
      if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) {
        return -1;
      }
      var ref = this.$to;
      var depth = ref.depth;
      var after2 = this.$to.after(depth);
      while (depth > 1 && after2 == this.$to.end(--depth)) {
        ++after2;
      }
      return after2;
    };
    Fitter.prototype.findCloseLevel = function findCloseLevel($to) {
      scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        var ref = this.frontier[i];
        var match = ref.match;
        var type = ref.type;
        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        var fit2 = contentAfterFits($to, i, type, match, dropInner);
        if (!fit2) {
          continue;
        }
        for (var d = i - 1; d >= 0; d--) {
          var ref$1 = this.frontier[d];
          var match$1 = ref$1.match;
          var type$1 = ref$1.type;
          var matches4 = contentAfterFits($to, d, type$1, match$1, true);
          if (!matches4 || matches4.childCount) {
            continue scan;
          }
        }
        return { depth: i, fit: fit2, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
      }
    };
    Fitter.prototype.close = function close2($to) {
      var close3 = this.findCloseLevel($to);
      if (!close3) {
        return null;
      }
      while (this.depth > close3.depth) {
        this.closeFrontierNode();
      }
      if (close3.fit.childCount) {
        this.placed = addToFragment(this.placed, close3.depth, close3.fit);
      }
      $to = close3.move;
      for (var d = close3.depth + 1; d <= $to.depth; d++) {
        var node4 = $to.node(d), add2 = node4.type.contentMatch.fillBefore(node4.content, true, $to.index(d));
        this.openFrontierNode(node4.type, node4.attrs, add2);
      }
      return $to;
    };
    Fitter.prototype.openFrontierNode = function openFrontierNode(type, attrs, content2) {
      var top2 = this.frontier[this.depth];
      top2.match = top2.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content2)));
      this.frontier.push({ type, match: type.contentMatch });
    };
    Fitter.prototype.closeFrontierNode = function closeFrontierNode() {
      var open = this.frontier.pop();
      var add2 = open.match.fillBefore(Fragment.empty, true);
      if (add2.childCount) {
        this.placed = addToFragment(this.placed, this.frontier.length, add2);
      }
    };
    Object.defineProperties(Fitter.prototype, prototypeAccessors$12);
    Transform.prototype.replaceRange = function(from4, to, slice4) {
      if (!slice4.size) {
        return this.deleteRange(from4, to);
      }
      var $from = this.doc.resolve(from4), $to = this.doc.resolve(to);
      if (fitsTrivially($from, $to, slice4)) {
        return this.step(new ReplaceStep(from4, to, slice4));
      }
      var targetDepths = coveredDepths($from, this.doc.resolve(to));
      if (targetDepths[targetDepths.length - 1] == 0) {
        targetDepths.pop();
      }
      var preferredTarget = -($from.depth + 1);
      targetDepths.unshift(preferredTarget);
      for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
        var spec = $from.node(d).type.spec;
        if (spec.defining || spec.isolating) {
          break;
        }
        if (targetDepths.indexOf(d) > -1) {
          preferredTarget = d;
        } else if ($from.before(d) == pos) {
          targetDepths.splice(1, 0, -d);
        }
      }
      var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
      var leftNodes = [], preferredDepth = slice4.openStart;
      for (var content2 = slice4.content, i = 0; ; i++) {
        var node4 = content2.firstChild;
        leftNodes.push(node4);
        if (i == slice4.openStart) {
          break;
        }
        content2 = node4.content;
      }
      if (preferredDepth > 0 && leftNodes[preferredDepth - 1].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 1].type) {
        preferredDepth -= 1;
      } else if (preferredDepth >= 2 && leftNodes[preferredDepth - 1].isTextblock && leftNodes[preferredDepth - 2].type.spec.defining && $from.node(preferredTargetIndex).type != leftNodes[preferredDepth - 2].type) {
        preferredDepth -= 2;
      }
      for (var j = slice4.openStart; j >= 0; j--) {
        var openDepth = (j + preferredDepth + 1) % (slice4.openStart + 1);
        var insert = leftNodes[openDepth];
        if (!insert) {
          continue;
        }
        for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
          var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
          if (targetDepth < 0) {
            expand = false;
            targetDepth = -targetDepth;
          }
          var parent = $from.node(targetDepth - 1), index3 = $from.index(targetDepth - 1);
          if (parent.canReplaceWith(index3, index3, insert.type, insert.marks)) {
            return this.replace(
              $from.before(targetDepth),
              expand ? $to.after(targetDepth) : to,
              new Slice(
                closeFragment(slice4.content, 0, slice4.openStart, openDepth),
                openDepth,
                slice4.openEnd
              )
            );
          }
        }
      }
      var startSteps = this.steps.length;
      for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
        this.replace(from4, to, slice4);
        if (this.steps.length > startSteps) {
          break;
        }
        var depth = targetDepths[i$2];
        if (depth < 0) {
          continue;
        }
        from4 = $from.before(depth);
        to = $to.after(depth);
      }
      return this;
    };
    Transform.prototype.replaceRangeWith = function(from4, to, node4) {
      if (!node4.isInline && from4 == to && this.doc.resolve(from4).parent.content.size) {
        var point = insertPoint(this.doc, from4, node4.type);
        if (point != null) {
          from4 = to = point;
        }
      }
      return this.replaceRange(from4, to, new Slice(Fragment.from(node4), 0, 0));
    };
    Transform.prototype.deleteRange = function(from4, to) {
      var $from = this.doc.resolve(from4), $to = this.doc.resolve(to);
      var covered = coveredDepths($from, $to);
      for (var i = 0; i < covered.length; i++) {
        var depth = covered[i], last2 = i == covered.length - 1;
        if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd) {
          return this.delete($from.start(depth), $to.end(depth));
        }
        if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) {
          return this.delete($from.before(depth), $to.after(depth));
        }
      }
      for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
        if (from4 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) {
          return this.delete($from.before(d), to);
        }
      }
      return this.delete(from4, to);
    };
  }
});

// ../../node_modules/.pnpm/prosemirror-state@1.3.4/node_modules/prosemirror-state/dist/index.es.js
var index_es_exports2 = {};
__export(index_es_exports2, {
  AllSelection: () => AllSelection,
  EditorState: () => EditorState,
  NodeSelection: () => NodeSelection,
  Plugin: () => Plugin,
  PluginKey: () => PluginKey,
  Selection: () => Selection,
  SelectionRange: () => SelectionRange,
  TextSelection: () => TextSelection,
  Transaction: () => Transaction
});
function findSelectionIn(doc2, node4, pos, index3, dir, text3) {
  if (node4.inlineContent) {
    return TextSelection.create(doc2, pos);
  }
  for (var i = index3 - (dir > 0 ? 0 : 1); dir > 0 ? i < node4.childCount : i >= 0; i += dir) {
    var child3 = node4.child(i);
    if (!child3.isAtom) {
      var inner = findSelectionIn(doc2, child3, pos + dir, dir < 0 ? child3.childCount : 0, dir, text3);
      if (inner) {
        return inner;
      }
    } else if (!text3 && NodeSelection.isSelectable(child3)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child3.nodeSize : 0));
    }
    pos += child3.nodeSize * dir;
  }
}
function selectionToInsertionEnd(tr, startLen, bias) {
  var last2 = tr.steps.length - 1;
  if (last2 < startLen) {
    return;
  }
  var step2 = tr.steps[last2];
  if (!(step2 instanceof ReplaceStep || step2 instanceof ReplaceAroundStep)) {
    return;
  }
  var map14 = tr.mapping.maps[last2], end2;
  map14.forEach(function(_from, _to, _newFrom, newTo) {
    if (end2 == null) {
      end2 = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
}
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
function bindProps(obj, self2, target2) {
  for (var prop2 in obj) {
    var val = obj[prop2];
    if (val instanceof Function) {
      val = val.bind(self2);
    } else if (prop2 == "handleDOMEvents") {
      val = bindProps(val, self2, {});
    }
    target2[prop2] = val;
  }
  return target2;
}
function createKey(name) {
  if (name in keys) {
    return name + "$" + ++keys[name];
  }
  keys[name] = 0;
  return name + "$";
}
var classesById, Selection, prototypeAccessors3, SelectionRange, TextSelection, TextBookmark, NodeSelection, NodeBookmark, AllSelection, AllBookmark, UPDATED_SEL, UPDATED_MARKS, UPDATED_SCROLL, Transaction, FieldDesc, baseFields, Configuration, EditorState, prototypeAccessors$13, applyListeners, Plugin, keys, PluginKey;
var init_index_es4 = __esm({
  "../../node_modules/.pnpm/prosemirror-state@1.3.4/node_modules/prosemirror-state/dist/index.es.js"() {
    init_index_es2();
    init_index_es3();
    classesById = /* @__PURE__ */ Object.create(null);
    Selection = function Selection2($anchor, $head, ranges) {
      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
      this.$anchor = $anchor;
      this.$head = $head;
    };
    prototypeAccessors3 = { anchor: { configurable: true }, head: { configurable: true }, from: { configurable: true }, to: { configurable: true }, $from: { configurable: true }, $to: { configurable: true }, empty: { configurable: true } };
    prototypeAccessors3.anchor.get = function() {
      return this.$anchor.pos;
    };
    prototypeAccessors3.head.get = function() {
      return this.$head.pos;
    };
    prototypeAccessors3.from.get = function() {
      return this.$from.pos;
    };
    prototypeAccessors3.to.get = function() {
      return this.$to.pos;
    };
    prototypeAccessors3.$from.get = function() {
      return this.ranges[0].$from;
    };
    prototypeAccessors3.$to.get = function() {
      return this.ranges[0].$to;
    };
    prototypeAccessors3.empty.get = function() {
      var ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++) {
        if (ranges[i].$from.pos != ranges[i].$to.pos) {
          return false;
        }
      }
      return true;
    };
    Selection.prototype.content = function content() {
      return this.$from.node(0).slice(this.from, this.to, true);
    };
    Selection.prototype.replace = function replace2(tr, content2) {
      if (content2 === void 0) content2 = Slice.empty;
      var lastNode = content2.content.lastChild, lastParent = null;
      for (var i = 0; i < content2.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      var mapFrom = tr.steps.length, ranges = this.ranges;
      for (var i$1 = 0; i$1 < ranges.length; i$1++) {
        var ref = ranges[i$1];
        var $from = ref.$from;
        var $to = ref.$to;
        var mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? Slice.empty : content2);
        if (i$1 == 0) {
          selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
        }
      }
    };
    Selection.prototype.replaceWith = function replaceWith(tr, node4) {
      var mapFrom = tr.steps.length, ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var ref = ranges[i];
        var $from = ref.$from;
        var $to = ref.$to;
        var mapping = tr.mapping.slice(mapFrom);
        var from4 = mapping.map($from.pos), to = mapping.map($to.pos);
        if (i) {
          tr.deleteRange(from4, to);
        } else {
          tr.replaceRangeWith(from4, to, node4);
          selectionToInsertionEnd(tr, mapFrom, node4.isInline ? -1 : 1);
        }
      }
    };
    Selection.findFrom = function findFrom($pos, dir, textOnly) {
      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner) {
        return inner;
      }
      for (var depth = $pos.depth - 1; depth >= 0; depth--) {
        var found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found2) {
          return found2;
        }
      }
    };
    Selection.near = function near($pos, bias) {
      if (bias === void 0) bias = 1;
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    };
    Selection.atStart = function atStart(doc2) {
      return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
    };
    Selection.atEnd = function atEnd(doc2) {
      return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
    };
    Selection.fromJSON = function fromJSON6(doc2, json) {
      if (!json || !json.type) {
        throw new RangeError("Invalid input for Selection.fromJSON");
      }
      var cls2 = classesById[json.type];
      if (!cls2) {
        throw new RangeError("No selection type " + json.type + " defined");
      }
      return cls2.fromJSON(doc2, json);
    };
    Selection.jsonID = function jsonID2(id, selectionClass) {
      if (id in classesById) {
        throw new RangeError("Duplicate use of selection JSON ID " + id);
      }
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    };
    Selection.prototype.getBookmark = function getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    };
    Object.defineProperties(Selection.prototype, prototypeAccessors3);
    Selection.prototype.visible = true;
    SelectionRange = function SelectionRange2($from, $to) {
      this.$from = $from;
      this.$to = $to;
    };
    TextSelection = (function(Selection3) {
      function TextSelection2($anchor, $head) {
        if ($head === void 0) $head = $anchor;
        Selection3.call(this, $anchor, $head);
      }
      if (Selection3) TextSelection2.__proto__ = Selection3;
      TextSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
      TextSelection2.prototype.constructor = TextSelection2;
      var prototypeAccessors$15 = { $cursor: { configurable: true } };
      prototypeAccessors$15.$cursor.get = function() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      };
      TextSelection2.prototype.map = function map14(doc2, mapping) {
        var $head = doc2.resolve(mapping.map(this.head));
        if (!$head.parent.inlineContent) {
          return Selection3.near($head);
        }
        var $anchor = doc2.resolve(mapping.map(this.anchor));
        return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
      };
      TextSelection2.prototype.replace = function replace3(tr, content2) {
        if (content2 === void 0) content2 = Slice.empty;
        Selection3.prototype.replace.call(this, tr, content2);
        if (content2 == Slice.empty) {
          var marks2 = this.$from.marksAcross(this.$to);
          if (marks2) {
            tr.ensureMarks(marks2);
          }
        }
      };
      TextSelection2.prototype.eq = function eq12(other) {
        return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
      };
      TextSelection2.prototype.getBookmark = function getBookmark2() {
        return new TextBookmark(this.anchor, this.head);
      };
      TextSelection2.prototype.toJSON = function toJSON7() {
        return { type: "text", anchor: this.anchor, head: this.head };
      };
      TextSelection2.fromJSON = function fromJSON8(doc2, json) {
        if (typeof json.anchor != "number" || typeof json.head != "number") {
          throw new RangeError("Invalid input for TextSelection.fromJSON");
        }
        return new TextSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
      };
      TextSelection2.create = function create6(doc2, anchor, head) {
        if (head === void 0) head = anchor;
        var $anchor = doc2.resolve(anchor);
        return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
      };
      TextSelection2.between = function between2($anchor, $head, bias) {
        var dPos = $anchor.pos - $head.pos;
        if (!bias || dPos) {
          bias = dPos >= 0 ? 1 : -1;
        }
        if (!$head.parent.inlineContent) {
          var found2 = Selection3.findFrom($head, bias, true) || Selection3.findFrom($head, -bias, true);
          if (found2) {
            $head = found2.$head;
          } else {
            return Selection3.near($head, bias);
          }
        }
        if (!$anchor.parent.inlineContent) {
          if (dPos == 0) {
            $anchor = $head;
          } else {
            $anchor = (Selection3.findFrom($anchor, -bias, true) || Selection3.findFrom($anchor, bias, true)).$anchor;
            if ($anchor.pos < $head.pos != dPos < 0) {
              $anchor = $head;
            }
          }
        }
        return new TextSelection2($anchor, $head);
      };
      Object.defineProperties(TextSelection2.prototype, prototypeAccessors$15);
      return TextSelection2;
    })(Selection);
    Selection.jsonID("text", TextSelection);
    TextBookmark = function TextBookmark2(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    };
    TextBookmark.prototype.map = function map4(mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    };
    TextBookmark.prototype.resolve = function resolve3(doc2) {
      return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
    };
    NodeSelection = (function(Selection3) {
      function NodeSelection2($pos) {
        var node4 = $pos.nodeAfter;
        var $end = $pos.node(0).resolve($pos.pos + node4.nodeSize);
        Selection3.call(this, $pos, $end);
        this.node = node4;
      }
      if (Selection3) NodeSelection2.__proto__ = Selection3;
      NodeSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
      NodeSelection2.prototype.constructor = NodeSelection2;
      NodeSelection2.prototype.map = function map14(doc2, mapping) {
        var ref = mapping.mapResult(this.anchor);
        var deleted = ref.deleted;
        var pos = ref.pos;
        var $pos = doc2.resolve(pos);
        if (deleted) {
          return Selection3.near($pos);
        }
        return new NodeSelection2($pos);
      };
      NodeSelection2.prototype.content = function content2() {
        return new Slice(Fragment.from(this.node), 0, 0);
      };
      NodeSelection2.prototype.eq = function eq12(other) {
        return other instanceof NodeSelection2 && other.anchor == this.anchor;
      };
      NodeSelection2.prototype.toJSON = function toJSON7() {
        return { type: "node", anchor: this.anchor };
      };
      NodeSelection2.prototype.getBookmark = function getBookmark2() {
        return new NodeBookmark(this.anchor);
      };
      NodeSelection2.fromJSON = function fromJSON8(doc2, json) {
        if (typeof json.anchor != "number") {
          throw new RangeError("Invalid input for NodeSelection.fromJSON");
        }
        return new NodeSelection2(doc2.resolve(json.anchor));
      };
      NodeSelection2.create = function create6(doc2, from4) {
        return new this(doc2.resolve(from4));
      };
      NodeSelection2.isSelectable = function isSelectable(node4) {
        return !node4.isText && node4.type.spec.selectable !== false;
      };
      return NodeSelection2;
    })(Selection);
    NodeSelection.prototype.visible = false;
    Selection.jsonID("node", NodeSelection);
    NodeBookmark = function NodeBookmark2(anchor) {
      this.anchor = anchor;
    };
    NodeBookmark.prototype.map = function map5(mapping) {
      var ref = mapping.mapResult(this.anchor);
      var deleted = ref.deleted;
      var pos = ref.pos;
      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    };
    NodeBookmark.prototype.resolve = function resolve4(doc2) {
      var $pos = doc2.resolve(this.anchor), node4 = $pos.nodeAfter;
      if (node4 && NodeSelection.isSelectable(node4)) {
        return new NodeSelection($pos);
      }
      return Selection.near($pos);
    };
    AllSelection = (function(Selection3) {
      function AllSelection2(doc2) {
        Selection3.call(this, doc2.resolve(0), doc2.resolve(doc2.content.size));
      }
      if (Selection3) AllSelection2.__proto__ = Selection3;
      AllSelection2.prototype = Object.create(Selection3 && Selection3.prototype);
      AllSelection2.prototype.constructor = AllSelection2;
      AllSelection2.prototype.replace = function replace3(tr, content2) {
        if (content2 === void 0) content2 = Slice.empty;
        if (content2 == Slice.empty) {
          tr.delete(0, tr.doc.content.size);
          var sel = Selection3.atStart(tr.doc);
          if (!sel.eq(tr.selection)) {
            tr.setSelection(sel);
          }
        } else {
          Selection3.prototype.replace.call(this, tr, content2);
        }
      };
      AllSelection2.prototype.toJSON = function toJSON7() {
        return { type: "all" };
      };
      AllSelection2.fromJSON = function fromJSON8(doc2) {
        return new AllSelection2(doc2);
      };
      AllSelection2.prototype.map = function map14(doc2) {
        return new AllSelection2(doc2);
      };
      AllSelection2.prototype.eq = function eq12(other) {
        return other instanceof AllSelection2;
      };
      AllSelection2.prototype.getBookmark = function getBookmark2() {
        return AllBookmark;
      };
      return AllSelection2;
    })(Selection);
    Selection.jsonID("all", AllSelection);
    AllBookmark = {
      map: function map6() {
        return this;
      },
      resolve: function resolve5(doc2) {
        return new AllSelection(doc2);
      }
    };
    UPDATED_SEL = 1;
    UPDATED_MARKS = 2;
    UPDATED_SCROLL = 4;
    Transaction = (function(Transform3) {
      function Transaction2(state) {
        Transform3.call(this, state.doc);
        this.time = Date.now();
        this.curSelection = state.selection;
        this.curSelectionFor = 0;
        this.storedMarks = state.storedMarks;
        this.updated = 0;
        this.meta = /* @__PURE__ */ Object.create(null);
      }
      if (Transform3) Transaction2.__proto__ = Transform3;
      Transaction2.prototype = Object.create(Transform3 && Transform3.prototype);
      Transaction2.prototype.constructor = Transaction2;
      var prototypeAccessors5 = { selection: { configurable: true }, selectionSet: { configurable: true }, storedMarksSet: { configurable: true }, isGeneric: { configurable: true }, scrolledIntoView: { configurable: true } };
      prototypeAccessors5.selection.get = function() {
        if (this.curSelectionFor < this.steps.length) {
          this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
          this.curSelectionFor = this.steps.length;
        }
        return this.curSelection;
      };
      Transaction2.prototype.setSelection = function setSelection3(selection) {
        if (selection.$from.doc != this.doc) {
          throw new RangeError("Selection passed to setSelection must point at the current document");
        }
        this.curSelection = selection;
        this.curSelectionFor = this.steps.length;
        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
        this.storedMarks = null;
        return this;
      };
      prototypeAccessors5.selectionSet.get = function() {
        return (this.updated & UPDATED_SEL) > 0;
      };
      Transaction2.prototype.setStoredMarks = function setStoredMarks(marks2) {
        this.storedMarks = marks2;
        this.updated |= UPDATED_MARKS;
        return this;
      };
      Transaction2.prototype.ensureMarks = function ensureMarks(marks2) {
        if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks2)) {
          this.setStoredMarks(marks2);
        }
        return this;
      };
      Transaction2.prototype.addStoredMark = function addStoredMark(mark3) {
        return this.ensureMarks(mark3.addToSet(this.storedMarks || this.selection.$head.marks()));
      };
      Transaction2.prototype.removeStoredMark = function removeStoredMark(mark3) {
        return this.ensureMarks(mark3.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      };
      prototypeAccessors5.storedMarksSet.get = function() {
        return (this.updated & UPDATED_MARKS) > 0;
      };
      Transaction2.prototype.addStep = function addStep2(step2, doc2) {
        Transform3.prototype.addStep.call(this, step2, doc2);
        this.updated = this.updated & ~UPDATED_MARKS;
        this.storedMarks = null;
      };
      Transaction2.prototype.setTime = function setTime(time) {
        this.time = time;
        return this;
      };
      Transaction2.prototype.replaceSelection = function replaceSelection(slice4) {
        this.selection.replace(this, slice4);
        return this;
      };
      Transaction2.prototype.replaceSelectionWith = function replaceSelectionWith(node4, inheritMarks) {
        var selection = this.selection;
        if (inheritMarks !== false) {
          node4 = node4.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
        }
        selection.replaceWith(this, node4);
        return this;
      };
      Transaction2.prototype.deleteSelection = function deleteSelection2() {
        this.selection.replace(this);
        return this;
      };
      Transaction2.prototype.insertText = function insertText(text3, from4, to) {
        if (to === void 0) to = from4;
        var schema = this.doc.type.schema;
        if (from4 == null) {
          if (!text3) {
            return this.deleteSelection();
          }
          return this.replaceSelectionWith(schema.text(text3), true);
        } else {
          if (!text3) {
            return this.deleteRange(from4, to);
          }
          var marks2 = this.storedMarks;
          if (!marks2) {
            var $from = this.doc.resolve(from4);
            marks2 = to == from4 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
          }
          this.replaceRangeWith(from4, to, schema.text(text3, marks2));
          if (!this.selection.empty) {
            this.setSelection(Selection.near(this.selection.$to));
          }
          return this;
        }
      };
      Transaction2.prototype.setMeta = function setMeta(key, value) {
        this.meta[typeof key == "string" ? key : key.key] = value;
        return this;
      };
      Transaction2.prototype.getMeta = function getMeta(key) {
        return this.meta[typeof key == "string" ? key : key.key];
      };
      prototypeAccessors5.isGeneric.get = function() {
        for (var _ in this.meta) {
          return false;
        }
        return true;
      };
      Transaction2.prototype.scrollIntoView = function scrollIntoView() {
        this.updated |= UPDATED_SCROLL;
        return this;
      };
      prototypeAccessors5.scrolledIntoView.get = function() {
        return (this.updated & UPDATED_SCROLL) > 0;
      };
      Object.defineProperties(Transaction2.prototype, prototypeAccessors5);
      return Transaction2;
    })(Transform);
    FieldDesc = function FieldDesc2(name, desc, self2) {
      this.name = name;
      this.init = bind(desc.init, self2);
      this.apply = bind(desc.apply, self2);
    };
    baseFields = [
      new FieldDesc("doc", {
        init: function init(config) {
          return config.doc || config.schema.topNodeType.createAndFill();
        },
        apply: function apply2(tr) {
          return tr.doc;
        }
      }),
      new FieldDesc("selection", {
        init: function init2(config, instance) {
          return config.selection || Selection.atStart(instance.doc);
        },
        apply: function apply3(tr) {
          return tr.selection;
        }
      }),
      new FieldDesc("storedMarks", {
        init: function init3(config) {
          return config.storedMarks || null;
        },
        apply: function apply4(tr, _marks, _old, state) {
          return state.selection.$cursor ? tr.storedMarks : null;
        }
      }),
      new FieldDesc("scrollToSelection", {
        init: function init4() {
          return 0;
        },
        apply: function apply5(tr, prev) {
          return tr.scrolledIntoView ? prev + 1 : prev;
        }
      })
    ];
    Configuration = function Configuration2(schema, plugins) {
      var this$1 = this;
      this.schema = schema;
      this.fields = baseFields.concat();
      this.plugins = [];
      this.pluginsByKey = /* @__PURE__ */ Object.create(null);
      if (plugins) {
        plugins.forEach(function(plugin) {
          if (this$1.pluginsByKey[plugin.key]) {
            throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
          }
          this$1.plugins.push(plugin);
          this$1.pluginsByKey[plugin.key] = plugin;
          if (plugin.spec.state) {
            this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
          }
        });
      }
    };
    EditorState = function EditorState2(config) {
      this.config = config;
    };
    prototypeAccessors$13 = { schema: { configurable: true }, plugins: { configurable: true }, tr: { configurable: true } };
    prototypeAccessors$13.schema.get = function() {
      return this.config.schema;
    };
    prototypeAccessors$13.plugins.get = function() {
      return this.config.plugins;
    };
    EditorState.prototype.apply = function apply6(tr) {
      return this.applyTransaction(tr).state;
    };
    EditorState.prototype.filterTransaction = function filterTransaction(tr, ignore) {
      if (ignore === void 0) ignore = -1;
      for (var i = 0; i < this.config.plugins.length; i++) {
        if (i != ignore) {
          var plugin = this.config.plugins[i];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) {
            return false;
          }
        }
      }
      return true;
    };
    EditorState.prototype.applyTransaction = function applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr)) {
        return { state: this, transactions: [] };
      }
      var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
      for (; ; ) {
        var haveNew = false;
        for (var i = 0; i < this.config.plugins.length; i++) {
          var plugin = this.config.plugins[i];
          if (plugin.spec.appendTransaction) {
            var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr && newState.filterTransaction(tr, i)) {
              tr.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (var j = 0; j < this.config.plugins.length; j++) {
                  seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
                }
              }
              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }
            if (seen) {
              seen[i] = { state: newState, n: trs.length };
            }
          }
        }
        if (!haveNew) {
          return { state: newState, transactions: trs };
        }
      }
    };
    EditorState.prototype.applyInner = function applyInner(tr) {
      if (!tr.before.eq(this.doc)) {
        throw new RangeError("Applying a mismatched transaction");
      }
      var newInstance = new EditorState(this.config), fields = this.config.fields;
      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }
      for (var i$1 = 0; i$1 < applyListeners.length; i$1++) {
        applyListeners[i$1](this, tr, newInstance);
      }
      return newInstance;
    };
    prototypeAccessors$13.tr.get = function() {
      return new Transaction(this);
    };
    EditorState.create = function create3(config) {
      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      var instance = new EditorState($config);
      for (var i = 0; i < $config.fields.length; i++) {
        instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
      }
      return instance;
    };
    EditorState.prototype.reconfigure = function reconfigure(config) {
      var $config = new Configuration(this.schema, config.plugins);
      var fields = $config.fields, instance = new EditorState($config);
      for (var i = 0; i < fields.length; i++) {
        var name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
      }
      return instance;
    };
    EditorState.prototype.toJSON = function toJSON6(pluginFields) {
      var result2 = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
      if (this.storedMarks) {
        result2.storedMarks = this.storedMarks.map(function(m) {
          return m.toJSON();
        });
      }
      if (pluginFields && typeof pluginFields == "object") {
        for (var prop2 in pluginFields) {
          if (prop2 == "doc" || prop2 == "selection") {
            throw new RangeError("The JSON fields `doc` and `selection` are reserved");
          }
          var plugin = pluginFields[prop2], state = plugin.spec.state;
          if (state && state.toJSON) {
            result2[prop2] = state.toJSON.call(plugin, this[plugin.key]);
          }
        }
      }
      return result2;
    };
    EditorState.fromJSON = function fromJSON7(config, json, pluginFields) {
      if (!json) {
        throw new RangeError("Invalid input for EditorState.fromJSON");
      }
      if (!config.schema) {
        throw new RangeError("Required config field 'schema' missing");
      }
      var $config = new Configuration(config.schema, config.plugins);
      var instance = new EditorState($config);
      $config.fields.forEach(function(field) {
        if (field.name == "doc") {
          instance.doc = Node2.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks) {
            instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
          }
        } else {
          if (pluginFields) {
            for (var prop2 in pluginFields) {
              var plugin = pluginFields[prop2], state = plugin.spec.state;
              if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop2)) {
                instance[field.name] = state.fromJSON.call(plugin, config, json[prop2], instance);
                return;
              }
            }
          }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance;
    };
    EditorState.addApplyListener = function addApplyListener(f) {
      applyListeners.push(f);
    };
    EditorState.removeApplyListener = function removeApplyListener(f) {
      var found2 = applyListeners.indexOf(f);
      if (found2 > -1) {
        applyListeners.splice(found2, 1);
      }
    };
    Object.defineProperties(EditorState.prototype, prototypeAccessors$13);
    applyListeners = [];
    Plugin = function Plugin2(spec) {
      this.props = {};
      if (spec.props) {
        bindProps(spec.props, this, this.props);
      }
      this.spec = spec;
      this.key = spec.key ? spec.key.key : createKey("plugin");
    };
    Plugin.prototype.getState = function getState(state) {
      return state[this.key];
    };
    keys = /* @__PURE__ */ Object.create(null);
    PluginKey = function PluginKey2(name) {
      if (name === void 0) name = "key";
      this.key = createKey(name);
    };
    PluginKey.prototype.get = function get(state) {
      return state.config.pluginsByKey[this.key];
    };
    PluginKey.prototype.getState = function getState2(state) {
      return state[this.key];
    };
  }
});

// ../../node_modules/.pnpm/prosemirror-view@1.18.11/node_modules/prosemirror-view/dist/index.es.js
var index_es_exports3 = {};
__export(index_es_exports3, {
  Decoration: () => Decoration,
  DecorationSet: () => DecorationSet,
  EditorView: () => EditorView,
  __endComposition: () => endComposition,
  __parseFromClipboard: () => parseFromClipboard,
  __serializeForClipboard: () => serializeForClipboard
});
function scanFor(node4, off2, targetNode, targetOff, dir) {
  for (; ; ) {
    if (node4 == targetNode && off2 == targetOff) {
      return true;
    }
    if (off2 == (dir < 0 ? 0 : nodeSize(node4))) {
      var parent = node4.parentNode;
      if (parent.nodeType != 1 || hasBlockDesc(node4) || atomElements.test(node4.nodeName) || node4.contentEditable == "false") {
        return false;
      }
      off2 = domIndex(node4) + (dir < 0 ? 0 : 1);
      node4 = parent;
    } else if (node4.nodeType == 1) {
      node4 = node4.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (node4.contentEditable == "false") {
        return false;
      }
      off2 = dir < 0 ? nodeSize(node4) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node4) {
  return node4.nodeType == 3 ? node4.nodeValue.length : node4.childNodes.length;
}
function isOnEdge(node4, offset2, parent) {
  for (var atStart2 = offset2 == 0, atEnd2 = offset2 == nodeSize(node4); atStart2 || atEnd2; ) {
    if (node4 == parent) {
      return true;
    }
    var index3 = domIndex(node4);
    node4 = node4.parentNode;
    if (!node4) {
      return false;
    }
    atStart2 = atStart2 && index3 == 0;
    atEnd2 = atEnd2 && index3 == nodeSize(node4);
  }
}
function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) {
      break;
    }
  }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function windowRect(doc2) {
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node4) {
  var rect2 = node4.getBoundingClientRect();
  var scaleX = rect2.width / node4.offsetWidth || 1;
  var scaleY = rect2.height / node4.offsetHeight || 1;
  return {
    left: rect2.left,
    right: rect2.left + node4.clientWidth * scaleX,
    top: rect2.top,
    bottom: rect2.top + node4.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect2, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc2 = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom; ; parent = parentNode(parent)) {
    if (!parent) {
      break;
    }
    if (parent.nodeType != 1) {
      continue;
    }
    var atTop = parent == doc2.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect(doc2) : clientRect(parent);
    var moveX = 0, moveY = 0;
    if (rect2.top < bounding.top + getSide(scrollThreshold, "top")) {
      moveY = -(bounding.top - rect2.top + getSide(scrollMargin, "top"));
    } else if (rect2.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) {
      moveY = rect2.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    }
    if (rect2.left < bounding.left + getSide(scrollThreshold, "left")) {
      moveX = -(bounding.left - rect2.left + getSide(scrollMargin, "left"));
    } else if (rect2.right > bounding.right - getSide(scrollThreshold, "right")) {
      moveX = rect2.right - bounding.right + getSide(scrollMargin, "right");
    }
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) {
          parent.scrollTop += moveY;
        }
        if (moveX) {
          parent.scrollLeft += moveX;
        }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect2 = { left: rect2.left - dX, top: rect2.top - dY, right: rect2.right - dX, bottom: rect2.bottom - dY };
      }
    }
    if (atTop) {
      break;
    }
  }
}
function storeScrollPos(view) {
  var rect2 = view.dom.getBoundingClientRect(), startY = Math.max(0, rect2.top);
  var refDOM, refTop;
  for (var x = (rect2.left + rect2.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect2.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (dom == view.dom || !view.dom.contains(dom)) {
      continue;
    }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  var stack = [], doc2 = dom.ownerDocument;
  for (; dom; dom = parentNode(dom)) {
    stack.push({ dom, top: dom.scrollTop, left: dom.scrollLeft });
    if (dom == doc2) {
      break;
    }
  }
  return stack;
}
function resetScrollPos(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var ref = stack[i];
    var dom = ref.dom;
    var top2 = ref.top;
    var left = ref.left;
    if (dom.scrollTop != top2 + dTop) {
      dom.scrollTop = top2 + dTop;
    }
    if (dom.scrollLeft != left) {
      dom.scrollLeft = left;
    }
  }
}
function focusPreventScroll(dom) {
  if (dom.setActive) {
    return dom.setActive();
  }
  if (preventScrollSupported) {
    return dom.focus(preventScrollSupported);
  }
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node4, coords) {
  var closest2, dxClosest = 2e8, coordsClosest, offset2 = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child3 = node4.firstChild, childIndex = 0; child3; child3 = child3.nextSibling, childIndex++) {
    var rects = void 0;
    if (child3.nodeType == 1) {
      rects = child3.getClientRects();
    } else if (child3.nodeType == 3) {
      rects = textRange(child3).getClientRects();
    } else {
      continue;
    }
    for (var i = 0; i < rects.length; i++) {
      var rect2 = rects[i];
      if (rect2.top <= rowBot && rect2.bottom >= rowTop) {
        rowBot = Math.max(rect2.bottom, rowBot);
        rowTop = Math.min(rect2.top, rowTop);
        var dx = rect2.left > coords.left ? rect2.left - coords.left : rect2.right < coords.left ? coords.left - rect2.right : 0;
        if (dx < dxClosest) {
          closest2 = child3;
          dxClosest = dx;
          coordsClosest = dx && closest2.nodeType == 3 ? { left: rect2.right < coords.left ? rect2.right : rect2.left, top: coords.top } : coords;
          if (child3.nodeType == 1 && dx) {
            offset2 = childIndex + (coords.left >= (rect2.left + rect2.right) / 2 ? 1 : 0);
          }
          continue;
        }
      }
      if (!closest2 && (coords.left >= rect2.right && coords.top >= rect2.top || coords.left >= rect2.left && coords.top >= rect2.bottom)) {
        offset2 = childIndex + 1;
      }
    }
  }
  if (closest2 && closest2.nodeType == 3) {
    return findOffsetInText(closest2, coordsClosest);
  }
  if (!closest2 || dxClosest && closest2.nodeType == 1) {
    return { node: node4, offset: offset2 };
  }
  return findOffsetInNode(closest2, coordsClosest);
}
function findOffsetInText(node4, coords) {
  var len = node4.nodeValue.length;
  var range2 = document.createRange();
  for (var i = 0; i < len; i++) {
    range2.setEnd(node4, i + 1);
    range2.setStart(node4, i);
    var rect2 = singleRect(range2, 1);
    if (rect2.top == rect2.bottom) {
      continue;
    }
    if (inRect(coords, rect2)) {
      return { node: node4, offset: i + (coords.left >= (rect2.left + rect2.right) / 2 ? 1 : 0) };
    }
  }
  return { node: node4, offset: 0 };
}
function inRect(coords, rect2) {
  return coords.left >= rect2.left - 1 && coords.left <= rect2.right + 1 && coords.top >= rect2.top - 1 && coords.top <= rect2.bottom + 1;
}
function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) {
    return parent;
  }
  return dom;
}
function posFromElement(view, elt, coords) {
  var ref = findOffsetInNode(elt, coords);
  var node4 = ref.node;
  var offset2 = ref.offset;
  var bias = -1;
  if (node4.nodeType == 1 && !node4.firstChild) {
    var rect2 = node4.getBoundingClientRect();
    bias = rect2.left != rect2.right && coords.left > (rect2.left + rect2.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node4, offset2, bias);
}
function posFromCaret(view, node4, offset2, coords) {
  var outside = -1;
  for (var cur = node4; ; ) {
    if (cur == view.dom) {
      break;
    }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) {
      return null;
    }
    if (desc.node.isBlock && desc.parent) {
      var rect2 = desc.dom.getBoundingClientRect();
      if (rect2.left > coords.left || rect2.top > coords.top) {
        outside = desc.posBefore;
      } else if (rect2.right < coords.left || rect2.bottom < coords.top) {
        outside = desc.posAfter;
      } else {
        break;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node4, offset2);
}
function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      var child3 = element.childNodes[i];
      if (child3.nodeType == 1) {
        var rects = child3.getClientRects();
        for (var j = 0; j < rects.length; j++) {
          var rect2 = rects[j];
          if (inRect(coords, rect2)) {
            return elementFromPoint(child3, coords, rect2);
          }
        }
      }
      if ((i = (i + 1) % len) == startI) {
        break;
      }
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  var assign2, assign$1;
  var root = view.root, node4, offset2;
  if (root.caretPositionFromPoint) {
    try {
      var pos$1 = root.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) {
        assign2 = pos$1, node4 = assign2.offsetNode, offset2 = assign2.offset;
      }
    } catch (_) {
    }
  }
  if (!node4 && root.caretRangeFromPoint) {
    var range2 = root.caretRangeFromPoint(coords.left, coords.top);
    if (range2) {
      assign$1 = range2, node4 = assign$1.startContainer, offset2 = assign$1.startOffset;
    }
  }
  var elt = root.elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) {
      return null;
    }
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) {
      return null;
    }
  }
  if (result.safari) {
    for (var p = elt; node4 && p; p = parentNode(p)) {
      if (p.draggable) {
        node4 = offset2 = null;
      }
    }
  }
  elt = targetKludge(elt, coords);
  if (node4) {
    if (result.gecko && node4.nodeType == 1) {
      offset2 = Math.min(offset2, node4.childNodes.length);
      if (offset2 < node4.childNodes.length) {
        var next = node4.childNodes[offset2], box$1;
        if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left && box$1.bottom > coords.top) {
          offset2++;
        }
      }
    }
    if (node4 == view.dom && offset2 == node4.childNodes.length - 1 && node4.lastChild.nodeType == 1 && coords.top > node4.lastChild.getBoundingClientRect().bottom) {
      pos = view.state.doc.content.size;
    } else if (offset2 == 0 || node4.nodeType != 1 || node4.childNodes[offset2 - 1].nodeName != "BR") {
      pos = posFromCaret(view, node4, offset2, coords);
    }
  }
  if (pos == null) {
    pos = posFromElement(view, elt, coords);
  }
  var desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function singleRect(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1];
}
function coordsAtPos(view, pos, side) {
  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node4 = ref.node;
  var offset2 = ref.offset;
  var supportEmptyRange = result.webkit || result.gecko;
  if (node4.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node4.nodeValue) || (side < 0 ? !offset2 : offset2 == node4.nodeValue.length))) {
      var rect2 = singleRect(textRange(node4, offset2, offset2), side);
      if (result.gecko && offset2 && /\s/.test(node4.nodeValue[offset2 - 1]) && offset2 < node4.nodeValue.length) {
        var rectBefore = singleRect(textRange(node4, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect2.top) {
          var rectAfter = singleRect(textRange(node4, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect2.top) {
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
          }
        }
      }
      return rect2;
    } else {
      var from4 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node4.nodeValue.length) {
        from4--;
        takeSide = 1;
      } else if (side < 0) {
        from4--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node4, from4, to), takeSide), takeSide < 0);
    }
  }
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset2 && (side < 0 || offset2 == nodeSize(node4))) {
      var before2 = node4.childNodes[offset2 - 1];
      if (before2.nodeType == 1) {
        return flattenH(before2.getBoundingClientRect(), false);
      }
    }
    if (offset2 < nodeSize(node4)) {
      var after2 = node4.childNodes[offset2];
      if (after2.nodeType == 1) {
        return flattenH(after2.getBoundingClientRect(), true);
      }
    }
    return flattenH(node4.getBoundingClientRect(), side >= 0);
  }
  if (offset2 && (side < 0 || offset2 == nodeSize(node4))) {
    var before$1 = node4.childNodes[offset2 - 1];
    var target2 = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1)) : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target2) {
      return flattenV(singleRect(target2, 1), false);
    }
  }
  if (offset2 < nodeSize(node4)) {
    var after$1 = node4.childNodes[offset2];
    var target$1 = after$1.nodeType == 3 ? textRange(after$1, 0, supportEmptyRange ? 0 : 1) : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) {
      return flattenV(singleRect(target$1, -1), true);
    }
  }
  return flattenV(singleRect(node4.nodeType == 3 ? textRange(node4) : node4, -side), side >= 0);
}
function flattenV(rect2, left) {
  if (rect2.width == 0) {
    return rect2;
  }
  var x = left ? rect2.left : rect2.right;
  return { top: rect2.top, bottom: rect2.bottom, left: x, right: x };
}
function flattenH(rect2, top2) {
  if (rect2.height == 0) {
    return rect2;
  }
  var y = top2 ? rect2.top : rect2.bottom;
  return { top: y, bottom: y, left: rect2.left, right: rect2.right };
}
function withFlushedState(view, state, f) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) {
    view.updateState(state);
  }
  if (active != view.dom) {
    view.focus();
  }
  try {
    return f();
  } finally {
    if (viewState != state) {
      view.updateState(viewState);
    }
    if (active != view.dom && active) {
      active.focus();
    }
  }
}
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function() {
    var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref.node;
    for (; ; ) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) {
        break;
      }
      if (nearest.node.isBlock) {
        dom = nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos(view, $pos.pos, 1);
    for (var child3 = dom.firstChild; child3; child3 = child3.nextSibling) {
      var boxes = void 0;
      if (child3.nodeType == 1) {
        boxes = child3.getClientRects();
      } else if (child3.nodeType == 3) {
        boxes = textRange(child3, 0, child3.nodeValue.length).getClientRects();
      } else {
        continue;
      }
      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top && (dir == "up" ? box.bottom < coords.top + 1 : box.top > coords.bottom - 1)) {
          return false;
        }
      }
    }
    return true;
  });
}
function endOfTextblockHorizontal(view, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock) {
    return false;
  }
  var offset2 = $head.parentOffset, atStart2 = !offset2, atEnd2 = offset2 == $head.parent.content.size;
  var sel = getSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) {
    return dir == "left" || dir == "backward" ? atStart2 : atEnd2;
  }
  return withFlushedState(view, state, function() {
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result2 = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) || oldNode == sel.focusNode && oldOff == sel.focusOffset;
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) {
      sel.caretBidiLevel = oldBidiLevel;
    }
    return result2;
  });
}
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) {
    return cachedResult;
  }
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  return new NodeViewDesc(null, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
}
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM) {
    view.trackWrites = null;
  }
}
function OuterDecoLevel(nodeName) {
  if (nodeName) {
    this.nodeName = nodeName;
  }
}
function computeOuterDeco(outerDeco, node4, needsWrap) {
  if (outerDeco.length == 0) {
    return noDeco;
  }
  var top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result2 = [top2];
  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) {
      continue;
    }
    if (attrs.nodeName) {
      result2.push(top2 = new OuterDecoLevel(attrs.nodeName));
    }
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) {
        continue;
      }
      if (needsWrap && result2.length == 1) {
        result2.push(top2 = new OuterDecoLevel(node4.isInline ? "span" : "div"));
      }
      if (name == "class") {
        top2.class = (top2.class ? top2.class + " " : "") + val;
      } else if (name == "style") {
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      } else if (name != "nodeName") {
        top2[name] = val;
      }
    }
  }
  return result2;
}
function patchOuterDeco(outerDOM, nodeDOM2, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) {
    return nodeDOM2;
  }
  var curDOM = nodeDOM2;
  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      var parent = void 0;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (var name in prev) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) {
      dom.removeAttribute(name);
    }
  }
  for (var name$1 in cur) {
    if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1]) {
      dom.setAttribute(name$1, cur[name$1]);
    }
  }
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
    for (var i = 0; i < prevList.length; i++) {
      if (curList.indexOf(prevList[i]) == -1) {
        dom.classList.remove(prevList[i]);
      }
    }
    for (var i$1 = 0; i$1 < curList.length; i$1++) {
      if (prevList.indexOf(curList[i$1]) == -1) {
        dom.classList.add(curList[i$1]);
      }
    }
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop2 = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop2.exec(prev.style)) {
        dom.style.removeProperty(m[1]);
      }
    }
    if (cur.style) {
      dom.style.cssText += cur.style;
    }
  }
}
function applyOuterDeco(dom, deco, node4) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node4, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length) {
    return false;
  }
  for (var i = 0; i < a.length; i++) {
    if (!a[i].type.eq(b[i].type)) {
      return false;
    }
  }
  return true;
}
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
function preMatch(frag, descs) {
  var fI = frag.childCount, dI = descs.length, matched = /* @__PURE__ */ new Map();
  for (; fI > 0 && dI > 0; dI--) {
    var desc = descs[dI - 1], node4 = desc.node;
    if (!node4) {
      continue;
    }
    if (node4 != frag.child(fI - 1)) {
      break;
    }
    --fI;
    matched.set(desc, fI);
  }
  return { index: fI, matched };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  var locals3 = deco.locals(parent), offset2 = 0;
  if (locals3.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child3 = parent.child(i);
      onNode(child3, locals3, deco.forChild(offset2, child3), i);
      offset2 += child3.nodeSize;
    }
    return;
  }
  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0; ; ) {
    if (decoIndex < locals3.length && locals3[decoIndex].to == offset2) {
      var widget2 = locals3[decoIndex++], widgets = void 0;
      while (decoIndex < locals3.length && locals3[decoIndex].to == offset2) {
        (widgets || (widgets = [widget2])).push(locals3[decoIndex++]);
      }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) {
          onWidget(widgets[i$1], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget2, parentIndex, !!restNode);
      }
    }
    var child$1 = void 0, index3 = void 0;
    if (restNode) {
      index3 = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index3 = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var i$2 = 0; i$2 < active.length; i$2++) {
      if (active[i$2].to <= offset2) {
        active.splice(i$2--, 1);
      }
    }
    while (decoIndex < locals3.length && locals3[decoIndex].from <= offset2 && locals3[decoIndex].to > offset2) {
      active.push(locals3[decoIndex++]);
    }
    var end2 = offset2 + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end2;
      if (decoIndex < locals3.length && locals3[decoIndex].from < cutAt) {
        cutAt = locals3[decoIndex].from;
      }
      for (var i$3 = 0; i$3 < active.length; i$3++) {
        if (active[i$3].to < cutAt) {
          cutAt = active[i$3].to;
        }
      }
      if (cutAt < end2) {
        restNode = child$1.cut(cutAt - offset2);
        child$1 = child$1.cut(0, cutAt - offset2);
        end2 = cutAt;
        index3 = -1;
      }
    }
    var outerDeco = !active.length ? nothing : child$1.isInline && !child$1.isLeaf ? active.filter(function(d) {
      return !d.inline;
    }) : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset2, child$1), index3);
    offset2 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node4, offset2) {
  for (; ; ) {
    if (node4.nodeType == 3) {
      return node4;
    }
    if (node4.nodeType == 1 && offset2 > 0) {
      if (node4.childNodes.length > offset2 && node4.childNodes[offset2].nodeType == 3) {
        return node4.childNodes[offset2];
      }
      node4 = node4.childNodes[offset2 - 1];
      offset2 = nodeSize(node4);
    } else if (node4.nodeType == 1 && offset2 < node4.childNodes.length) {
      node4 = node4.childNodes[offset2];
      offset2 = 0;
    } else {
      return null;
    }
  }
}
function findTextInFragment(frag, text3, from4, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    var child3 = frag.child(i++), childStart = pos;
    pos += child3.nodeSize;
    if (!child3.isText) {
      continue;
    }
    var str = child3.text;
    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) {
        break;
      }
      str += next.text;
    }
    if (pos >= from4) {
      var found2 = str.lastIndexOf(text3, to - childStart);
      if (found2 >= 0 && found2 + text3.length + childStart >= from4) {
        return childStart + found2;
      }
    }
  }
  return -1;
}
function replaceNodes(nodes, from4, to, view, replacement) {
  var result2 = [];
  for (var i = 0, off2 = 0; i < nodes.length; i++) {
    var child3 = nodes[i], start3 = off2, end2 = off2 += child3.size;
    if (start3 >= to || end2 <= from4) {
      result2.push(child3);
    } else {
      if (start3 < from4) {
        result2.push(child3.slice(0, from4 - start3, view));
      }
      if (replacement) {
        result2.push(replacement);
        replacement = null;
      }
      if (end2 > to) {
        result2.push(child3.slice(to - start3, child3.size, view));
      }
    }
  }
  return result2;
}
function selectionFromDOM(view, origin) {
  var domSel = view.root.getSelection(), doc2 = view.state.doc;
  if (!domSel.focusNode) {
    return null;
  }
  var nearestDesc2 = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc2 && nearestDesc2.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) {
    return null;
  }
  var $head = doc2.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc2 && !nearestDesc2.node) {
      nearestDesc2 = nearestDesc2.parent;
    }
    if (nearestDesc2 && nearestDesc2.node.isAtom && NodeSelection.isSelectable(nearestDesc2.node) && nearestDesc2.parent && !(nearestDesc2.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc2.dom))) {
      var pos = nearestDesc2.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor < 0) {
      return null;
    }
    $anchor = doc2.resolve(anchor);
  }
  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force) {
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view)) {
    return;
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent) {
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      }
      if (!sel.empty && !sel.$from.parent.inlineContent) {
        resetEditableTo = temporarilyEditableNear(view, sel.to);
      }
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) {
        resetEditable(resetEditableFrom);
      }
      if (resetEditableTo) {
        resetEditable(resetEditableTo);
      }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) {
        removeClassOnSelectionChange(view);
      }
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
function temporarilyEditableNear(view, pos) {
  var ref = view.docView.domFromPos(pos, 0);
  var node4 = ref.node;
  var offset2 = ref.offset;
  var after2 = offset2 < node4.childNodes.length ? node4.childNodes[offset2] : null;
  var before2 = offset2 ? node4.childNodes[offset2 - 1] : null;
  if (result.safari && after2 && after2.contentEditable == "false") {
    return setEditable(after2);
  }
  if ((!after2 || after2.contentEditable == "false") && (!before2 || before2.contentEditable == "false")) {
    if (after2) {
      return setEditable(after2);
    } else if (before2) {
      return setEditable(before2);
    }
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (result.safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  var doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node4 = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.hideSelectionGuard = function() {
    if (domSel.anchorNode != node4 || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function() {
        if (!editorOwnsSelection(view) || view.state.selection.visible) {
          view.dom.classList.remove("ProseMirror-hideselection");
        }
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  var domSel = view.root.getSelection(), range2 = document.createRange();
  var node4 = view.cursorWrapper.dom, img = node4.nodeName == "IMG";
  if (img) {
    range2.setEnd(node4.parentNode, domIndex(node4) + 1);
  } else {
    range2.setEnd(node4, 0);
  }
  range2.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range2);
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node4.disabled = true;
    node4.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) {
        desc.selectNode();
      }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) {
      view.lastSelectedViewDesc.deselectNode();
    }
    view.lastSelectedViewDesc = null;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function(f) {
    return f(view, $anchor, $head);
  }) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) {
    return false;
  }
  return hasSelection(view);
}
function hasSelection(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) {
    return false;
  }
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply7(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection) {
        return apply7(view, next);
      }
      return false;
    } else if (!(result.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node4 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node4 || node4.isText) {
        return false;
      }
      var nodePos = dir < 0 ? $head.pos - node4.nodeSize : $head.pos;
      if (!(node4.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) {
        return false;
      }
      if (NodeSelection.isSelectable(node4)) {
        return apply7(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node4.nodeSize) : $head));
      } else if (result.webkit) {
        return apply7(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node4.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply7(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var next$1 = moveSelectionBlock(view.state, dir);
    if (next$1) {
      return apply7(view, next$1);
    }
    return false;
  }
}
function nodeLen(node4) {
  return node4.nodeType == 3 ? node4.nodeValue.length : node4.childNodes.length;
}
function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodesLeft(view) {
  var sel = view.root.getSelection();
  var node4 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node4) {
    return;
  }
  var moveNode, moveOffset, force = false;
  if (result.gecko && node4.nodeType == 1 && offset2 < nodeLen(node4) && isIgnorable(node4.childNodes[offset2])) {
    force = true;
  }
  for (; ; ) {
    if (offset2 > 0) {
      if (node4.nodeType != 1) {
        break;
      } else {
        var before2 = node4.childNodes[offset2 - 1];
        if (isIgnorable(before2)) {
          moveNode = node4;
          moveOffset = --offset2;
        } else if (before2.nodeType == 3) {
          node4 = before2;
          offset2 = node4.nodeValue.length;
        } else {
          break;
        }
      }
    } else if (isBlockNode(node4)) {
      break;
    } else {
      var prev = node4.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node4.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node4 = node4.parentNode;
        if (node4 == view.dom) {
          break;
        }
        offset2 = 0;
      } else {
        node4 = prev;
        offset2 = nodeLen(node4);
      }
    }
  }
  if (force) {
    setSelFocus(view, sel, node4, offset2);
  } else if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function skipIgnoredNodesRight(view) {
  var sel = view.root.getSelection();
  var node4 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node4) {
    return;
  }
  var len = nodeLen(node4);
  var moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node4.nodeType != 1) {
        break;
      }
      var after2 = node4.childNodes[offset2];
      if (isIgnorable(after2)) {
        moveNode = node4;
        moveOffset = ++offset2;
      } else {
        break;
      }
    } else if (isBlockNode(node4)) {
      break;
    } else {
      var next = node4.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node4 = node4.parentNode;
        if (node4 == view.dom) {
          break;
        }
        offset2 = len = 0;
      } else {
        node4 = next;
        offset2 = 0;
        len = nodeLen(node4);
      }
    }
  }
  if (moveNode) {
    setSelFocus(view, sel, moveNode, moveOffset);
  }
}
function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function setSelFocus(view, sel, node4, offset2) {
  if (selectionCollapsed(sel)) {
    var range2 = document.createRange();
    range2.setEnd(node4, offset2);
    range2.setStart(node4, offset2);
    sel.removeAllRanges();
    sel.addRange(range2);
  } else if (sel.extend) {
    sel.extend(node4, offset2);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function() {
    if (view.state == state) {
      selectionToDOM(view);
    }
  }, 50);
}
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1) {
    return false;
  }
  if (result.mac && mods.indexOf("m") > -1) {
    return false;
  }
  var $from = sel.$from;
  var $to = sel.$to;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection) {
      return apply7(view, next);
    }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply7(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection)) {
    return true;
  }
  var ref = view.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty3 = ref.empty;
  if (!$head.sameParent($anchor)) {
    return true;
  }
  if (!empty3) {
    return false;
  }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
    return true;
  }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) {
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    } else {
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    }
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node4, state) {
  view.domObserver.stop();
  node4.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!result.safari || view.state.selection.$head.parentOffset > 0) {
    return;
  }
  var ref = view.root.getSelection();
  var focusNode = ref.focusNode;
  var focusOffset = ref.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child3 = focusNode.firstChild;
    switchEditable(view, child3, true);
    setTimeout(function() {
      return switchEditable(view, child3, false);
    }, 20);
  }
}
function getMods(event) {
  var result2 = "";
  if (event.ctrlKey) {
    result2 += "c";
  }
  if (event.metaKey) {
    result2 += "m";
  }
  if (event.altKey) {
    result2 += "a";
  }
  if (event.shiftKey) {
    result2 += "s";
  }
  return result2;
}
function captureKeyDown(view, event) {
  var code2 = event.keyCode, mods = getMods(event);
  if (code2 == 8 || result.mac && code2 == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view);
  } else if (code2 == 46 || result.mac && code2 == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view);
  } else if (code2 == 13 || code2 == 27) {
    return true;
  } else if (code2 == 37) {
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code2 == 39) {
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (code2 == 38) {
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view);
  } else if (code2 == 40) {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view);
  } else if (mods == (result.mac ? "m" : "c") && (code2 == 66 || code2 == 73 || code2 == 89 || code2 == 90)) {
    return true;
  }
  return false;
}
function parseBetween(view, from_, to_) {
  var ref = view.docView.parseRange(from_, to_);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from4 = ref.from;
  var to = ref.to;
  var domSel = view.root.getSelection(), find2 = null, anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel)) {
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
    }
  }
  if (result.chrome && view.lastKeyCode === 8) {
    for (var off2 = toOffset; off2 > fromOffset; off2--) {
      var node4 = parent.childNodes[off2 - 1], desc = node4.pmViewDesc;
      if (node4.nodeName == "BR" && !desc) {
        toOffset = off2;
        break;
      }
      if (!desc || desc.size) {
        break;
      }
    }
  }
  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from4);
  var sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.spec.code ? "full" : true,
    editableContent: true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    var anchor$1 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null) {
      head = anchor$1;
    }
    sel = { anchor: anchor$1 + from4, head: head + from4 };
  }
  return { doc: doc2, sel, from: from4, to };
}
function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
}
function readDOMChange(view, from4, to, typeOver, addedNodes) {
  if (from4 < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") {
        tr$1.setMeta("pointer", true);
      } else if (origin == "key") {
        tr$1.scrollIntoView();
      }
      view.dispatch(tr$1);
    }
    return;
  }
  var $before = view.state.doc.resolve(from4);
  var shared = $before.sharedDepth(to);
  from4 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse3 = parseBetween(view, from4, to);
  if (result.chrome && view.cursorWrapper && parse3.sel && parse3.sel.anchor == view.cursorWrapper.deco.from) {
    var text3 = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text3 && text3.nodeValue ? text3.nodeValue.length : 1;
    parse3.sel = { anchor: parse3.sel.anchor + size, head: parse3.sel.anchor + size };
  }
  var doc2 = view.state.doc, compare = doc2.slice(parse3.from, parse3.to);
  var preferredPos, preferredSide;
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;
  var change = findDiff(compare.content, parse3.doc.content, parse3.from, preferredPos, preferredSide);
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse3.sel && parse3.sel.anchor != parse3.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) && addedNodes.some(function(n) {
      return n.nodeName == "DIV" || n.nodeName == "P";
    }) && view.someProp("handleKeyDown", function(f) {
      return f(view, keyEvent(13, "Enter"));
    })) {
      view.lastIOSEnter = 0;
      return;
    } else {
      if (parse3.sel) {
        var sel$1 = resolveSelection(view, view.state.doc, parse3.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) {
          view.dispatch(view.state.tr.setSelection(sel$1));
        }
      }
      return;
    }
  }
  view.domChangeCount++;
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse3.from && parse3.doc.textBetween(change.start - parse3.from - 1, change.start - parse3.from + 1) == "  ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  var $from = parse3.doc.resolveNoCache(change.start - parse3.from);
  var $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  if ((result.ios && view.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function(n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  })) || !inlineChange && $from.pos < parse3.doc.content.size && (nextSel = Selection.findFrom(parse3.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function(f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function(f) {
    return f(view, keyEvent(8, "Backspace"));
  })) {
    if (result.android && result.chrome) {
      view.domObserver.suppressSelectionUpdates();
    }
    return;
  }
  if (result.chrome && result.android && change.toB == change.from) {
    view.lastAndroidDelete = Date.now();
  }
  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse3.sel && parse3.sel.anchor == parse3.sel.head && parse3.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse3.doc.resolveNoCache(change.endB - parse3.from);
    setTimeout(function() {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  var chFrom = change.start, chTo = change.endA;
  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function() {
          return selectionToDOM(view);
        }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && ($from1 = doc2.resolve(change.start)) && (markChange = isMarkChange(
        $from.parent.content.cut($from.parentOffset, $to.parentOffset),
        $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())
      ))
    ) {
      tr = view.state.tr;
      if (markChange.type == "add") {
        tr.addMark(chFrom, chTo, markChange.mark);
      } else {
        tr.removeMark(chFrom, chTo, markChange.mark);
      }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text$12 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function(f) {
        return f(view, chFrom, chTo, text$12);
      })) {
        return;
      }
      tr = view.state.tr.insertText(text$12, chFrom, chTo);
    }
  }
  if (!tr) {
    tr = view.state.tr.replace(chFrom, chTo, parse3.doc.slice(change.start - parse3.from, change.endB - parse3.from));
  }
  if (parse3.sel) {
    var sel$2 = resolveSelection(view, tr.doc, parse3.sel);
    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty && (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) && (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) || result.ie && sel$2.empty && sel$2.head == chFrom)) {
      tr.setSelection(sel$2);
    }
  }
  if (storedMarks) {
    tr.ensureMarks(storedMarks);
  }
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size) {
    return null;
  }
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark3, update2;
  for (var i = 0; i < prevMarks.length; i++) {
    added = prevMarks[i].removeFromSet(added);
  }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) {
    removed = curMarks[i$1].removeFromSet(removed);
  }
  if (added.length == 1 && removed.length == 0) {
    mark3 = added[0];
    type = "add";
    update2 = function(node4) {
      return node4.mark(mark3.addToSet(node4.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark3 = removed[0];
    type = "remove";
    update2 = function(node4) {
      return node4.mark(mark3.removeFromSet(node4.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev.childCount; i$2++) {
    updated.push(update2(prev.child(i$2)));
  }
  if (Fragment.from(updated).eq(cur)) {
    return { mark: mark3, type };
  }
}
function looksLikeJoin(old, start3, end2, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || // The content must have shrunk
  end2 - start3 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
  skipClosingAndOpening($newStart, true, false) < $newEnd.pos) {
    return false;
  }
  var $start = old.resolve(start3);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) {
    return false;
  }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2) {
    return false;
  }
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start3 = a.findDiffStart(b, pos);
  if (start3 == null) {
    return null;
  }
  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start3 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start3;
  }
  if (endA < start3 && a.size < b.size) {
    var move2 = preferredPos <= start3 && preferredPos >= endA ? start3 - preferredPos : 0;
    start3 -= move2;
    endB = start3 + (endB - endA);
    endA = start3;
  } else if (endB < start3) {
    var move$1 = preferredPos <= start3 && preferredPos >= endB ? start3 - preferredPos : 0;
    start3 -= move$1;
    endA = start3 + (endA - endB);
    endB = start3;
  }
  return { start: start3, endA, endB };
}
function serializeForClipboard(view, slice4) {
  var context = [];
  var content2 = slice4.content;
  var openStart = slice4.openStart;
  var openEnd = slice4.openEnd;
  while (openStart > 1 && openEnd > 1 && content2.childCount == 1 && content2.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node4 = content2.firstChild;
    context.push(node4.type.name, node4.attrs != node4.type.defaultAttrs ? node4.attrs : null);
    content2 = node4.content;
  }
  var serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  var doc2 = detachedDoc(), wrap = doc2.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content2, { document: doc2 }));
  var firstChild = wrap.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc2.createElement(needsWrap[i]);
      while (wrap.firstChild) {
        wrapper.appendChild(wrap.firstChild);
      }
      wrap.appendChild(wrapper);
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) {
    firstChild.setAttribute("data-pm-slice", openStart + " " + openEnd + " " + JSON.stringify(context));
  }
  var text3 = view.someProp("clipboardTextSerializer", function(f) {
    return f(slice4);
  }) || slice4.content.textBetween(0, slice4.content.size, "\n\n");
  return { dom: wrap, text: text3 };
}
function parseFromClipboard(view, text3, html2, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice4;
  if (!html2 && !text3) {
    return null;
  }
  var asText = text3 && (plainText || inCode || !html2);
  if (asText) {
    view.someProp("transformPastedText", function(f) {
      text3 = f(text3, inCode || plainText);
    });
    if (inCode) {
      return new Slice(Fragment.from(view.state.schema.text(text3.replace(/\r\n?/g, "\n"))), 0, 0);
    }
    var parsed = view.someProp("clipboardTextParser", function(f) {
      return f(text3, $context, plainText);
    });
    if (parsed) {
      slice4 = parsed;
    } else {
      var marks2 = $context.marks();
      var ref = view.state;
      var schema = ref.schema;
      var serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text3.trim().split(/(?:\r\n?|\n)+/).forEach(function(block2) {
        dom.appendChild(document.createElement("p")).appendChild(serializer.serializeNode(schema.text(block2, marks2)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", function(f) {
      html2 = f(html2);
    });
    dom = readHTML(html2);
    if (result.webkit) {
      restoreReplacedSpaces(dom);
    }
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice4) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser.fromSchema(view.state.schema);
    slice4 = parser.parseSlice(dom, { preserveWhitespace: !!(asText || sliceData), context: $context });
  }
  if (sliceData) {
    slice4 = addContext(closeSlice(slice4, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else {
    slice4 = Slice.maxOpen(normalizeSiblings(slice4.content, $context), false);
  }
  view.someProp("transformPasted", function(f) {
    slice4 = f(slice4);
  });
  return slice4;
}
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) {
    return fragment;
  }
  var loop = function(d2) {
    var parent = $context.node(d2);
    var match = parent.contentMatchAt($context.index(d2));
    var lastWrap = void 0, result2 = [];
    fragment.forEach(function(node4) {
      if (!result2) {
        return;
      }
      var wrap = match.findWrapping(node4.type), inLast;
      if (!wrap) {
        return result2 = null;
      }
      if (inLast = result2.length && lastWrap.length && addToSibling(wrap, lastWrap, node4, result2[result2.length - 1], 0)) {
        result2[result2.length - 1] = inLast;
      } else {
        if (result2.length) {
          result2[result2.length - 1] = closeRight(result2[result2.length - 1], lastWrap.length);
        }
        var wrapped = withWrappers(node4, wrap);
        result2.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap;
      }
    });
    if (result2) {
      return { v: Fragment.from(result2) };
    }
  };
  for (var d = $context.depth; d >= 0; d--) {
    var returned = loop(d);
    if (returned) return returned.v;
  }
  return fragment;
}
function withWrappers(node4, wrap, from4) {
  if (from4 === void 0) from4 = 0;
  for (var i = wrap.length - 1; i >= from4; i--) {
    node4 = wrap[i].create(null, Fragment.from(node4));
  }
  return node4;
}
function addToSibling(wrap, lastWrap, node4, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node4, sibling.lastChild, depth + 1);
    if (inner) {
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    }
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node4.type : wrap[depth + 1])) {
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node4, wrap, depth + 1))));
    }
  }
}
function closeRight(node4, depth) {
  if (depth == 0) {
    return node4;
  }
  var fragment = node4.content.replaceChild(node4.childCount - 1, closeRight(node4.lastChild, depth - 1));
  var fill = node4.contentMatchAt(node4.childCount).fillBefore(Fragment.empty, true);
  return node4.copy(fragment.append(fill));
}
function closeRange(fragment, side, from4, to, depth, openEnd) {
  var node4 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node4.content;
  if (depth < to - 1) {
    inner = closeRange(inner, side, from4, to, depth + 1, openEnd);
  }
  if (depth >= from4) {
    inner = side < 0 ? node4.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner) : inner.append(node4.contentMatchAt(node4.childCount).fillBefore(Fragment.empty, true));
  }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node4.copy(inner));
}
function closeSlice(slice4, openStart, openEnd) {
  if (openStart < slice4.openStart) {
    slice4 = new Slice(closeRange(slice4.content, -1, openStart, slice4.openStart, 0, slice4.openEnd), openStart, slice4.openEnd);
  }
  if (openEnd < slice4.openEnd) {
    slice4 = new Slice(closeRange(slice4.content, 1, openEnd, slice4.openEnd, 0, 0), slice4.openStart, openEnd);
  }
  return slice4;
}
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html2) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html2);
  if (metas) {
    html2 = html2.slice(metas[0].length);
  }
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html2), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) {
    html2 = wrap.map(function(n) {
      return "<" + n + ">";
    }).join("") + html2 + wrap.map(function(n) {
      return "</" + n + ">";
    }).reverse().join("");
  }
  elt.innerHTML = html2;
  if (wrap) {
    for (var i = 0; i < wrap.length; i++) {
      elt = elt.querySelector(wrap[i]) || elt;
    }
  }
  return elt;
}
function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i = 0; i < nodes.length; i++) {
    var node4 = nodes[i];
    if (node4.childNodes.length == 1 && node4.textContent == " " && node4.parentNode) {
      node4.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node4);
    }
  }
}
function addContext(slice4, context) {
  if (!slice4.size) {
    return slice4;
  }
  var schema = slice4.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice4;
  }
  var content2 = slice4.content;
  var openStart = slice4.openStart;
  var openEnd = slice4.openEnd;
  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) {
      break;
    }
    content2 = Fragment.from(type.create(array[i + 1], content2));
    openStart++;
    openEnd++;
  }
  return new Slice(content2, openStart, openEnd);
}
function checkCSS(view) {
  if (cssChecked) {
    return;
  }
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal") {
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
  }
}
function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = { time: 0, x: 0, y: 0, type: "" };
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;
  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;
  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;
  view.domObserver = new DOMObserver(view, function(from4, to, typeOver, added) {
    return readDOMChange(view, from4, to, typeOver, added);
  });
  view.domObserver.start();
  view.domChangeCount = 0;
  view.eventHandlers = /* @__PURE__ */ Object.create(null);
  var loop = function(event2) {
    var handler = handlers[event2];
    view.dom.addEventListener(event2, view.eventHandlers[event2] = function(event3) {
      if (eventBelongsToView(view, event3) && !runCustomHandler(view, event3) && (view.editable || !(event3.type in editHandlers))) {
        handler(view, event3);
      }
    });
  };
  for (var event in handlers) loop(event);
  if (result.safari) {
    view.dom.addEventListener("input", function() {
      return null;
    });
  }
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (var type in view.eventHandlers) {
    view.dom.removeEventListener(type, view.eventHandlers[type]);
  }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", function(currentHandlers) {
    for (var type in currentHandlers) {
      if (!view.eventHandlers[type]) {
        view.dom.addEventListener(type, view.eventHandlers[type] = function(event) {
          return runCustomHandler(view, event);
        });
      }
    }
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function(handlers2) {
    var handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles) {
    return true;
  }
  if (event.defaultPrevented) {
    return false;
  }
  for (var node4 = event.target; node4 != view.dom; node4 = node4.parentNode) {
    if (!node4 || node4.nodeType == 11 || node4.pmViewDesc && node4.pmViewDesc.stopEvent(event)) {
      return false;
    }
  }
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) {
    handlers[event.type](view, event);
  }
}
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside);
  var loop = function(i2) {
    if (view.someProp(propName, function(f) {
      return i2 > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i2), event, true) : f(view, pos, $pos.node(i2), $pos.before(i2), event, false);
    })) {
      return { v: true };
    }
  };
  for (var i = $pos.depth + 1; i > 0; i--) {
    var returned = loop(i);
    if (returned) return returned.v;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused) {
    view.focus();
  }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") {
    tr.setMeta("pointer", true);
  }
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1) {
    return false;
  }
  var $pos = view.state.doc.resolve(inside), node4 = $pos.nodeAfter;
  if (node4 && node4.isAtom && NodeSelection.isSelectable(node4)) {
    updateSelection(view, new NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1) {
    return false;
  }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection) {
    selectedNode = sel.node;
  }
  var $pos = view.state.doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node4 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node4)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) {
        selectAt = $pos.before(sel.$from.depth);
      } else {
        selectAt = $pos.before(i);
      }
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode2) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function(f) {
    return f(view, pos, event);
  }) || (selectNode2 ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function(f) {
    return f(view, pos, event);
  });
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function(f) {
    return f(view, pos, event);
  }) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0) {
    return false;
  }
  var doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc2.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node4 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node4.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node4.content.size), "pointer");
    } else if (NodeSelection.isSelectable(node4)) {
      updateSelection(view, NodeSelection.create(doc2, nodePos), "pointer");
    } else {
      continue;
    }
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
function inOrNearComposition(view, event) {
  if (view.composing) {
    return true;
  }
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) {
    view.composingTimeout = setTimeout(function() {
      return endComposition(view);
    }, delay);
  }
}
function clearComposition(view) {
  view.composing = false;
  while (view.compositionNodes.length > 0) {
    view.compositionNodes.pop().markParentsDirty();
  }
}
function endComposition(view, forceUpdate) {
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) {
      view.dispatch(view.state.tr.setSelection(sel));
    } else {
      view.updateState(view.state);
    }
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode) {
    return;
  }
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range2 = document.createRange();
  range2.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range2);
  setTimeout(function() {
    if (wrap.parentNode) {
      wrap.parentNode.removeChild(wrap);
    }
    view.focus();
  }, 50);
}
function sliceSingleNode(slice4) {
  return slice4.openStart == 0 && slice4.openEnd == 0 && slice4.content.childCount == 1 ? slice4.content.firstChild : null;
}
function capturePaste(view, e) {
  if (!view.dom.parentNode) {
    return;
  }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target2 = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) {
    target2.contentEditable = "true";
  }
  target2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target2.focus();
  setTimeout(function() {
    view.focus();
    if (target2.parentNode) {
      target2.parentNode.removeChild(target2);
    }
    if (plainText) {
      doPaste(view, target2.value, null, e);
    } else {
      doPaste(view, target2.textContent, target2.innerHTML, e);
    }
  }, 50);
}
function doPaste(view, text3, html2, e) {
  var slice4 = parseFromClipboard(view, text3, html2, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function(f) {
    return f(view, e, slice4 || Slice.empty);
  })) {
    return true;
  }
  if (!slice4) {
    return false;
  }
  var singleNode = sliceSingleNode(slice4);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice4);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function compareObjs(a, b) {
  if (a == b) {
    return true;
  }
  for (var p in a) {
    if (a[p] !== b[p]) {
      return false;
    }
  }
  for (var p$1 in b) {
    if (!(p$1 in a)) {
      return false;
    }
  }
  return true;
}
function mapChildren(oldChildren, newLocal, mapping, node4, offset2, oldOffset, options) {
  var children = oldChildren.slice();
  var shift2 = function(oldStart, oldEnd, newStart, newEnd) {
    for (var i2 = 0; i2 < children.length; i2 += 3) {
      var end2 = children[i2 + 1], dSize = void 0;
      if (end2 == -1 || oldStart > end2 + oldOffset) {
        continue;
      }
      if (oldEnd >= children[i2] + oldOffset) {
        children[i2 + 1] = -1;
      } else if (newStart >= offset2 && (dSize = newEnd - newStart - (oldEnd - oldStart))) {
        children[i2] += dSize;
        children[i2 + 1] += dSize;
      }
    }
  };
  for (var i = 0; i < mapping.maps.length; i++) {
    mapping.maps[i].forEach(shift2);
  }
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) {
    if (children[i$1 + 1] == -1) {
      var from4 = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from4 - offset2;
      if (fromLocal < 0 || fromLocal >= node4.content.size) {
        mustRebuild = true;
        continue;
      }
      var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset2;
      var ref = node4.content.findIndex(fromLocal);
      var index3 = ref.index;
      var childOffset = ref.offset;
      var childNode = node4.maybeChild(index3);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[i$1 + 2].mapInner(mapping, childNode, from4 + 1, oldChildren[i$1] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i$1] = fromLocal;
          children[i$1 + 1] = toLocal;
          children[i$1 + 2] = mapped;
        } else {
          children[i$1 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(
      children,
      oldChildren,
      newLocal || [],
      mapping,
      offset2,
      oldOffset,
      options
    );
    var built = buildTree(decorations, node4, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) {
      if (children[i$2 + 1] < 0) {
        children.splice(i$2, 3);
        i$2 -= 3;
      }
    }
    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j < children.length && children[j] < from$1) {
        j += 3;
      }
      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }
  return new DecorationSet(newLocal && newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length) {
    return spans;
  }
  var result2 = [];
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result2.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result2;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set2, oldOffset2) {
    for (var i2 = 0; i2 < set2.local.length; i2++) {
      var mapped = set2.local[i2].map(mapping, offset2, oldOffset2);
      if (mapped) {
        decorations.push(mapped);
      } else if (options.onRemove) {
        options.onRemove(set2.local[i2].spec);
      }
    }
    for (var i$1 = 0; i$1 < set2.children.length; i$1 += 3) {
      gather(set2.children[i$1 + 2], set2.children[i$1] + oldOffset2 + 1);
    }
  }
  for (var i = 0; i < children.length; i += 3) {
    if (children[i + 1] == -1) {
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
    }
  }
  return decorations;
}
function takeSpansForNode(spans, node4, offset2) {
  if (node4.isLeaf) {
    return null;
  }
  var end2 = offset2 + node4.nodeSize, found2 = null;
  for (var i = 0, span = void 0; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  var result2 = [];
  for (var i = 0; i < array.length; i++) {
    if (array[i] != null) {
      result2.push(array[i]);
    }
  }
  return result2;
}
function buildTree(spans, node4, offset2, options) {
  var children = [], hasNulls = false;
  node4.forEach(function(childNode, localStart) {
    var found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      var subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty) {
        children.push(localStart, localStart + childNode.nodeSize, subtree);
      }
    }
  });
  var locals3 = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (var i = 0; i < locals3.length; i++) {
    if (!locals3[i].type.valid(node4, locals3[i])) {
      if (options.onRemove) {
        options.onRemove(locals3[i].spec);
      }
      locals3.splice(i--, 1);
    }
  }
  return locals3.length || children.length ? new DecorationSet(locals3, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  var working = spans;
  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) {
      for (var j = i + 1; j < working.length; j++) {
        var next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans) {
              working = spans.slice();
            }
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
    }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) {
    i++;
  }
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  var found2 = [];
  view.someProp("decorations", function(f) {
    var result2 = f(view.state);
    if (result2 && result2 != empty) {
      found2.push(result2);
    }
  });
  if (view.cursorWrapper) {
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  }
  return DecorationGroup.from(found2);
}
function computeDocDeco(view) {
  var attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", function(value) {
    if (typeof value == "function") {
      value = value(view.state);
    }
    if (value) {
      for (var attr in value) {
        if (attr == "class") {
          attrs.class += " " + value[attr];
        } else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") {
          attrs[attr] = String(value[attr]);
        }
      }
    }
  });
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.setAttribute("mark-placeholder", "true");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.head, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", function(value) {
    return value(view.state) === false;
  });
}
function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  var result2 = {};
  view.someProp("nodeViews", function(obj) {
    for (var prop2 in obj) {
      if (!Object.prototype.hasOwnProperty.call(result2, prop2)) {
        result2[prop2] = obj[prop2];
      }
    }
  });
  return result2;
}
function changedNodeViews(a, b) {
  var nA = 0, nB = 0;
  for (var prop2 in a) {
    if (a[prop2] != b[prop2]) {
      return true;
    }
    nA++;
  }
  for (var _ in b) {
    nB++;
  }
  return nA != nB;
}
var result, ie_edge, ie_upto10, ie_11up, ie2, chrome, domIndex, parentNode, reusedRange, textRange, isEquivalentPosition, atomElements, selectionCollapsed, preventScrollSupported, BIDI, maybeRTL, cachedState, cachedDir, cachedResult, NOT_DIRTY, CHILD_DIRTY, CONTENT_DIRTY, NODE_DIRTY, ViewDesc, prototypeAccessors4, nothing, WidgetViewDesc, CompositionViewDesc, MarkViewDesc, NodeViewDesc, TextViewDesc, TrailingHackViewDesc, CustomNodeViewDesc, noDeco, ViewTreeUpdater, brokenSelectBetweenUneditable, wrapMap, _detachedDoc, observeOptions, useCharData, SelectionState, DOMObserver, cssChecked, handlers, editHandlers, selectNodeModifier, MouseDown, timeoutComposition, brokenClipboardAPI, Dragging, dragCopyModifier, prop2, WidgetType, InlineType, NodeType3, Decoration, prototypeAccessors$14, none, noSpec, DecorationSet, empty, DecorationGroup, EditorView, prototypeAccessors$22;
var init_index_es5 = __esm({
  "../../node_modules/.pnpm/prosemirror-view@1.18.11/node_modules/prosemirror-view/dist/index.es.js"() {
    init_index_es4();
    init_index_es2();
    init_index_es3();
    result = {};
    if (typeof navigator != "undefined" && typeof document != "undefined") {
      ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
      ie_upto10 = /MSIE \d/.test(navigator.userAgent);
      ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
      result.mac = /Mac/.test(navigator.platform);
      ie2 = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
      result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
      result.gecko = !ie2 && /gecko\/(\d+)/i.test(navigator.userAgent);
      result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
      chrome = !ie2 && /Chrome\/(\d+)/.exec(navigator.userAgent);
      result.chrome = !!chrome;
      result.chrome_version = chrome && +chrome[1];
      result.safari = !ie2 && /Apple Computer/.test(navigator.vendor);
      result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
      result.android = /Android \d/.test(navigator.userAgent);
      result.webkit = "webkitFontSmoothing" in document.documentElement.style;
      result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
    }
    domIndex = function(node4) {
      for (var index3 = 0; ; index3++) {
        node4 = node4.previousSibling;
        if (!node4) {
          return index3;
        }
      }
    };
    parentNode = function(node4) {
      var parent = node4.assignedSlot || node4.parentNode;
      return parent && parent.nodeType == 11 ? parent.host : parent;
    };
    reusedRange = null;
    textRange = function(node4, from4, to) {
      var range2 = reusedRange || (reusedRange = document.createRange());
      range2.setEnd(node4, to == null ? node4.nodeValue.length : to);
      range2.setStart(node4, from4 || 0);
      return range2;
    };
    isEquivalentPosition = function(node4, off2, targetNode, targetOff) {
      return targetNode && (scanFor(node4, off2, targetNode, targetOff, -1) || scanFor(node4, off2, targetNode, targetOff, 1));
    };
    atomElements = /^(img|br|input|textarea|hr)$/i;
    selectionCollapsed = function(domSel) {
      var collapsed = domSel.isCollapsed;
      if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed) {
        collapsed = false;
      }
      return collapsed;
    };
    preventScrollSupported = null;
    BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    maybeRTL = /[\u0590-\u08ac]/;
    cachedState = null;
    cachedDir = null;
    cachedResult = false;
    NOT_DIRTY = 0;
    CHILD_DIRTY = 1;
    CONTENT_DIRTY = 2;
    NODE_DIRTY = 3;
    ViewDesc = function ViewDesc2(parent, children, dom, contentDOM) {
      this.parent = parent;
      this.children = children;
      this.dom = dom;
      dom.pmViewDesc = this;
      this.contentDOM = contentDOM;
      this.dirty = NOT_DIRTY;
    };
    prototypeAccessors4 = { beforePosition: { configurable: true }, size: { configurable: true }, border: { configurable: true }, posBefore: { configurable: true }, posAtStart: { configurable: true }, posAfter: { configurable: true }, posAtEnd: { configurable: true }, contentLost: { configurable: true }, domAtom: { configurable: true } };
    ViewDesc.prototype.matchesWidget = function matchesWidget() {
      return false;
    };
    ViewDesc.prototype.matchesMark = function matchesMark() {
      return false;
    };
    ViewDesc.prototype.matchesNode = function matchesNode() {
      return false;
    };
    ViewDesc.prototype.matchesHack = function matchesHack(_nodeName) {
      return false;
    };
    prototypeAccessors4.beforePosition.get = function() {
      return false;
    };
    ViewDesc.prototype.parseRule = function parseRule() {
      return null;
    };
    ViewDesc.prototype.stopEvent = function stopEvent() {
      return false;
    };
    prototypeAccessors4.size.get = function() {
      var size = 0;
      for (var i = 0; i < this.children.length; i++) {
        size += this.children[i].size;
      }
      return size;
    };
    prototypeAccessors4.border.get = function() {
      return 0;
    };
    ViewDesc.prototype.destroy = function destroy() {
      this.parent = null;
      if (this.dom.pmViewDesc == this) {
        this.dom.pmViewDesc = null;
      }
      for (var i = 0; i < this.children.length; i++) {
        this.children[i].destroy();
      }
    };
    ViewDesc.prototype.posBeforeChild = function posBeforeChild(child3) {
      for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
        var cur = this.children[i];
        if (cur == child3) {
          return pos;
        }
        pos += cur.size;
      }
    };
    prototypeAccessors4.posBefore.get = function() {
      return this.parent.posBeforeChild(this);
    };
    prototypeAccessors4.posAtStart.get = function() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    };
    prototypeAccessors4.posAfter.get = function() {
      return this.posBefore + this.size;
    };
    prototypeAccessors4.posAtEnd.get = function() {
      return this.posAtStart + this.size - 2 * this.border;
    };
    ViewDesc.prototype.localPosFromDOM = function localPosFromDOM(dom, offset2, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          var domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset2 - 1];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
            domBefore = domBefore.previousSibling;
          }
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          var domAfter, desc$1;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset2];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) {
            domAfter = domAfter.nextSibling;
          }
          return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd;
        }
      }
      var atEnd2;
      if (dom == this.dom && this.contentDOM) {
        atEnd2 = offset2 > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd2 = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset2 == 0) {
          for (var search = dom; ; search = search.parentNode) {
            if (search == this.dom) {
              atEnd2 = false;
              break;
            }
            if (search.parentNode.firstChild != search) {
              break;
            }
          }
        }
        if (atEnd2 == null && offset2 == dom.childNodes.length) {
          for (var search$1 = dom; ; search$1 = search$1.parentNode) {
            if (search$1 == this.dom) {
              atEnd2 = true;
              break;
            }
            if (search$1.parentNode.lastChild != search$1) {
              break;
            }
          }
        }
      }
      return (atEnd2 == null ? bias > 0 : atEnd2) ? this.posAtEnd : this.posAtStart;
    };
    ViewDesc.prototype.nearestDesc = function nearestDesc(dom, onlyNodes) {
      for (var first = true, cur = dom; cur; cur = cur.parentNode) {
        var desc = this.getDesc(cur);
        if (desc && (!onlyNodes || desc.node)) {
          if (first && desc.nodeDOM && !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom)) {
            first = false;
          } else {
            return desc;
          }
        }
      }
    };
    ViewDesc.prototype.getDesc = function getDesc(dom) {
      var desc = dom.pmViewDesc;
      for (var cur = desc; cur; cur = cur.parent) {
        if (cur == this) {
          return desc;
        }
      }
    };
    ViewDesc.prototype.posFromDOM = function posFromDOM(dom, offset2, bias) {
      for (var scan = dom; scan; scan = scan.parentNode) {
        var desc = this.getDesc(scan);
        if (desc) {
          return desc.localPosFromDOM(dom, offset2, bias);
        }
      }
      return -1;
    };
    ViewDesc.prototype.descAt = function descAt(pos) {
      for (var i = 0, offset2 = 0; i < this.children.length; i++) {
        var child3 = this.children[i], end2 = offset2 + child3.size;
        if (offset2 == pos && end2 != offset2) {
          while (!child3.border && child3.children.length) {
            child3 = child3.children[0];
          }
          return child3;
        }
        if (pos < end2) {
          return child3.descAt(pos - offset2 - child3.border);
        }
        offset2 = end2;
      }
    };
    ViewDesc.prototype.domFromPos = function domFromPos(pos, side) {
      if (!this.contentDOM) {
        return { node: this.dom, offset: 0 };
      }
      for (var offset2 = 0, i = 0, first = true; ; i++, first = false) {
        while (i < this.children.length && (this.children[i].beforePosition || this.children[i].dom.parentNode != this.contentDOM)) {
          offset2 += this.children[i++].size;
        }
        var child3 = i == this.children.length ? null : this.children[i];
        if (offset2 == pos && (side == 0 || !child3 || !child3.size || child3.border || side < 0 && first) || child3 && child3.domAtom && pos < offset2 + child3.size) {
          return {
            node: this.contentDOM,
            offset: child3 ? domIndex(child3.dom) : this.contentDOM.childNodes.length
          };
        }
        if (!child3) {
          throw new Error("Invalid position " + pos);
        }
        var end2 = offset2 + child3.size;
        if (!child3.domAtom && (side < 0 && !child3.border ? end2 >= pos : end2 > pos) && (end2 > pos || i + 1 >= this.children.length || !this.children[i + 1].beforePosition)) {
          return child3.domFromPos(pos - offset2 - child3.border, side);
        }
        offset2 = end2;
      }
    };
    ViewDesc.prototype.parseRange = function parseRange(from4, to, base2) {
      if (base2 === void 0) base2 = 0;
      if (this.children.length == 0) {
        return { node: this.contentDOM, from: from4, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
      }
      var fromOffset = -1, toOffset = -1;
      for (var offset2 = base2, i = 0; ; i++) {
        var child3 = this.children[i], end2 = offset2 + child3.size;
        if (fromOffset == -1 && from4 <= end2) {
          var childBase = offset2 + child3.border;
          if (from4 >= childBase && to <= end2 - child3.border && child3.node && child3.contentDOM && this.contentDOM.contains(child3.contentDOM)) {
            return child3.parseRange(from4, to, childBase);
          }
          from4 = offset2;
          for (var j = i; j > 0; j--) {
            var prev = this.children[j - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from4 -= prev.size;
          }
          if (fromOffset == -1) {
            fromOffset = 0;
          }
        }
        if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
          to = end2;
          for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
            var next = this.children[j$1];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }
            to += next.size;
          }
          if (toOffset == -1) {
            toOffset = this.contentDOM.childNodes.length;
          }
          break;
        }
        offset2 = end2;
      }
      return { node: this.contentDOM, from: from4, to, fromOffset, toOffset };
    };
    ViewDesc.prototype.emptyChildAt = function emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length) {
        return false;
      }
      var child3 = this.children[side < 0 ? 0 : this.children.length - 1];
      return child3.size == 0 || child3.emptyChildAt(side);
    };
    ViewDesc.prototype.domAfterPos = function domAfterPos(pos) {
      var ref = this.domFromPos(pos, 0);
      var node4 = ref.node;
      var offset2 = ref.offset;
      if (node4.nodeType != 1 || offset2 == node4.childNodes.length) {
        throw new RangeError("No node after pos " + pos);
      }
      return node4.childNodes[offset2];
    };
    ViewDesc.prototype.setSelection = function setSelection(anchor, head, root, force) {
      var from4 = Math.min(anchor, head), to = Math.max(anchor, head);
      for (var i = 0, offset2 = 0; i < this.children.length; i++) {
        var child3 = this.children[i], end2 = offset2 + child3.size;
        if (from4 > offset2 && to < end2) {
          return child3.setSelection(anchor - offset2 - child3.border, head - offset2 - child3.border, root, force);
        }
        offset2 = end2;
      }
      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      var domSel = root.getSelection();
      var brKludge = false;
      if ((result.gecko || result.safari) && anchor == head) {
        var node4 = anchorDOM.node;
        var offset$1 = anchorDOM.offset;
        if (node4.nodeType == 3) {
          brKludge = offset$1 && node4.nodeValue[offset$1 - 1] == "\n";
          if (brKludge && offset$1 == node4.nodeValue.length) {
            for (var scan = node4, after2 = void 0; scan; scan = scan.parentNode) {
              if (after2 = scan.nextSibling) {
                if (after2.nodeName == "BR") {
                  anchorDOM = headDOM = { node: after2.parentNode, offset: domIndex(after2) + 1 };
                }
                break;
              }
              var desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock) {
                break;
              }
            }
          }
        } else {
          var prev = node4.childNodes[offset$1 - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
        var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
        if (after$1 && after$1.contentEditable == "false") {
          force = true;
        }
      }
      if (!(force || brKludge && result.safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) {
        return;
      }
      var domSelExtended = false;
      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head) {
            domSel.extend(headDOM.node, headDOM.offset);
          }
          domSelExtended = true;
        } catch (err2) {
          if (!(err2 instanceof DOMException)) {
            throw err2;
          }
        }
      }
      if (!domSelExtended) {
        if (anchor > head) {
          var tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        var range2 = document.createRange();
        range2.setEnd(headDOM.node, headDOM.offset);
        range2.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range2);
      }
    };
    ViewDesc.prototype.ignoreMutation = function ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    };
    prototypeAccessors4.contentLost.get = function() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    };
    ViewDesc.prototype.markDirty = function markDirty(from4, to) {
      for (var offset2 = 0, i = 0; i < this.children.length; i++) {
        var child3 = this.children[i], end2 = offset2 + child3.size;
        if (offset2 == end2 ? from4 <= end2 && to >= offset2 : from4 < end2 && to > offset2) {
          var startInside = offset2 + child3.border, endInside = end2 - child3.border;
          if (from4 >= startInside && to <= endInside) {
            this.dirty = from4 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from4 == startInside && to == endInside && (child3.contentLost || child3.dom.parentNode != this.contentDOM)) {
              child3.dirty = NODE_DIRTY;
            } else {
              child3.markDirty(from4 - startInside, to - startInside);
            }
            return;
          } else {
            child3.dirty = child3.dom == child3.contentDOM && child3.dom.parentNode == this.contentDOM ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }
        offset2 = end2;
      }
      this.dirty = CONTENT_DIRTY;
    };
    ViewDesc.prototype.markParentsDirty = function markParentsDirty() {
      var level = 1;
      for (var node4 = this.parent; node4; node4 = node4.parent, level++) {
        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node4.dirty < dirty) {
          node4.dirty = dirty;
        }
      }
    };
    prototypeAccessors4.domAtom.get = function() {
      return false;
    };
    Object.defineProperties(ViewDesc.prototype, prototypeAccessors4);
    nothing = [];
    WidgetViewDesc = (function(ViewDesc3) {
      function WidgetViewDesc2(parent, widget2, view, pos) {
        var self2, dom = widget2.type.toDOM;
        if (typeof dom == "function") {
          dom = dom(view, function() {
            if (!self2) {
              return pos;
            }
            if (self2.parent) {
              return self2.parent.posBeforeChild(self2);
            }
          });
        }
        if (!widget2.type.spec.raw) {
          if (dom.nodeType != 1) {
            var wrap = document.createElement("span");
            wrap.appendChild(dom);
            dom = wrap;
          }
          dom.contentEditable = false;
          dom.classList.add("ProseMirror-widget");
        }
        ViewDesc3.call(this, parent, nothing, dom, null);
        this.widget = widget2;
        self2 = this;
      }
      if (ViewDesc3) WidgetViewDesc2.__proto__ = ViewDesc3;
      WidgetViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      WidgetViewDesc2.prototype.constructor = WidgetViewDesc2;
      var prototypeAccessors$15 = { beforePosition: { configurable: true }, domAtom: { configurable: true } };
      prototypeAccessors$15.beforePosition.get = function() {
        return this.widget.type.side < 0;
      };
      WidgetViewDesc2.prototype.matchesWidget = function matchesWidget2(widget2) {
        return this.dirty == NOT_DIRTY && widget2.type.eq(this.widget.type);
      };
      WidgetViewDesc2.prototype.parseRule = function parseRule2() {
        return { ignore: true };
      };
      WidgetViewDesc2.prototype.stopEvent = function stopEvent2(event) {
        var stop2 = this.widget.spec.stopEvent;
        return stop2 ? stop2(event) : false;
      };
      WidgetViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
        return mutation.type != "selection" || this.widget.spec.ignoreSelection;
      };
      prototypeAccessors$15.domAtom.get = function() {
        return true;
      };
      Object.defineProperties(WidgetViewDesc2.prototype, prototypeAccessors$15);
      return WidgetViewDesc2;
    })(ViewDesc);
    CompositionViewDesc = (function(ViewDesc3) {
      function CompositionViewDesc2(parent, dom, textDOM, text3) {
        ViewDesc3.call(this, parent, nothing, dom, null);
        this.textDOM = textDOM;
        this.text = text3;
      }
      if (ViewDesc3) CompositionViewDesc2.__proto__ = ViewDesc3;
      CompositionViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      CompositionViewDesc2.prototype.constructor = CompositionViewDesc2;
      var prototypeAccessors$23 = { size: { configurable: true } };
      prototypeAccessors$23.size.get = function() {
        return this.text.length;
      };
      CompositionViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset2) {
        if (dom != this.textDOM) {
          return this.posAtStart + (offset2 ? this.size : 0);
        }
        return this.posAtStart + offset2;
      };
      CompositionViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
        return { node: this.textDOM, offset: pos };
      };
      CompositionViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mut) {
        return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
      };
      Object.defineProperties(CompositionViewDesc2.prototype, prototypeAccessors$23);
      return CompositionViewDesc2;
    })(ViewDesc);
    MarkViewDesc = (function(ViewDesc3) {
      function MarkViewDesc2(parent, mark3, dom, contentDOM) {
        ViewDesc3.call(this, parent, [], dom, contentDOM);
        this.mark = mark3;
      }
      if (ViewDesc3) MarkViewDesc2.__proto__ = ViewDesc3;
      MarkViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      MarkViewDesc2.prototype.constructor = MarkViewDesc2;
      MarkViewDesc2.create = function create6(parent, mark3, inline2, view) {
        var custom = view.nodeViews[mark3.type.name];
        var spec = custom && custom(mark3, view, inline2);
        if (!spec || !spec.dom) {
          spec = DOMSerializer.renderSpec(document, mark3.type.spec.toDOM(mark3, inline2));
        }
        return new MarkViewDesc2(parent, mark3, spec.dom, spec.contentDOM || spec.dom);
      };
      MarkViewDesc2.prototype.parseRule = function parseRule2() {
        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
      };
      MarkViewDesc2.prototype.matchesMark = function matchesMark2(mark3) {
        return this.dirty != NODE_DIRTY && this.mark.eq(mark3);
      };
      MarkViewDesc2.prototype.markDirty = function markDirty2(from4, to) {
        ViewDesc3.prototype.markDirty.call(this, from4, to);
        if (this.dirty != NOT_DIRTY) {
          var parent = this.parent;
          while (!parent.node) {
            parent = parent.parent;
          }
          if (parent.dirty < this.dirty) {
            parent.dirty = this.dirty;
          }
          this.dirty = NOT_DIRTY;
        }
      };
      MarkViewDesc2.prototype.slice = function slice4(from4, to, view) {
        var copy6 = MarkViewDesc2.create(this.parent, this.mark, true, view);
        var nodes = this.children, size = this.size;
        if (to < size) {
          nodes = replaceNodes(nodes, to, size, view);
        }
        if (from4 > 0) {
          nodes = replaceNodes(nodes, 0, from4, view);
        }
        for (var i = 0; i < nodes.length; i++) {
          nodes[i].parent = copy6;
        }
        copy6.children = nodes;
        return copy6;
      };
      return MarkViewDesc2;
    })(ViewDesc);
    NodeViewDesc = (function(ViewDesc3) {
      function NodeViewDesc2(parent, node4, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos) {
        ViewDesc3.call(this, parent, node4.isLeaf ? nothing : [], dom, contentDOM);
        this.nodeDOM = nodeDOM2;
        this.node = node4;
        this.outerDeco = outerDeco;
        this.innerDeco = innerDeco;
        if (contentDOM) {
          this.updateChildren(view, pos);
        }
      }
      if (ViewDesc3) NodeViewDesc2.__proto__ = ViewDesc3;
      NodeViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      NodeViewDesc2.prototype.constructor = NodeViewDesc2;
      var prototypeAccessors$32 = { size: { configurable: true }, border: { configurable: true }, domAtom: { configurable: true } };
      NodeViewDesc2.create = function create6(parent, node4, outerDeco, innerDeco, view, pos) {
        var assign2;
        var custom = view.nodeViews[node4.type.name], descObj;
        var spec = custom && custom(node4, view, function() {
          if (!descObj) {
            return pos;
          }
          if (descObj.parent) {
            return descObj.parent.posBeforeChild(descObj);
          }
        }, outerDeco, innerDeco);
        var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
        if (node4.isText) {
          if (!dom) {
            dom = document.createTextNode(node4.text);
          } else if (dom.nodeType != 3) {
            throw new RangeError("Text must be rendered as a DOM text node");
          }
        } else if (!dom) {
          assign2 = DOMSerializer.renderSpec(document, node4.type.spec.toDOM(node4)), dom = assign2.dom, contentDOM = assign2.contentDOM;
        }
        if (!contentDOM && !node4.isText && dom.nodeName != "BR") {
          if (!dom.hasAttribute("contenteditable")) {
            dom.contentEditable = false;
          }
          if (node4.type.spec.draggable) {
            dom.draggable = true;
          }
        }
        var nodeDOM2 = dom;
        dom = applyOuterDeco(dom, outerDeco, node4);
        if (spec) {
          return descObj = new CustomNodeViewDesc(
            parent,
            node4,
            outerDeco,
            innerDeco,
            dom,
            contentDOM,
            nodeDOM2,
            spec,
            view,
            pos + 1
          );
        } else if (node4.isText) {
          return new TextViewDesc(parent, node4, outerDeco, innerDeco, dom, nodeDOM2, view);
        } else {
          return new NodeViewDesc2(parent, node4, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos + 1);
        }
      };
      NodeViewDesc2.prototype.parseRule = function parseRule2() {
        var this$1 = this;
        if (this.node.type.spec.reparseInView) {
          return null;
        }
        var rule = { node: this.node.type.name, attrs: this.node.attrs };
        if (this.node.type.spec.code) {
          rule.preserveWhitespace = "full";
        }
        if (this.contentDOM && !this.contentLost) {
          rule.contentElement = this.contentDOM;
        } else {
          rule.getContent = function() {
            return this$1.contentDOM ? Fragment.empty : this$1.node.content;
          };
        }
        return rule;
      };
      NodeViewDesc2.prototype.matchesNode = function matchesNode2(node4, outerDeco, innerDeco) {
        return this.dirty == NOT_DIRTY && node4.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
      };
      prototypeAccessors$32.size.get = function() {
        return this.node.nodeSize;
      };
      prototypeAccessors$32.border.get = function() {
        return this.node.isLeaf ? 0 : 1;
      };
      NodeViewDesc2.prototype.updateChildren = function updateChildren(view, pos) {
        var this$1 = this;
        var inline2 = this.node.inlineContent, off2 = pos;
        var composition = view.composing && this.localCompositionInfo(view, pos);
        var localComposition = composition && composition.pos > -1 ? composition : null;
        var compositionInChild = composition && composition.pos < 0;
        var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
        iterDeco(this.node, this.innerDeco, function(widget2, i, insideNode) {
          if (widget2.spec.marks) {
            updater.syncToMarks(widget2.spec.marks, inline2, view);
          } else if (widget2.type.side >= 0 && !insideNode) {
            updater.syncToMarks(i == this$1.node.childCount ? Mark.none : this$1.node.child(i).marks, inline2, view);
          }
          updater.placeWidget(widget2, view, off2);
        }, function(child3, outerDeco, innerDeco, i) {
          updater.syncToMarks(child3.marks, inline2, view);
          var compIndex;
          if (updater.findNodeMatch(child3, outerDeco, innerDeco, i)) ;
          else if (compositionInChild && view.state.selection.from > off2 && view.state.selection.to < off2 + child3.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child3, outerDeco, innerDeco, compIndex, view)) ;
          else if (updater.updateNextNode(child3, outerDeco, innerDeco, view, i)) ;
          else {
            updater.addNode(child3, outerDeco, innerDeco, view, off2);
          }
          off2 += child3.nodeSize;
        });
        updater.syncToMarks(nothing, inline2, view);
        if (this.node.isTextblock) {
          updater.addTextblockHacks();
        }
        updater.destroyRest();
        if (updater.changed || this.dirty == CONTENT_DIRTY) {
          if (localComposition) {
            this.protectLocalComposition(view, localComposition);
          }
          renderDescs(this.contentDOM, this.children, view);
          if (result.ios) {
            iosHacks(this.dom);
          }
        }
      };
      NodeViewDesc2.prototype.localCompositionInfo = function localCompositionInfo(view, pos) {
        var ref = view.state.selection;
        var from4 = ref.from;
        var to = ref.to;
        if (!(view.state.selection instanceof TextSelection) || from4 < pos || to > pos + this.node.content.size) {
          return;
        }
        var sel = view.root.getSelection();
        var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
        if (!textNode || !this.dom.contains(textNode.parentNode)) {
          return;
        }
        if (this.node.inlineContent) {
          var text3 = textNode.nodeValue;
          var textPos = findTextInFragment(this.node.content, text3, from4 - pos, to - pos);
          return textPos < 0 ? null : { node: textNode, pos: textPos, text: text3 };
        } else {
          return { node: textNode, pos: -1 };
        }
      };
      NodeViewDesc2.prototype.protectLocalComposition = function protectLocalComposition(view, ref) {
        var node4 = ref.node;
        var pos = ref.pos;
        var text3 = ref.text;
        if (this.getDesc(node4)) {
          return;
        }
        var topNode = node4;
        for (; ; topNode = topNode.parentNode) {
          if (topNode.parentNode == this.contentDOM) {
            break;
          }
          while (topNode.previousSibling) {
            topNode.parentNode.removeChild(topNode.previousSibling);
          }
          while (topNode.nextSibling) {
            topNode.parentNode.removeChild(topNode.nextSibling);
          }
          if (topNode.pmViewDesc) {
            topNode.pmViewDesc = null;
          }
        }
        var desc = new CompositionViewDesc(this, topNode, node4, text3);
        view.compositionNodes.push(desc);
        this.children = replaceNodes(this.children, pos, pos + text3.length, view, desc);
      };
      NodeViewDesc2.prototype.update = function update2(node4, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY || !node4.sameMarkup(this.node)) {
          return false;
        }
        this.updateInner(node4, outerDeco, innerDeco, view);
        return true;
      };
      NodeViewDesc2.prototype.updateInner = function updateInner(node4, outerDeco, innerDeco, view) {
        this.updateOuterDeco(outerDeco);
        this.node = node4;
        this.innerDeco = innerDeco;
        if (this.contentDOM) {
          this.updateChildren(view, this.posAtStart);
        }
        this.dirty = NOT_DIRTY;
      };
      NodeViewDesc2.prototype.updateOuterDeco = function updateOuterDeco(outerDeco) {
        if (sameOuterDeco(outerDeco, this.outerDeco)) {
          return;
        }
        var needsWrap = this.nodeDOM.nodeType != 1;
        var oldDOM = this.dom;
        this.dom = patchOuterDeco(
          this.dom,
          this.nodeDOM,
          computeOuterDeco(this.outerDeco, this.node, needsWrap),
          computeOuterDeco(outerDeco, this.node, needsWrap)
        );
        if (this.dom != oldDOM) {
          oldDOM.pmViewDesc = null;
          this.dom.pmViewDesc = this;
        }
        this.outerDeco = outerDeco;
      };
      NodeViewDesc2.prototype.selectNode = function selectNode2() {
        this.nodeDOM.classList.add("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable) {
          this.dom.draggable = true;
        }
      };
      NodeViewDesc2.prototype.deselectNode = function deselectNode() {
        this.nodeDOM.classList.remove("ProseMirror-selectednode");
        if (this.contentDOM || !this.node.type.spec.draggable) {
          this.dom.removeAttribute("draggable");
        }
      };
      prototypeAccessors$32.domAtom.get = function() {
        return this.node.isAtom;
      };
      Object.defineProperties(NodeViewDesc2.prototype, prototypeAccessors$32);
      return NodeViewDesc2;
    })(ViewDesc);
    TextViewDesc = (function(NodeViewDesc2) {
      function TextViewDesc2(parent, node4, outerDeco, innerDeco, dom, nodeDOM2, view) {
        NodeViewDesc2.call(this, parent, node4, outerDeco, innerDeco, dom, null, nodeDOM2, view);
      }
      if (NodeViewDesc2) TextViewDesc2.__proto__ = NodeViewDesc2;
      TextViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
      TextViewDesc2.prototype.constructor = TextViewDesc2;
      var prototypeAccessors$42 = { domAtom: { configurable: true } };
      TextViewDesc2.prototype.parseRule = function parseRule2() {
        var skip = this.nodeDOM.parentNode;
        while (skip && skip != this.dom && !skip.pmIsDeco) {
          skip = skip.parentNode;
        }
        return { skip: skip || true };
      };
      TextViewDesc2.prototype.update = function update2(node4, outerDeco, _, view) {
        if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node4.sameMarkup(this.node)) {
          return false;
        }
        this.updateOuterDeco(outerDeco);
        if ((this.dirty != NOT_DIRTY || node4.text != this.node.text) && node4.text != this.nodeDOM.nodeValue) {
          this.nodeDOM.nodeValue = node4.text;
          if (view.trackWrites == this.nodeDOM) {
            view.trackWrites = null;
          }
        }
        this.node = node4;
        this.dirty = NOT_DIRTY;
        return true;
      };
      TextViewDesc2.prototype.inParent = function inParent() {
        var parentDOM = this.parent.contentDOM;
        for (var n = this.nodeDOM; n; n = n.parentNode) {
          if (n == parentDOM) {
            return true;
          }
        }
        return false;
      };
      TextViewDesc2.prototype.domFromPos = function domFromPos2(pos) {
        return { node: this.nodeDOM, offset: pos };
      };
      TextViewDesc2.prototype.localPosFromDOM = function localPosFromDOM2(dom, offset2, bias) {
        if (dom == this.nodeDOM) {
          return this.posAtStart + Math.min(offset2, this.node.text.length);
        }
        return NodeViewDesc2.prototype.localPosFromDOM.call(this, dom, offset2, bias);
      };
      TextViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
        return mutation.type != "characterData" && mutation.type != "selection";
      };
      TextViewDesc2.prototype.slice = function slice4(from4, to, view) {
        var node4 = this.node.cut(from4, to), dom = document.createTextNode(node4.text);
        return new TextViewDesc2(this.parent, node4, this.outerDeco, this.innerDeco, dom, dom, view);
      };
      TextViewDesc2.prototype.markDirty = function markDirty2(from4, to) {
        NodeViewDesc2.prototype.markDirty.call(this, from4, to);
        if (this.dom != this.nodeDOM && (from4 == 0 || to == this.nodeDOM.nodeValue.length)) {
          this.dirty = NODE_DIRTY;
        }
      };
      prototypeAccessors$42.domAtom.get = function() {
        return false;
      };
      Object.defineProperties(TextViewDesc2.prototype, prototypeAccessors$42);
      return TextViewDesc2;
    })(NodeViewDesc);
    TrailingHackViewDesc = (function(ViewDesc3) {
      function TrailingHackViewDesc2() {
        ViewDesc3.apply(this, arguments);
      }
      if (ViewDesc3) TrailingHackViewDesc2.__proto__ = ViewDesc3;
      TrailingHackViewDesc2.prototype = Object.create(ViewDesc3 && ViewDesc3.prototype);
      TrailingHackViewDesc2.prototype.constructor = TrailingHackViewDesc2;
      var prototypeAccessors$52 = { domAtom: { configurable: true } };
      TrailingHackViewDesc2.prototype.parseRule = function parseRule2() {
        return { ignore: true };
      };
      TrailingHackViewDesc2.prototype.matchesHack = function matchesHack2(nodeName) {
        return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
      };
      prototypeAccessors$52.domAtom.get = function() {
        return true;
      };
      Object.defineProperties(TrailingHackViewDesc2.prototype, prototypeAccessors$52);
      return TrailingHackViewDesc2;
    })(ViewDesc);
    CustomNodeViewDesc = (function(NodeViewDesc2) {
      function CustomNodeViewDesc2(parent, node4, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, spec, view, pos) {
        NodeViewDesc2.call(this, parent, node4, outerDeco, innerDeco, dom, contentDOM, nodeDOM2, view, pos);
        this.spec = spec;
      }
      if (NodeViewDesc2) CustomNodeViewDesc2.__proto__ = NodeViewDesc2;
      CustomNodeViewDesc2.prototype = Object.create(NodeViewDesc2 && NodeViewDesc2.prototype);
      CustomNodeViewDesc2.prototype.constructor = CustomNodeViewDesc2;
      CustomNodeViewDesc2.prototype.update = function update2(node4, outerDeco, innerDeco, view) {
        if (this.dirty == NODE_DIRTY) {
          return false;
        }
        if (this.spec.update) {
          var result2 = this.spec.update(node4, outerDeco, innerDeco);
          if (result2) {
            this.updateInner(node4, outerDeco, innerDeco, view);
          }
          return result2;
        } else if (!this.contentDOM && !node4.isLeaf) {
          return false;
        } else {
          return NodeViewDesc2.prototype.update.call(this, node4, outerDeco, innerDeco, view);
        }
      };
      CustomNodeViewDesc2.prototype.selectNode = function selectNode2() {
        this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc2.prototype.selectNode.call(this);
      };
      CustomNodeViewDesc2.prototype.deselectNode = function deselectNode() {
        this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc2.prototype.deselectNode.call(this);
      };
      CustomNodeViewDesc2.prototype.setSelection = function setSelection3(anchor, head, root, force) {
        this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : NodeViewDesc2.prototype.setSelection.call(this, anchor, head, root, force);
      };
      CustomNodeViewDesc2.prototype.destroy = function destroy4() {
        if (this.spec.destroy) {
          this.spec.destroy();
        }
        NodeViewDesc2.prototype.destroy.call(this);
      };
      CustomNodeViewDesc2.prototype.stopEvent = function stopEvent2(event) {
        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
      };
      CustomNodeViewDesc2.prototype.ignoreMutation = function ignoreMutation2(mutation) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc2.prototype.ignoreMutation.call(this, mutation);
      };
      return CustomNodeViewDesc2;
    })(NodeViewDesc);
    OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
    noDeco = [new OuterDecoLevel()];
    ViewTreeUpdater = function ViewTreeUpdater2(top2, lockedNode) {
      this.top = top2;
      this.lock = lockedNode;
      this.index = 0;
      this.stack = [];
      this.changed = false;
      this.preMatch = preMatch(top2.node.content, top2.children);
    };
    ViewTreeUpdater.prototype.destroyBetween = function destroyBetween(start3, end2) {
      if (start3 == end2) {
        return;
      }
      for (var i = start3; i < end2; i++) {
        this.top.children[i].destroy();
      }
      this.top.children.splice(start3, end2 - start3);
      this.changed = true;
    };
    ViewTreeUpdater.prototype.destroyRest = function destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    };
    ViewTreeUpdater.prototype.syncToMarks = function syncToMarks(marks2, inline2, view) {
      var keep = 0, depth = this.stack.length >> 1;
      var maxKeep = Math.min(depth, marks2.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks2[keep]) && marks2[keep].type.spec.spanning !== false) {
        keep++;
      }
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks2.length) {
        this.stack.push(this.top, this.index + 1);
        var found2 = -1;
        for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          if (this.top.children[i].matchesMark(marks2[depth])) {
            found2 = i;
            break;
          }
        }
        if (found2 > -1) {
          if (found2 > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found2);
          }
          this.top = this.top.children[this.index];
        } else {
          var markDesc = MarkViewDesc.create(this.top, marks2[depth], inline2, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    };
    ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch(node4, outerDeco, innerDeco, index3) {
      var children = this.top.children, found2 = -1;
      if (index3 >= this.preMatch.index) {
        for (var i = this.index; i < children.length; i++) {
          if (children[i].matchesNode(node4, outerDeco, innerDeco)) {
            found2 = i;
            break;
          }
        }
      } else {
        for (var i$1 = this.index, e = Math.min(children.length, i$1 + 1); i$1 < e; i$1++) {
          var child3 = children[i$1];
          if (child3.matchesNode(node4, outerDeco, innerDeco) && !this.preMatch.matched.has(child3)) {
            found2 = i$1;
            break;
          }
        }
      }
      if (found2 < 0) {
        return false;
      }
      this.destroyBetween(this.index, found2);
      this.index++;
      return true;
    };
    ViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt(node4, outerDeco, innerDeco, index3, view) {
      var child3 = this.top.children[index3];
      if (!child3.update(node4, outerDeco, innerDeco, view)) {
        return false;
      }
      this.destroyBetween(this.index, index3);
      this.index = index3 + 1;
      return true;
    };
    ViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild(domNode) {
      for (; ; ) {
        var parent = domNode.parentNode;
        if (!parent) {
          return -1;
        }
        if (parent == this.top.contentDOM) {
          var desc = domNode.pmViewDesc;
          if (desc) {
            for (var i = this.index; i < this.top.children.length; i++) {
              if (this.top.children[i] == desc) {
                return i;
              }
            }
          }
          return -1;
        }
        domNode = parent;
      }
    };
    ViewTreeUpdater.prototype.updateNextNode = function updateNextNode(node4, outerDeco, innerDeco, view, index3) {
      for (var i = this.index; i < this.top.children.length; i++) {
        var next = this.top.children[i];
        if (next instanceof NodeViewDesc) {
          var preMatch2 = this.preMatch.matched.get(next);
          if (preMatch2 != null && preMatch2 != index3) {
            return false;
          }
          var nextDOM = next.dom;
          var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) && !(node4.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node4.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node4, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM) {
              this.changed = true;
            }
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    };
    ViewTreeUpdater.prototype.addNode = function addNode2(node4, outerDeco, innerDeco, view, pos) {
      this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node4, outerDeco, innerDeco, view, pos));
      this.changed = true;
    };
    ViewTreeUpdater.prototype.placeWidget = function placeWidget(widget2, view, pos) {
      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget2) && (widget2 == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        var desc = new WidgetViewDesc(this.top, widget2, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    };
    ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks() {
      var lastChild = this.top.children[this.index - 1];
      while (lastChild instanceof MarkViewDesc) {
        lastChild = lastChild.children[lastChild.children.length - 1];
      }
      if (!lastChild || // Empty textblock
      !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text)) {
        if (result.safari && lastChild && lastChild.dom.contentEditable == "false") {
          this.addHackNode("IMG");
        }
        this.addHackNode("BR");
      }
    };
    ViewTreeUpdater.prototype.addHackNode = function addHackNode(nodeName) {
      if (this.index < this.top.children.length && this.top.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        var dom = document.createElement(nodeName);
        this.top.children.splice(this.index++, 0, new TrailingHackViewDesc(this.top, nothing, dom, null));
        this.changed = true;
      }
    };
    brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;
    wrapMap = {
      thead: ["table"],
      tbody: ["table"],
      tfoot: ["table"],
      caption: ["table"],
      colgroup: ["table"],
      col: ["table", "colgroup"],
      tr: ["table", "tbody"],
      td: ["table", "tbody", "tr"],
      th: ["table", "tbody", "tr"]
    };
    _detachedDoc = null;
    observeOptions = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      attributes: true,
      attributeOldValue: true,
      subtree: true
    };
    useCharData = result.ie && result.ie_version <= 11;
    SelectionState = function SelectionState2() {
      this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
    };
    SelectionState.prototype.set = function set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    };
    SelectionState.prototype.eq = function eq5(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    };
    DOMObserver = function DOMObserver2(view, handleDOMChange) {
      var this$1 = this;
      this.view = view;
      this.handleDOMChange = handleDOMChange;
      this.queue = [];
      this.flushingSoon = -1;
      this.observer = window.MutationObserver && new window.MutationObserver(function(mutations) {
        for (var i = 0; i < mutations.length; i++) {
          this$1.queue.push(mutations[i]);
        }
        if (result.ie && result.ie_version <= 11 && mutations.some(
          function(m) {
            return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
          }
        )) {
          this$1.flushSoon();
        } else {
          this$1.flush();
        }
      });
      this.currentSelection = new SelectionState();
      if (useCharData) {
        this.onCharData = function(e) {
          this$1.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
          this$1.flushSoon();
        };
      }
      this.onSelectionChange = this.onSelectionChange.bind(this);
      this.suppressingSelectionUpdates = false;
    };
    DOMObserver.prototype.flushSoon = function flushSoon() {
      var this$1 = this;
      if (this.flushingSoon < 0) {
        this.flushingSoon = window.setTimeout(function() {
          this$1.flushingSoon = -1;
          this$1.flush();
        }, 20);
      }
    };
    DOMObserver.prototype.forceFlush = function forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    };
    DOMObserver.prototype.start = function start2() {
      if (this.observer) {
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (useCharData) {
        this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      }
      this.connectSelection();
    };
    DOMObserver.prototype.stop = function stop() {
      var this$1 = this;
      if (this.observer) {
        var take = this.observer.takeRecords();
        if (take.length) {
          for (var i = 0; i < take.length; i++) {
            this.queue.push(take[i]);
          }
          window.setTimeout(function() {
            return this$1.flush();
          }, 20);
        }
        this.observer.disconnect();
      }
      if (useCharData) {
        this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      }
      this.disconnectSelection();
    };
    DOMObserver.prototype.connectSelection = function connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    };
    DOMObserver.prototype.disconnectSelection = function disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    };
    DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates() {
      var this$1 = this;
      this.suppressingSelectionUpdates = true;
      setTimeout(function() {
        return this$1.suppressingSelectionUpdates = false;
      }, 50);
    };
    DOMObserver.prototype.onSelectionChange = function onSelectionChange() {
      if (!hasFocusAndSelection(this.view)) {
        return;
      }
      if (this.suppressingSelectionUpdates) {
        return selectionToDOM(this.view);
      }
      if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
        var sel = this.view.root.getSelection();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) {
          return this.flushSoon();
        }
      }
      this.flush();
    };
    DOMObserver.prototype.setCurSelection = function setCurSelection() {
      this.currentSelection.set(this.view.root.getSelection());
    };
    DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange(sel) {
      if (sel.rangeCount == 0) {
        return true;
      }
      var container = sel.getRangeAt(0).commonAncestorContainer;
      var desc = this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({ type: "selection", target: container.nodeType == 3 ? container.parentNode : container })) {
        this.setCurSelection();
        return true;
      }
    };
    DOMObserver.prototype.flush = function flush() {
      if (!this.view.docView || this.flushingSoon > -1) {
        return;
      }
      var mutations = this.observer ? this.observer.takeRecords() : [];
      if (this.queue.length) {
        mutations = this.queue.concat(mutations);
        this.queue.length = 0;
      }
      var sel = this.view.root.getSelection();
      var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasSelection(this.view) && !this.ignoreSelectionChange(sel);
      var from4 = -1, to = -1, typeOver = false, added = [];
      if (this.view.editable) {
        for (var i = 0; i < mutations.length; i++) {
          var result$1 = this.registerMutation(mutations[i], added);
          if (result$1) {
            from4 = from4 < 0 ? result$1.from : Math.min(result$1.from, from4);
            to = to < 0 ? result$1.to : Math.max(result$1.to, to);
            if (result$1.typeOver) {
              typeOver = true;
            }
          }
        }
      }
      if (result.gecko && added.length > 1) {
        var brs = added.filter(function(n) {
          return n.nodeName == "BR";
        });
        if (brs.length == 2) {
          var a = brs[0];
          var b = brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode) {
            b.remove();
          } else {
            a.remove();
          }
        }
      }
      if (from4 > -1 || newSel) {
        if (from4 > -1) {
          this.view.docView.markDirty(from4, to);
          checkCSS(this.view);
        }
        this.handleDOMChange(from4, to, typeOver, added);
        if (this.view.docView.dirty) {
          this.view.updateState(this.view.state);
        } else if (!this.currentSelection.eq(sel)) {
          selectionToDOM(this.view);
        }
        this.currentSelection.set(sel);
      }
    };
    DOMObserver.prototype.registerMutation = function registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1) {
        return null;
      }
      var desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
      mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) {
        return null;
      }
      if (!desc || desc.ignoreMutation(mut)) {
        return null;
      }
      if (mut.type == "childList") {
        for (var i = 0; i < mut.addedNodes.length; i++) {
          added.push(mut.addedNodes[i]);
        }
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) {
          return { from: desc.posBefore, to: desc.posAfter };
        }
        var prev = mut.previousSibling, next = mut.nextSibling;
        if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
          for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
            var ref = mut.addedNodes[i$1];
            var previousSibling = ref.previousSibling;
            var nextSibling = ref.nextSibling;
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) {
              prev = previousSibling;
            }
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) {
              next = nextSibling;
            }
          }
        }
        var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        var from4 = desc.localPosFromDOM(mut.target, fromOffset, -1);
        var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        var to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return { from: from4, to };
      } else if (mut.type == "attributes") {
        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
      } else {
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    };
    cssChecked = false;
    handlers = {};
    editHandlers = {};
    editHandlers.keydown = function(view, event) {
      view.shiftKey = event.keyCode == 16 || event.shiftKey;
      if (inOrNearComposition(view, event)) {
        return;
      }
      if (event.keyCode != 229) {
        view.domObserver.forceFlush();
      }
      view.lastKeyCode = event.keyCode;
      view.lastKeyCodeTime = Date.now();
      if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
        var now = Date.now();
        view.lastIOSEnter = now;
        view.lastIOSEnterFallbackTimeout = setTimeout(function() {
          if (view.lastIOSEnter == now) {
            view.someProp("handleKeyDown", function(f) {
              return f(view, keyEvent(13, "Enter"));
            });
            view.lastIOSEnter = 0;
          }
        }, 200);
      } else if (view.someProp("handleKeyDown", function(f) {
        return f(view, event);
      }) || captureKeyDown(view, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "key");
      }
    };
    editHandlers.keyup = function(view, e) {
      if (e.keyCode == 16) {
        view.shiftKey = false;
      }
    };
    editHandlers.keypress = function(view, event) {
      if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || result.mac && event.metaKey) {
        return;
      }
      if (view.someProp("handleKeyPress", function(f) {
        return f(view, event);
      })) {
        event.preventDefault();
        return;
      }
      var sel = view.state.selection;
      if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
        var text3 = String.fromCharCode(event.charCode);
        if (!view.someProp("handleTextInput", function(f) {
          return f(view, sel.$from.pos, sel.$to.pos, text3);
        })) {
          view.dispatch(view.state.tr.insertText(text3).scrollIntoView());
        }
        event.preventDefault();
      }
    };
    selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";
    handlers.mousedown = function(view, event) {
      view.shiftKey = event.shiftKey;
      var flushed = forceDOMFlush(view);
      var now = Date.now(), type = "singleClick";
      if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
        if (view.lastClick.type == "singleClick") {
          type = "doubleClick";
        } else if (view.lastClick.type == "doubleClick") {
          type = "tripleClick";
        }
      }
      view.lastClick = { time: now, x: event.clientX, y: event.clientY, type };
      var pos = view.posAtCoords(eventCoords(event));
      if (!pos) {
        return;
      }
      if (type == "singleClick") {
        if (view.mouseDown) {
          view.mouseDown.done();
        }
        view.mouseDown = new MouseDown(view, pos, event, flushed);
      } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
        event.preventDefault();
      } else {
        setSelectionOrigin(view, "pointer");
      }
    };
    MouseDown = function MouseDown2(view, pos, event, flushed) {
      var this$1 = this;
      this.view = view;
      this.startDoc = view.state.doc;
      this.pos = pos;
      this.event = event;
      this.flushed = flushed;
      this.selectNode = event[selectNodeModifier];
      this.allowDefault = event.shiftKey;
      var targetNode, targetPos;
      if (pos.inside > -1) {
        targetNode = view.state.doc.nodeAt(pos.inside);
        targetPos = pos.inside;
      } else {
        var $pos = view.state.doc.resolve(pos.pos);
        targetNode = $pos.parent;
        targetPos = $pos.depth ? $pos.before() : 0;
      }
      this.mightDrag = null;
      var target2 = flushed ? null : event.target;
      var targetDesc = target2 ? view.docView.nearestDesc(target2, true) : null;
      this.target = targetDesc ? targetDesc.dom : null;
      var ref = view.state;
      var selection = ref.selection;
      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos) {
        this.mightDrag = {
          node: targetNode,
          pos: targetPos,
          addAttr: this.target && !this.target.draggable,
          setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")
        };
      }
      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) {
          this.target.draggable = true;
        }
        if (this.mightDrag.setUneditable) {
          setTimeout(function() {
            if (this$1.view.mouseDown == this$1) {
              this$1.target.setAttribute("contentEditable", "false");
            }
          }, 20);
        }
        this.view.domObserver.start();
      }
      view.root.addEventListener("mouseup", this.up = this.up.bind(this));
      view.root.addEventListener("mousemove", this.move = this.move.bind(this));
      setSelectionOrigin(view, "pointer");
    };
    MouseDown.prototype.done = function done() {
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) {
          this.target.removeAttribute("draggable");
        }
        if (this.mightDrag.setUneditable) {
          this.target.removeAttribute("contentEditable");
        }
        this.view.domObserver.start();
      }
      this.view.mouseDown = null;
    };
    MouseDown.prototype.up = function up(event) {
      this.done();
      if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target)) {
        return;
      }
      var pos = this.pos;
      if (this.view.state.doc != this.startDoc) {
        pos = this.view.posAtCoords(eventCoords(event));
      }
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
      result.safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
      // cursor, but still report that the node is selected
      // when asked through getSelection. You'll then get a
      // situation where clicking at the point where that
      // (hidden) cursor is doesn't change the selection, and
      // thus doesn't get a reaction from ProseMirror. This
      // works around that.
      result.chrome && !(this.view.state.selection instanceof TextSelection) && Math.min(
        Math.abs(pos.pos - this.view.state.selection.from),
        Math.abs(pos.pos - this.view.state.selection.to)
      ) <= 2)) {
        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    };
    MouseDown.prototype.move = function move(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) {
        this.allowDefault = true;
      }
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0) {
        this.done();
      }
    };
    handlers.touchdown = function(view) {
      forceDOMFlush(view);
      setSelectionOrigin(view, "pointer");
    };
    handlers.contextmenu = function(view) {
      return forceDOMFlush(view);
    };
    timeoutComposition = result.android ? 5e3 : -1;
    editHandlers.compositionstart = editHandlers.compositionupdate = function(view) {
      if (!view.composing) {
        view.domObserver.flush();
        var state = view.state;
        var $pos = state.selection.$from;
        if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function(m) {
          return m.type.spec.inclusive === false;
        }))) {
          view.markCursor = view.state.storedMarks || $pos.marks();
          endComposition(view, true);
          view.markCursor = null;
        } else {
          endComposition(view);
          if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
            var sel = view.root.getSelection();
            for (var node4 = sel.focusNode, offset2 = sel.focusOffset; node4 && node4.nodeType == 1 && offset2 != 0; ) {
              var before2 = offset2 < 0 ? node4.lastChild : node4.childNodes[offset2 - 1];
              if (!before2) {
                break;
              }
              if (before2.nodeType == 3) {
                sel.collapse(before2, before2.nodeValue.length);
                break;
              } else {
                node4 = before2;
                offset2 = -1;
              }
            }
          }
        }
        view.composing = true;
      }
      scheduleComposeEnd(view, timeoutComposition);
    };
    editHandlers.compositionend = function(view, event) {
      if (view.composing) {
        view.composing = false;
        view.compositionEndedAt = event.timeStamp;
        scheduleComposeEnd(view, 20);
      }
    };
    brokenClipboardAPI = result.ie && result.ie_version < 15 || result.ios && result.webkit_version < 604;
    handlers.copy = editHandlers.cut = function(view, e) {
      var sel = view.state.selection, cut3 = e.type == "cut";
      if (sel.empty) {
        return;
      }
      var data = brokenClipboardAPI ? null : e.clipboardData;
      var slice4 = sel.content();
      var ref = serializeForClipboard(view, slice4);
      var dom = ref.dom;
      var text3 = ref.text;
      if (data) {
        e.preventDefault();
        data.clearData();
        data.setData("text/html", dom.innerHTML);
        data.setData("text/plain", text3);
      } else {
        captureCopy(view, dom);
      }
      if (cut3) {
        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
      }
    };
    editHandlers.paste = function(view, e) {
      var data = brokenClipboardAPI ? null : e.clipboardData;
      if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e)) {
        e.preventDefault();
      } else {
        capturePaste(view, e);
      }
    };
    Dragging = function Dragging2(slice4, move2) {
      this.slice = slice4;
      this.move = move2;
    };
    dragCopyModifier = result.mac ? "altKey" : "ctrlKey";
    handlers.dragstart = function(view, e) {
      var mouseDown = view.mouseDown;
      if (mouseDown) {
        mouseDown.done();
      }
      if (!e.dataTransfer) {
        return;
      }
      var sel = view.state.selection;
      var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
      if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
      else if (mouseDown && mouseDown.mightDrag) {
        view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
      } else if (e.target && e.target.nodeType == 1) {
        var desc = view.docView.nearestDesc(e.target, true);
        if (desc && desc.node.type.spec.draggable && desc != view.docView) {
          view.dispatch(view.state.tr.setSelection(NodeSelection.create(view.state.doc, desc.posBefore)));
        }
      }
      var slice4 = view.state.selection.content();
      var ref = serializeForClipboard(view, slice4);
      var dom = ref.dom;
      var text3 = ref.text;
      e.dataTransfer.clearData();
      e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
      e.dataTransfer.effectAllowed = "copyMove";
      if (!brokenClipboardAPI) {
        e.dataTransfer.setData("text/plain", text3);
      }
      view.dragging = new Dragging(slice4, !e[dragCopyModifier]);
    };
    handlers.dragend = function(view) {
      var dragging = view.dragging;
      window.setTimeout(function() {
        if (view.dragging == dragging) {
          view.dragging = null;
        }
      }, 50);
    };
    editHandlers.dragover = editHandlers.dragenter = function(_, e) {
      return e.preventDefault();
    };
    editHandlers.drop = function(view, e) {
      var dragging = view.dragging;
      view.dragging = null;
      if (!e.dataTransfer) {
        return;
      }
      var eventPos = view.posAtCoords(eventCoords(e));
      if (!eventPos) {
        return;
      }
      var $mouse = view.state.doc.resolve(eventPos.pos);
      if (!$mouse) {
        return;
      }
      var slice4 = dragging && dragging.slice;
      if (slice4) {
        view.someProp("transformPasted", function(f) {
          slice4 = f(slice4);
        });
      } else {
        slice4 = parseFromClipboard(
          view,
          e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"),
          brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"),
          false,
          $mouse
        );
      }
      var move2 = dragging && !e[dragCopyModifier];
      if (view.someProp("handleDrop", function(f) {
        return f(view, e, slice4 || Slice.empty, move2);
      })) {
        e.preventDefault();
        return;
      }
      if (!slice4) {
        return;
      }
      e.preventDefault();
      var insertPos = slice4 ? dropPoint(view.state.doc, $mouse.pos, slice4) : $mouse.pos;
      if (insertPos == null) {
        insertPos = $mouse.pos;
      }
      var tr = view.state.tr;
      if (move2) {
        tr.deleteSelection();
      }
      var pos = tr.mapping.map(insertPos);
      var isNode = slice4.openStart == 0 && slice4.openEnd == 0 && slice4.content.childCount == 1;
      var beforeInsert = tr.doc;
      if (isNode) {
        tr.replaceRangeWith(pos, pos, slice4.content.firstChild);
      } else {
        tr.replaceRange(pos, pos, slice4);
      }
      if (tr.doc.eq(beforeInsert)) {
        return;
      }
      var $pos = tr.doc.resolve(pos);
      if (isNode && NodeSelection.isSelectable(slice4.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice4.content.firstChild)) {
        tr.setSelection(new NodeSelection($pos));
      } else {
        var end2 = tr.mapping.map(insertPos);
        tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function(_from, _to, _newFrom, newTo) {
          return end2 = newTo;
        });
        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end2)));
      }
      view.focus();
      view.dispatch(tr.setMeta("uiEvent", "drop"));
    };
    handlers.focus = function(view) {
      if (!view.focused) {
        view.domObserver.stop();
        view.dom.classList.add("ProseMirror-focused");
        view.domObserver.start();
        view.focused = true;
        setTimeout(function() {
          if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection())) {
            selectionToDOM(view);
          }
        }, 20);
      }
    };
    handlers.blur = function(view) {
      if (view.focused) {
        view.domObserver.stop();
        view.dom.classList.remove("ProseMirror-focused");
        view.domObserver.start();
        view.domObserver.currentSelection.set({});
        view.focused = false;
      }
    };
    handlers.beforeinput = function(view, event) {
      if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
        var domChangeCount = view.domChangeCount;
        setTimeout(function() {
          if (view.domChangeCount != domChangeCount) {
            return;
          }
          view.dom.blur();
          view.focus();
          if (view.someProp("handleKeyDown", function(f) {
            return f(view, keyEvent(8, "Backspace"));
          })) {
            return;
          }
          var ref = view.state.selection;
          var $cursor = ref.$cursor;
          if ($cursor && $cursor.pos > 0) {
            view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
          }
        }, 50);
      }
    };
    for (prop2 in editHandlers) {
      handlers[prop2] = editHandlers[prop2];
    }
    WidgetType = function WidgetType2(toDOM, spec) {
      this.spec = spec || noSpec;
      this.side = this.spec.side || 0;
      this.toDOM = toDOM;
    };
    WidgetType.prototype.map = function map7(mapping, span, offset2, oldOffset) {
      var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
      var pos = ref.pos;
      var deleted = ref.deleted;
      return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
    };
    WidgetType.prototype.valid = function valid() {
      return true;
    };
    WidgetType.prototype.eq = function eq6(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    };
    InlineType = function InlineType2(attrs, spec) {
      this.spec = spec || noSpec;
      this.attrs = attrs;
    };
    InlineType.prototype.map = function map8(mapping, span, offset2, oldOffset) {
      var from4 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
      return from4 >= to ? null : new Decoration(from4, to, this);
    };
    InlineType.prototype.valid = function valid2(_, span) {
      return span.from < span.to;
    };
    InlineType.prototype.eq = function eq7(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    };
    InlineType.is = function is(span) {
      return span.type instanceof InlineType;
    };
    NodeType3 = function NodeType4(attrs, spec) {
      this.spec = spec || noSpec;
      this.attrs = attrs;
    };
    NodeType3.prototype.map = function map9(mapping, span, offset2, oldOffset) {
      var from4 = mapping.mapResult(span.from + oldOffset, 1);
      if (from4.deleted) {
        return null;
      }
      var to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from4.pos) {
        return null;
      }
      return new Decoration(from4.pos - offset2, to.pos - offset2, this);
    };
    NodeType3.prototype.valid = function valid3(node4, span) {
      var ref = node4.content.findIndex(span.from);
      var index3 = ref.index;
      var offset2 = ref.offset;
      return offset2 == span.from && offset2 + node4.child(index3).nodeSize == span.to;
    };
    NodeType3.prototype.eq = function eq8(other) {
      return this == other || other instanceof NodeType3 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    };
    Decoration = function Decoration2(from4, to, type) {
      this.from = from4;
      this.to = to;
      this.type = type;
    };
    prototypeAccessors$14 = { spec: { configurable: true }, inline: { configurable: true } };
    Decoration.prototype.copy = function copy4(from4, to) {
      return new Decoration(from4, to, this.type);
    };
    Decoration.prototype.eq = function eq9(other, offset2) {
      if (offset2 === void 0) offset2 = 0;
      return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
    };
    Decoration.prototype.map = function map10(mapping, offset2, oldOffset) {
      return this.type.map(mapping, this, offset2, oldOffset);
    };
    Decoration.widget = function widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    };
    Decoration.inline = function inline(from4, to, attrs, spec) {
      return new Decoration(from4, to, new InlineType(attrs, spec));
    };
    Decoration.node = function node3(from4, to, attrs, spec) {
      return new Decoration(from4, to, new NodeType3(attrs, spec));
    };
    prototypeAccessors$14.spec.get = function() {
      return this.type.spec;
    };
    prototypeAccessors$14.inline.get = function() {
      return this.type instanceof InlineType;
    };
    Object.defineProperties(Decoration.prototype, prototypeAccessors$14);
    none = [];
    noSpec = {};
    DecorationSet = function DecorationSet2(local, children) {
      this.local = local && local.length ? local : none;
      this.children = children && children.length ? children : none;
    };
    DecorationSet.create = function create4(doc2, decorations) {
      return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
    };
    DecorationSet.prototype.find = function find(start3, end2, predicate) {
      var result2 = [];
      this.findInner(start3 == null ? 0 : start3, end2 == null ? 1e9 : end2, result2, 0, predicate);
      return result2;
    };
    DecorationSet.prototype.findInner = function findInner(start3, end2, result2, offset2, predicate) {
      for (var i = 0; i < this.local.length; i++) {
        var span = this.local[i];
        if (span.from <= end2 && span.to >= start3 && (!predicate || predicate(span.spec))) {
          result2.push(span.copy(span.from + offset2, span.to + offset2));
        }
      }
      for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
        if (this.children[i$1] < end2 && this.children[i$1 + 1] > start3) {
          var childOff = this.children[i$1] + 1;
          this.children[i$1 + 2].findInner(start3 - childOff, end2 - childOff, result2, offset2 + childOff, predicate);
        }
      }
    };
    DecorationSet.prototype.map = function map11(mapping, doc2, options) {
      if (this == empty || mapping.maps.length == 0) {
        return this;
      }
      return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
    };
    DecorationSet.prototype.mapInner = function mapInner(mapping, node4, offset2, oldOffset, options) {
      var newLocal;
      for (var i = 0; i < this.local.length; i++) {
        var mapped = this.local[i].map(mapping, offset2, oldOffset);
        if (mapped && mapped.type.valid(node4, mapped)) {
          (newLocal || (newLocal = [])).push(mapped);
        } else if (options.onRemove) {
          options.onRemove(this.local[i].spec);
        }
      }
      if (this.children.length) {
        return mapChildren(this.children, newLocal, mapping, node4, offset2, oldOffset, options);
      } else {
        return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty;
      }
    };
    DecorationSet.prototype.add = function add(doc2, decorations) {
      if (!decorations.length) {
        return this;
      }
      if (this == empty) {
        return DecorationSet.create(doc2, decorations);
      }
      return this.addInner(doc2, decorations, 0);
    };
    DecorationSet.prototype.addInner = function addInner(doc2, decorations, offset2) {
      var this$1 = this;
      var children, childIndex = 0;
      doc2.forEach(function(childNode, childOffset) {
        var baseOffset = childOffset + offset2, found2;
        if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset))) {
          return;
        }
        if (!children) {
          children = this$1.children.slice();
        }
        while (childIndex < children.length && children[childIndex] < childOffset) {
          childIndex += 3;
        }
        if (children[childIndex] == childOffset) {
          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
        } else {
          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
        }
        childIndex += 3;
      });
      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
      for (var i = 0; i < local.length; i++) {
        if (!local[i].type.valid(doc2, local[i])) {
          local.splice(i--, 1);
        }
      }
      return new DecorationSet(
        local.length ? this.local.concat(local).sort(byPos) : this.local,
        children || this.children
      );
    };
    DecorationSet.prototype.remove = function remove(decorations) {
      if (decorations.length == 0 || this == empty) {
        return this;
      }
      return this.removeInner(decorations, 0);
    };
    DecorationSet.prototype.removeInner = function removeInner(decorations, offset2) {
      var children = this.children, local = this.local;
      for (var i = 0; i < children.length; i += 3) {
        var found2 = void 0, from4 = children[i] + offset2, to = children[i + 1] + offset2;
        for (var j = 0, span = void 0; j < decorations.length; j++) {
          if (span = decorations[j]) {
            if (span.from > from4 && span.to < to) {
              decorations[j] = null;
              (found2 || (found2 = [])).push(span);
            }
          }
        }
        if (!found2) {
          continue;
        }
        if (children == this.children) {
          children = this.children.slice();
        }
        var removed = children[i + 2].removeInner(found2, from4 + 1);
        if (removed != empty) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }
      if (local.length) {
        for (var i$1 = 0, span$1 = void 0; i$1 < decorations.length; i$1++) {
          if (span$1 = decorations[i$1]) {
            for (var j$1 = 0; j$1 < local.length; j$1++) {
              if (local[j$1].eq(span$1, offset2)) {
                if (local == this.local) {
                  local = this.local.slice();
                }
                local.splice(j$1--, 1);
              }
            }
          }
        }
      }
      if (children == this.children && local == this.local) {
        return this;
      }
      return local.length || children.length ? new DecorationSet(local, children) : empty;
    };
    DecorationSet.prototype.forChild = function forChild(offset2, node4) {
      if (this == empty) {
        return this;
      }
      if (node4.isLeaf) {
        return DecorationSet.empty;
      }
      var child3, local;
      for (var i = 0; i < this.children.length; i += 3) {
        if (this.children[i] >= offset2) {
          if (this.children[i] == offset2) {
            child3 = this.children[i + 2];
          }
          break;
        }
      }
      var start3 = offset2 + 1, end2 = start3 + node4.content.size;
      for (var i$1 = 0; i$1 < this.local.length; i$1++) {
        var dec = this.local[i$1];
        if (dec.from < end2 && dec.to > start3 && dec.type instanceof InlineType) {
          var from4 = Math.max(start3, dec.from) - start3, to = Math.min(end2, dec.to) - start3;
          if (from4 < to) {
            (local || (local = [])).push(dec.copy(from4, to));
          }
        }
      }
      if (local) {
        var localSet = new DecorationSet(local.sort(byPos));
        return child3 ? new DecorationGroup([localSet, child3]) : localSet;
      }
      return child3 || empty;
    };
    DecorationSet.prototype.eq = function eq10(other) {
      if (this == other) {
        return true;
      }
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) {
        return false;
      }
      for (var i = 0; i < this.local.length; i++) {
        if (!this.local[i].eq(other.local[i])) {
          return false;
        }
      }
      for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
        if (this.children[i$1] != other.children[i$1] || this.children[i$1 + 1] != other.children[i$1 + 1] || !this.children[i$1 + 2].eq(other.children[i$1 + 2])) {
          return false;
        }
      }
      return true;
    };
    DecorationSet.prototype.locals = function locals(node4) {
      return removeOverlap(this.localsInner(node4));
    };
    DecorationSet.prototype.localsInner = function localsInner(node4) {
      if (this == empty) {
        return none;
      }
      if (node4.inlineContent || !this.local.some(InlineType.is)) {
        return this.local;
      }
      var result2 = [];
      for (var i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType)) {
          result2.push(this.local[i]);
        }
      }
      return result2;
    };
    empty = new DecorationSet();
    DecorationSet.empty = empty;
    DecorationSet.removeOverlap = removeOverlap;
    DecorationGroup = function DecorationGroup2(members) {
      this.members = members;
    };
    DecorationGroup.prototype.forChild = function forChild2(offset2, child3) {
      if (child3.isLeaf) {
        return DecorationSet.empty;
      }
      var found2 = [];
      for (var i = 0; i < this.members.length; i++) {
        var result2 = this.members[i].forChild(offset2, child3);
        if (result2 == empty) {
          continue;
        }
        if (result2 instanceof DecorationGroup) {
          found2 = found2.concat(result2.members);
        } else {
          found2.push(result2);
        }
      }
      return DecorationGroup.from(found2);
    };
    DecorationGroup.prototype.eq = function eq11(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) {
        return false;
      }
      for (var i = 0; i < this.members.length; i++) {
        if (!this.members[i].eq(other.members[i])) {
          return false;
        }
      }
      return true;
    };
    DecorationGroup.prototype.locals = function locals2(node4) {
      var result2, sorted = true;
      for (var i = 0; i < this.members.length; i++) {
        var locals3 = this.members[i].localsInner(node4);
        if (!locals3.length) {
          continue;
        }
        if (!result2) {
          result2 = locals3;
        } else {
          if (sorted) {
            result2 = result2.slice();
            sorted = false;
          }
          for (var j = 0; j < locals3.length; j++) {
            result2.push(locals3[j]);
          }
        }
      }
      return result2 ? removeOverlap(sorted ? result2 : result2.sort(byPos)) : none;
    };
    DecorationGroup.from = function from2(members) {
      switch (members.length) {
        case 0:
          return empty;
        case 1:
          return members[0];
        default:
          return new DecorationGroup(members);
      }
    };
    EditorView = function EditorView2(place, props) {
      this._props = props;
      this.state = props.state;
      this.dispatch = this.dispatch.bind(this);
      this._root = null;
      this.focused = false;
      this.trackWrites = null;
      this.dom = place && place.mount || document.createElement("div");
      if (place) {
        if (place.appendChild) {
          place.appendChild(this.dom);
        } else if (place.apply) {
          place(this.dom);
        } else if (place.mount) {
          this.mounted = true;
        }
      }
      this.editable = getEditable(this);
      this.markCursor = null;
      this.cursorWrapper = null;
      updateCursorWrapper(this);
      this.nodeViews = buildNodeViews(this);
      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
      this.lastSelectedViewDesc = null;
      this.dragging = null;
      initInput(this);
      this.pluginViews = [];
      this.updatePluginViews();
    };
    prototypeAccessors$22 = { props: { configurable: true }, root: { configurable: true } };
    prototypeAccessors$22.props.get = function() {
      if (this._props.state != this.state) {
        var prev = this._props;
        this._props = {};
        for (var name in prev) {
          this._props[name] = prev[name];
        }
        this._props.state = this.state;
      }
      return this._props;
    };
    EditorView.prototype.update = function update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this._props = props;
      this.updateStateInner(props.state, true);
    };
    EditorView.prototype.setProps = function setProps(props) {
      var updated = {};
      for (var name in this._props) {
        updated[name] = this._props[name];
      }
      updated.state = this.state;
      for (var name$1 in props) {
        updated[name$1] = props[name$1];
      }
      this.update(updated);
    };
    EditorView.prototype.updateState = function updateState(state) {
      this.updateStateInner(state, this.state.plugins != state.plugins);
    };
    EditorView.prototype.updateStateInner = function updateStateInner(state, reconfigured) {
      var this$1 = this;
      var prev = this.state, redraw = false, updateSel = false;
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      if (reconfigured) {
        var nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
      var scroll = reconfigured ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection)) {
        updateSel = true;
      }
      var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          var chromeKludge = result.chrome ? this.trackWrites = this.root.getSelection().focusNode : null;
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco([]);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites) {
            forceSelUpdate = true;
          }
        }
        if (forceSelUpdate || !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        var startDOM = this.root.getSelection().focusNode;
        if (this.someProp("handleScrollToSelection", function(f) {
          return f(this$1);
        }))
          ;
        else if (state.selection instanceof NodeSelection) {
          scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM);
        } else {
          scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM);
        }
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    };
    EditorView.prototype.destroyPluginViews = function destroyPluginViews() {
      var view;
      while (view = this.pluginViews.pop()) {
        if (view.destroy) {
          view.destroy();
        }
      }
    };
    EditorView.prototype.updatePluginViews = function updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins) {
        this.destroyPluginViews();
        for (var i = 0; i < this.state.plugins.length; i++) {
          var plugin = this.state.plugins[i];
          if (plugin.spec.view) {
            this.pluginViews.push(plugin.spec.view(this));
          }
        }
      } else {
        for (var i$1 = 0; i$1 < this.pluginViews.length; i$1++) {
          var pluginView = this.pluginViews[i$1];
          if (pluginView.update) {
            pluginView.update(this, prevState);
          }
        }
      }
    };
    EditorView.prototype.someProp = function someProp(propName, f) {
      var prop2 = this._props && this._props[propName], value;
      if (prop2 != null && (value = f ? f(prop2) : prop2)) {
        return value;
      }
      var plugins = this.state.plugins;
      if (plugins) {
        for (var i = 0; i < plugins.length; i++) {
          var prop$1 = plugins[i].props[propName];
          if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) {
            return value;
          }
        }
      }
    };
    EditorView.prototype.hasFocus = function hasFocus() {
      return this.root.activeElement == this.dom;
    };
    EditorView.prototype.focus = function focus() {
      this.domObserver.stop();
      if (this.editable) {
        focusPreventScroll(this.dom);
      }
      selectionToDOM(this);
      this.domObserver.start();
    };
    prototypeAccessors$22.root.get = function() {
      var cached = this._root;
      if (cached == null) {
        for (var search = this.dom.parentNode; search; search = search.parentNode) {
          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
            if (!search.getSelection) {
              Object.getPrototypeOf(search).getSelection = function() {
                return document.getSelection();
              };
            }
            return this._root = search;
          }
        }
      }
      return cached || document;
    };
    EditorView.prototype.posAtCoords = function posAtCoords$1(coords) {
      return posAtCoords(this, coords);
    };
    EditorView.prototype.coordsAtPos = function coordsAtPos$1(pos, side) {
      if (side === void 0) side = 1;
      return coordsAtPos(this, pos, side);
    };
    EditorView.prototype.domAtPos = function domAtPos(pos, side) {
      if (side === void 0) side = 0;
      return this.docView.domFromPos(pos, side);
    };
    EditorView.prototype.nodeDOM = function nodeDOM(pos) {
      var desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    };
    EditorView.prototype.posAtDOM = function posAtDOM(node4, offset2, bias) {
      if (bias === void 0) bias = -1;
      var pos = this.docView.posFromDOM(node4, offset2, bias);
      if (pos == null) {
        throw new RangeError("DOM position not inside the editor");
      }
      return pos;
    };
    EditorView.prototype.endOfTextblock = function endOfTextblock$1(dir, state) {
      return endOfTextblock(this, state || this.state, dir);
    };
    EditorView.prototype.destroy = function destroy2() {
      if (!this.docView) {
        return;
      }
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
    };
    EditorView.prototype.dispatchEvent = function dispatchEvent$1(event) {
      return dispatchEvent(this, event);
    };
    EditorView.prototype.dispatch = function dispatch(tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) {
        dispatchTransaction.call(this, tr);
      } else {
        this.updateState(this.state.apply(tr));
      }
    };
    Object.defineProperties(EditorView.prototype, prototypeAccessors$22);
  }
});

// ../../node_modules/.pnpm/prosemirror-inputrules@1.1.3/node_modules/prosemirror-inputrules/dist/index.es.js
var index_es_exports4 = {};
__export(index_es_exports4, {
  InputRule: () => InputRule,
  closeDoubleQuote: () => closeDoubleQuote,
  closeSingleQuote: () => closeSingleQuote,
  ellipsis: () => ellipsis,
  emDash: () => emDash,
  inputRules: () => inputRules,
  openDoubleQuote: () => openDoubleQuote,
  openSingleQuote: () => openSingleQuote,
  smartQuotes: () => smartQuotes,
  textblockTypeInputRule: () => textblockTypeInputRule,
  undoInputRule: () => undoInputRule,
  wrappingInputRule: () => wrappingInputRule
});
function stringHandler(string) {
  return function(state, match, start3, end2) {
    var insert = string;
    if (match[1]) {
      var offset2 = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset2 + match[1].length);
      start3 += offset2;
      var cutOff = start3 - end2;
      if (cutOff > 0) {
        insert = match[0].slice(offset2 - cutOff, offset2) + insert;
        start3 = end2;
      }
    }
    return state.tr.insertText(insert, start3, end2);
  };
}
function inputRules(ref) {
  var rules = ref.rules;
  var plugin = new Plugin({
    state: {
      init: function init5() {
        return null;
      },
      apply: function apply9(tr, prev) {
        var stored = tr.getMeta(this);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput: function handleTextInput(view, from4, to, text3) {
        return run(view, from4, to, text3, rules, plugin);
      },
      handleDOMEvents: {
        compositionend: function(view) {
          setTimeout(function() {
            var ref2 = view.state.selection;
            var $cursor = ref2.$cursor;
            if ($cursor) {
              run(view, $cursor.pos, $cursor.pos, "", rules, plugin);
            }
          });
        }
      }
    },
    isInputRules: true
  });
  return plugin;
}
function run(view, from4, to, text3, rules, plugin) {
  if (view.composing) {
    return false;
  }
  var state = view.state, $from = state.doc.resolve(from4);
  if ($from.parent.type.spec.code) {
    return false;
  }
  var textBefore = $from.parent.textBetween(
    Math.max(0, $from.parentOffset - MAX_MATCH),
    $from.parentOffset,
    null,
    "￼"
  ) + text3;
  for (var i = 0; i < rules.length; i++) {
    var match = rules[i].match.exec(textBefore);
    var tr = match && rules[i].handler(state, match, from4 - (match[0].length - text3.length), to);
    if (!tr) {
      continue;
    }
    view.dispatch(tr.setMeta(plugin, { transform: tr, from: from4, to, text: text3 }));
    return true;
  }
  return false;
}
function undoInputRule(state, dispatch2) {
  var plugins = state.plugins;
  for (var i = 0; i < plugins.length; i++) {
    var plugin = plugins[i], undoable = void 0;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch2) {
        var tr = state.tr, toUndo = undoable.transform;
        for (var j = toUndo.steps.length - 1; j >= 0; j--) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          var marks2 = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks2));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
        dispatch2(tr);
      }
      return true;
    }
  }
  return false;
}
function wrappingInputRule(regexp, nodeType2, getAttrs, joinPredicate) {
  return new InputRule(regexp, function(state, match, start3, end2) {
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    var tr = state.tr.delete(start3, end2);
    var $start = tr.doc.resolve(start3), range2 = $start.blockRange(), wrapping = range2 && findWrapping3(range2, nodeType2, attrs);
    if (!wrapping) {
      return null;
    }
    tr.wrap(range2, wrapping);
    var before2 = tr.doc.resolve(start3 - 1).nodeBefore;
    if (before2 && before2.type == nodeType2 && canJoin(tr.doc, start3 - 1) && (!joinPredicate || joinPredicate(match, before2))) {
      tr.join(start3 - 1);
    }
    return tr;
  });
}
function textblockTypeInputRule(regexp, nodeType2, getAttrs) {
  return new InputRule(regexp, function(state, match, start3, end2) {
    var $start = state.doc.resolve(start3);
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType2)) {
      return null;
    }
    return state.tr.delete(start3, end2).setBlockType(start3, start3, nodeType2, attrs);
  });
}
var InputRule, MAX_MATCH, emDash, ellipsis, openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote, smartQuotes;
var init_index_es6 = __esm({
  "../../node_modules/.pnpm/prosemirror-inputrules@1.1.3/node_modules/prosemirror-inputrules/dist/index.es.js"() {
    init_index_es4();
    init_index_es3();
    InputRule = function InputRule2(match, handler) {
      this.match = match;
      this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
    };
    MAX_MATCH = 500;
    emDash = new InputRule(/--$/, "—");
    ellipsis = new InputRule(/\.\.\.$/, "…");
    openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“");
    closeDoubleQuote = new InputRule(/"$/, "”");
    openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘");
    closeSingleQuote = new InputRule(/'$/, "’");
    smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];
  }
});

// ../../node_modules/.pnpm/@toast-ui+editor@3.1.10/node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js
var require_toastui_editor_viewer = __commonJS({
  "../../node_modules/.pnpm/@toast-ui+editor@3.1.10/node_modules/@toast-ui/editor/dist/toastui-editor-viewer.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory((init_index_es6(), __toCommonJS(index_es_exports4)), (init_index_es2(), __toCommonJS(index_es_exports)), (init_index_es4(), __toCommonJS(index_es_exports2)), (init_index_es5(), __toCommonJS(index_es_exports3)));
      else if (typeof define === "function" && define.amd)
        define(["prosemirror-inputrules", "prosemirror-model", "prosemirror-state", "prosemirror-view"], factory);
      else if (typeof exports === "object")
        exports["toastui"] = factory((init_index_es6(), __toCommonJS(index_es_exports4)), (init_index_es2(), __toCommonJS(index_es_exports)), (init_index_es4(), __toCommonJS(index_es_exports2)), (init_index_es5(), __toCommonJS(index_es_exports3)));
      else
        root["toastui"] = root["toastui"] || {}, root["toastui"]["Editor"] = factory(root[void 0], root[void 0], root[void 0], root[void 0]);
    })(self, function(__WEBPACK_EXTERNAL_MODULE__479__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__814__, __WEBPACK_EXTERNAL_MODULE__311__) {
      return (
        /******/
        (function() {
          var __webpack_modules__ = {
            /***/
            368: (
              /***/
              (function(module2) {
                (function(global2, factory) {
                  true ? module2.exports = factory() : 0;
                })(this, function() {
                  "use strict";
                  function _toConsumableArray2(arr) {
                    if (Array.isArray(arr)) {
                      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                        arr2[i] = arr[i];
                      }
                      return arr2;
                    } else {
                      return Array.from(arr);
                    }
                  }
                  var hasOwnProperty2 = Object.hasOwnProperty, setPrototypeOf2 = Object.setPrototypeOf, isFrozen2 = Object.isFrozen, getPrototypeOf2 = Object.getPrototypeOf, getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor;
                  var freeze2 = Object.freeze, seal2 = Object.seal, create6 = Object.create;
                  var _ref2 = typeof Reflect !== "undefined" && Reflect, apply9 = _ref2.apply, construct2 = _ref2.construct;
                  if (!apply9) {
                    apply9 = function apply10(fun, thisValue, args) {
                      return fun.apply(thisValue, args);
                    };
                  }
                  if (!freeze2) {
                    freeze2 = function freeze3(x) {
                      return x;
                    };
                  }
                  if (!seal2) {
                    seal2 = function seal3(x) {
                      return x;
                    };
                  }
                  if (!construct2) {
                    construct2 = function construct3(Func, args) {
                      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray2(args))))();
                    };
                  }
                  var arrayForEach2 = unapply2(Array.prototype.forEach);
                  var arrayPop2 = unapply2(Array.prototype.pop);
                  var arrayPush2 = unapply2(Array.prototype.push);
                  var stringToLowerCase2 = unapply2(String.prototype.toLowerCase);
                  var stringMatch2 = unapply2(String.prototype.match);
                  var stringReplace2 = unapply2(String.prototype.replace);
                  var stringIndexOf2 = unapply2(String.prototype.indexOf);
                  var stringTrim2 = unapply2(String.prototype.trim);
                  var regExpTest2 = unapply2(RegExp.prototype.test);
                  var typeErrorCreate2 = unconstruct2(TypeError);
                  function unapply2(func) {
                    return function(thisArg) {
                      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                        args[_key - 1] = arguments[_key];
                      }
                      return apply9(func, thisArg, args);
                    };
                  }
                  function unconstruct2(func) {
                    return function() {
                      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                        args[_key2] = arguments[_key2];
                      }
                      return construct2(func, args);
                    };
                  }
                  function addToSet3(set2, array) {
                    if (setPrototypeOf2) {
                      setPrototypeOf2(set2, null);
                    }
                    var l = array.length;
                    while (l--) {
                      var element = array[l];
                      if (typeof element === "string") {
                        var lcElement = stringToLowerCase2(element);
                        if (lcElement !== element) {
                          if (!isFrozen2(array)) {
                            array[l] = lcElement;
                          }
                          element = lcElement;
                        }
                      }
                      set2[element] = true;
                    }
                    return set2;
                  }
                  function clone2(object) {
                    var newObject = create6(null);
                    var property = void 0;
                    for (property in object) {
                      if (apply9(hasOwnProperty2, object, [property])) {
                        newObject[property] = object[property];
                      }
                    }
                    return newObject;
                  }
                  function lookupGetter2(object, prop2) {
                    while (object !== null) {
                      var desc = getOwnPropertyDescriptor2(object, prop2);
                      if (desc) {
                        if (desc.get) {
                          return unapply2(desc.get);
                        }
                        if (typeof desc.value === "function") {
                          return unapply2(desc.value);
                        }
                      }
                      object = getPrototypeOf2(object);
                    }
                    function fallbackValue(element) {
                      console.warn("fallback value for", element);
                      return null;
                    }
                    return fallbackValue;
                  }
                  var html2 = freeze2(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
                  var svg2 = freeze2(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
                  var svgFilters2 = freeze2(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
                  var svgDisallowed2 = freeze2(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
                  var mathMl2 = freeze2(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
                  var mathMlDisallowed2 = freeze2(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
                  var text3 = freeze2(["#text"]);
                  var html$12 = freeze2(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
                  var svg$12 = freeze2(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
                  var mathMl$12 = freeze2(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
                  var xml2 = freeze2(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
                  var MUSTACHE_EXPR2 = seal2(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
                  var ERB_EXPR2 = seal2(/<%[\s\S]*|[\s\S]*%>/gm);
                  var DATA_ATTR2 = seal2(/^data-[\-\w.\u00B7-\uFFFF]/);
                  var ARIA_ATTR2 = seal2(/^aria-[\-\w]+$/);
                  var IS_ALLOWED_URI2 = seal2(
                    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
                    // eslint-disable-line no-useless-escape
                  );
                  var IS_SCRIPT_OR_DATA2 = seal2(/^(?:\w+script|data):/i);
                  var ATTR_WHITESPACE2 = seal2(
                    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
                    // eslint-disable-line no-control-regex
                  );
                  var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
                    return typeof obj;
                  } : function(obj) {
                    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                  };
                  function _toConsumableArray$12(arr) {
                    if (Array.isArray(arr)) {
                      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                        arr2[i] = arr[i];
                      }
                      return arr2;
                    } else {
                      return Array.from(arr);
                    }
                  }
                  var getGlobal3 = function getGlobal4() {
                    return typeof window === "undefined" ? null : window;
                  };
                  var _createTrustedTypesPolicy3 = function _createTrustedTypesPolicy4(trustedTypes, document2) {
                    if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof2(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
                      return null;
                    }
                    var suffix = null;
                    var ATTR_NAME = "data-tt-policy-suffix";
                    if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
                      suffix = document2.currentScript.getAttribute(ATTR_NAME);
                    }
                    var policyName = "dompurify" + (suffix ? "#" + suffix : "");
                    try {
                      return trustedTypes.createPolicy(policyName, {
                        createHTML: function createHTML(html$$1) {
                          return html$$1;
                        }
                      });
                    } catch (_) {
                      console.warn("TrustedTypes policy " + policyName + " could not be created.");
                      return null;
                    }
                  };
                  function createDOMPurify2() {
                    var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal3();
                    var DOMPurify = function DOMPurify2(root) {
                      return createDOMPurify2(root);
                    };
                    DOMPurify.version = "2.3.3";
                    DOMPurify.removed = [];
                    if (!window2 || !window2.document || window2.document.nodeType !== 9) {
                      DOMPurify.isSupported = false;
                      return DOMPurify;
                    }
                    var originalDocument = window2.document;
                    var document2 = window2.document;
                    var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node4 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, Text2 = window2.Text, Comment = window2.Comment, DOMParser3 = window2.DOMParser, trustedTypes = window2.trustedTypes;
                    var ElementPrototype = Element2.prototype;
                    var cloneNode = lookupGetter2(ElementPrototype, "cloneNode");
                    var getNextSibling = lookupGetter2(ElementPrototype, "nextSibling");
                    var getChildNodes2 = lookupGetter2(ElementPrototype, "childNodes");
                    var getParentNode2 = lookupGetter2(ElementPrototype, "parentNode");
                    if (typeof HTMLTemplateElement === "function") {
                      var template = document2.createElement("template");
                      if (template.content && template.content.ownerDocument) {
                        document2 = template.content.ownerDocument;
                      }
                    }
                    var trustedTypesPolicy = _createTrustedTypesPolicy3(trustedTypes, originalDocument);
                    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML("") : "";
                    var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
                    var importNode = originalDocument.importNode;
                    var documentMode = {};
                    try {
                      documentMode = clone2(document2).documentMode ? document2.documentMode : {};
                    } catch (_) {
                    }
                    var hooks = {};
                    DOMPurify.isSupported = typeof getParentNode2 === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
                    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR2, ERB_EXPR$$1 = ERB_EXPR2, DATA_ATTR$$1 = DATA_ATTR2, ARIA_ATTR$$1 = ARIA_ATTR2, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA2, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE2;
                    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI2;
                    var ALLOWED_TAGS = null;
                    var DEFAULT_ALLOWED_TAGS = addToSet3({}, [].concat(_toConsumableArray$12(html2), _toConsumableArray$12(svg2), _toConsumableArray$12(svgFilters2), _toConsumableArray$12(mathMl2), _toConsumableArray$12(text3)));
                    var ALLOWED_ATTR = null;
                    var DEFAULT_ALLOWED_ATTR = addToSet3({}, [].concat(_toConsumableArray$12(html$12), _toConsumableArray$12(svg$12), _toConsumableArray$12(mathMl$12), _toConsumableArray$12(xml2)));
                    var FORBID_TAGS = null;
                    var FORBID_ATTR = null;
                    var ALLOW_ARIA_ATTR = true;
                    var ALLOW_DATA_ATTR = true;
                    var ALLOW_UNKNOWN_PROTOCOLS = false;
                    var SAFE_FOR_TEMPLATES = false;
                    var WHOLE_DOCUMENT = false;
                    var SET_CONFIG = false;
                    var FORCE_BODY = false;
                    var RETURN_DOM = false;
                    var RETURN_DOM_FRAGMENT = false;
                    var RETURN_DOM_IMPORT = true;
                    var RETURN_TRUSTED_TYPE = false;
                    var SANITIZE_DOM = true;
                    var KEEP_CONTENT = true;
                    var IN_PLACE = false;
                    var USE_PROFILES = {};
                    var FORBID_CONTENTS = null;
                    var DEFAULT_FORBID_CONTENTS = addToSet3({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
                    var DATA_URI_TAGS = null;
                    var DEFAULT_DATA_URI_TAGS = addToSet3({}, ["audio", "video", "img", "source", "image", "track"]);
                    var URI_SAFE_ATTRIBUTES = null;
                    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet3({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
                    var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
                    var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
                    var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
                    var NAMESPACE = HTML_NAMESPACE;
                    var IS_EMPTY_INPUT = false;
                    var PARSER_MEDIA_TYPE = void 0;
                    var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
                    var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
                    var transformCaseFunc = void 0;
                    var CONFIG = null;
                    var formElement = document2.createElement("form");
                    var _parseConfig = function _parseConfig2(cfg) {
                      if (CONFIG && CONFIG === cfg) {
                        return;
                      }
                      if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof2(cfg)) !== "object") {
                        cfg = {};
                      }
                      cfg = clone2(cfg);
                      ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet3({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
                      ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet3({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
                      URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet3(clone2(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
                      DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet3(clone2(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
                      FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet3({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
                      FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet3({}, cfg.FORBID_TAGS) : {};
                      FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet3({}, cfg.FORBID_ATTR) : {};
                      USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
                      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
                      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
                      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
                      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
                      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
                      RETURN_DOM = cfg.RETURN_DOM || false;
                      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
                      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false;
                      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
                      FORCE_BODY = cfg.FORCE_BODY || false;
                      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
                      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
                      IN_PLACE = cfg.IN_PLACE || false;
                      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
                      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
                      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
                      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
                      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x) {
                        return x;
                      } : stringToLowerCase2;
                      if (SAFE_FOR_TEMPLATES) {
                        ALLOW_DATA_ATTR = false;
                      }
                      if (RETURN_DOM_FRAGMENT) {
                        RETURN_DOM = true;
                      }
                      if (USE_PROFILES) {
                        ALLOWED_TAGS = addToSet3({}, [].concat(_toConsumableArray$12(text3)));
                        ALLOWED_ATTR = [];
                        if (USE_PROFILES.html === true) {
                          addToSet3(ALLOWED_TAGS, html2);
                          addToSet3(ALLOWED_ATTR, html$12);
                        }
                        if (USE_PROFILES.svg === true) {
                          addToSet3(ALLOWED_TAGS, svg2);
                          addToSet3(ALLOWED_ATTR, svg$12);
                          addToSet3(ALLOWED_ATTR, xml2);
                        }
                        if (USE_PROFILES.svgFilters === true) {
                          addToSet3(ALLOWED_TAGS, svgFilters2);
                          addToSet3(ALLOWED_ATTR, svg$12);
                          addToSet3(ALLOWED_ATTR, xml2);
                        }
                        if (USE_PROFILES.mathMl === true) {
                          addToSet3(ALLOWED_TAGS, mathMl2);
                          addToSet3(ALLOWED_ATTR, mathMl$12);
                          addToSet3(ALLOWED_ATTR, xml2);
                        }
                      }
                      if (cfg.ADD_TAGS) {
                        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
                          ALLOWED_TAGS = clone2(ALLOWED_TAGS);
                        }
                        addToSet3(ALLOWED_TAGS, cfg.ADD_TAGS);
                      }
                      if (cfg.ADD_ATTR) {
                        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
                          ALLOWED_ATTR = clone2(ALLOWED_ATTR);
                        }
                        addToSet3(ALLOWED_ATTR, cfg.ADD_ATTR);
                      }
                      if (cfg.ADD_URI_SAFE_ATTR) {
                        addToSet3(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
                      }
                      if (cfg.FORBID_CONTENTS) {
                        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
                          FORBID_CONTENTS = clone2(FORBID_CONTENTS);
                        }
                        addToSet3(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
                      }
                      if (KEEP_CONTENT) {
                        ALLOWED_TAGS["#text"] = true;
                      }
                      if (WHOLE_DOCUMENT) {
                        addToSet3(ALLOWED_TAGS, ["html", "head", "body"]);
                      }
                      if (ALLOWED_TAGS.table) {
                        addToSet3(ALLOWED_TAGS, ["tbody"]);
                        delete FORBID_TAGS.tbody;
                      }
                      if (freeze2) {
                        freeze2(cfg);
                      }
                      CONFIG = cfg;
                    };
                    var MATHML_TEXT_INTEGRATION_POINTS = addToSet3({}, ["mi", "mo", "mn", "ms", "mtext"]);
                    var HTML_INTEGRATION_POINTS = addToSet3({}, ["foreignobject", "desc", "title", "annotation-xml"]);
                    var ALL_SVG_TAGS = addToSet3({}, svg2);
                    addToSet3(ALL_SVG_TAGS, svgFilters2);
                    addToSet3(ALL_SVG_TAGS, svgDisallowed2);
                    var ALL_MATHML_TAGS = addToSet3({}, mathMl2);
                    addToSet3(ALL_MATHML_TAGS, mathMlDisallowed2);
                    var _checkValidNamespace = function _checkValidNamespace2(element) {
                      var parent = getParentNode2(element);
                      if (!parent || !parent.tagName) {
                        parent = {
                          namespaceURI: HTML_NAMESPACE,
                          tagName: "template"
                        };
                      }
                      var tagName = stringToLowerCase2(element.tagName);
                      var parentTagName = stringToLowerCase2(parent.tagName);
                      if (element.namespaceURI === SVG_NAMESPACE) {
                        if (parent.namespaceURI === HTML_NAMESPACE) {
                          return tagName === "svg";
                        }
                        if (parent.namespaceURI === MATHML_NAMESPACE) {
                          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
                        }
                        return Boolean(ALL_SVG_TAGS[tagName]);
                      }
                      if (element.namespaceURI === MATHML_NAMESPACE) {
                        if (parent.namespaceURI === HTML_NAMESPACE) {
                          return tagName === "math";
                        }
                        if (parent.namespaceURI === SVG_NAMESPACE) {
                          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
                        }
                        return Boolean(ALL_MATHML_TAGS[tagName]);
                      }
                      if (element.namespaceURI === HTML_NAMESPACE) {
                        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
                          return false;
                        }
                        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
                          return false;
                        }
                        var commonSvgAndHTMLElements = addToSet3({}, ["title", "style", "font", "a", "script"]);
                        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
                      }
                      return false;
                    };
                    var _forceRemove = function _forceRemove2(node4) {
                      arrayPush2(DOMPurify.removed, { element: node4 });
                      try {
                        node4.parentNode.removeChild(node4);
                      } catch (_) {
                        try {
                          node4.outerHTML = emptyHTML;
                        } catch (_2) {
                          node4.remove();
                        }
                      }
                    };
                    var _removeAttribute = function _removeAttribute2(name, node4) {
                      try {
                        arrayPush2(DOMPurify.removed, {
                          attribute: node4.getAttributeNode(name),
                          from: node4
                        });
                      } catch (_) {
                        arrayPush2(DOMPurify.removed, {
                          attribute: null,
                          from: node4
                        });
                      }
                      node4.removeAttribute(name);
                      if (name === "is" && !ALLOWED_ATTR[name]) {
                        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
                          try {
                            _forceRemove(node4);
                          } catch (_) {
                          }
                        } else {
                          try {
                            node4.setAttribute(name, "");
                          } catch (_) {
                          }
                        }
                      }
                    };
                    var _initDocument = function _initDocument2(dirty) {
                      var doc2 = void 0;
                      var leadingWhitespace = void 0;
                      if (FORCE_BODY) {
                        dirty = "<remove></remove>" + dirty;
                      } else {
                        var matches4 = stringMatch2(dirty, /^[\r\n\t ]+/);
                        leadingWhitespace = matches4 && matches4[0];
                      }
                      if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
                        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
                      }
                      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
                      if (NAMESPACE === HTML_NAMESPACE) {
                        try {
                          doc2 = new DOMParser3().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
                        } catch (_) {
                        }
                      }
                      if (!doc2 || !doc2.documentElement) {
                        doc2 = implementation.createDocument(NAMESPACE, "template", null);
                        try {
                          doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
                        } catch (_) {
                        }
                      }
                      var body = doc2.body || doc2.documentElement;
                      if (dirty && leadingWhitespace) {
                        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
                      }
                      if (NAMESPACE === HTML_NAMESPACE) {
                        return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
                      }
                      return WHOLE_DOCUMENT ? doc2.documentElement : body;
                    };
                    var _createIterator = function _createIterator2(root) {
                      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
                    };
                    var _isClobbered = function _isClobbered2(elm) {
                      if (elm instanceof Text2 || elm instanceof Comment) {
                        return false;
                      }
                      if (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function") {
                        return true;
                      }
                      return false;
                    };
                    var _isNode = function _isNode2(object) {
                      return (typeof Node4 === "undefined" ? "undefined" : _typeof2(Node4)) === "object" ? object instanceof Node4 : object && (typeof object === "undefined" ? "undefined" : _typeof2(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
                    };
                    var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
                      if (!hooks[entryPoint]) {
                        return;
                      }
                      arrayForEach2(hooks[entryPoint], function(hook) {
                        hook.call(DOMPurify, currentNode, data, CONFIG);
                      });
                    };
                    var _sanitizeElements = function _sanitizeElements2(currentNode) {
                      var content2 = void 0;
                      _executeHook("beforeSanitizeElements", currentNode, null);
                      if (_isClobbered(currentNode)) {
                        _forceRemove(currentNode);
                        return true;
                      }
                      if (stringMatch2(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
                        _forceRemove(currentNode);
                        return true;
                      }
                      var tagName = transformCaseFunc(currentNode.nodeName);
                      _executeHook("uponSanitizeElement", currentNode, {
                        tagName,
                        allowedTags: ALLOWED_TAGS
                      });
                      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest2(/<[/\w]/g, currentNode.innerHTML) && regExpTest2(/<[/\w]/g, currentNode.textContent)) {
                        _forceRemove(currentNode);
                        return true;
                      }
                      if (tagName === "select" && regExpTest2(/<template/i, currentNode.innerHTML)) {
                        _forceRemove(currentNode);
                        return true;
                      }
                      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
                        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
                          var parentNode2 = getParentNode2(currentNode) || currentNode.parentNode;
                          var childNodes = getChildNodes2(currentNode) || currentNode.childNodes;
                          if (childNodes && parentNode2) {
                            var childCount = childNodes.length;
                            for (var i = childCount - 1; i >= 0; --i) {
                              parentNode2.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
                            }
                          }
                        }
                        _forceRemove(currentNode);
                        return true;
                      }
                      if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
                        _forceRemove(currentNode);
                        return true;
                      }
                      if ((tagName === "noscript" || tagName === "noembed") && regExpTest2(/<\/no(script|embed)/i, currentNode.innerHTML)) {
                        _forceRemove(currentNode);
                        return true;
                      }
                      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
                        content2 = currentNode.textContent;
                        content2 = stringReplace2(content2, MUSTACHE_EXPR$$1, " ");
                        content2 = stringReplace2(content2, ERB_EXPR$$1, " ");
                        if (currentNode.textContent !== content2) {
                          arrayPush2(DOMPurify.removed, { element: currentNode.cloneNode() });
                          currentNode.textContent = content2;
                        }
                      }
                      _executeHook("afterSanitizeElements", currentNode, null);
                      return false;
                    };
                    var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
                      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
                        return false;
                      }
                      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest2(DATA_ATTR$$1, lcName)) ;
                      else if (ALLOW_ARIA_ATTR && regExpTest2(ARIA_ATTR$$1, lcName)) ;
                      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
                        return false;
                      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
                      else if (regExpTest2(IS_ALLOWED_URI$$1, stringReplace2(value, ATTR_WHITESPACE$$1, ""))) ;
                      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf2(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
                      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest2(IS_SCRIPT_OR_DATA$$1, stringReplace2(value, ATTR_WHITESPACE$$1, ""))) ;
                      else if (!value) ;
                      else {
                        return false;
                      }
                      return true;
                    };
                    var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
                      var attr = void 0;
                      var value = void 0;
                      var lcName = void 0;
                      var l = void 0;
                      _executeHook("beforeSanitizeAttributes", currentNode, null);
                      var attributes = currentNode.attributes;
                      if (!attributes) {
                        return;
                      }
                      var hookEvent = {
                        attrName: "",
                        attrValue: "",
                        keepAttr: true,
                        allowedAttributes: ALLOWED_ATTR
                      };
                      l = attributes.length;
                      while (l--) {
                        attr = attributes[l];
                        var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
                        value = stringTrim2(attr.value);
                        lcName = transformCaseFunc(name);
                        hookEvent.attrName = lcName;
                        hookEvent.attrValue = value;
                        hookEvent.keepAttr = true;
                        hookEvent.forceKeepAttr = void 0;
                        _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
                        value = hookEvent.attrValue;
                        if (hookEvent.forceKeepAttr) {
                          continue;
                        }
                        _removeAttribute(name, currentNode);
                        if (!hookEvent.keepAttr) {
                          continue;
                        }
                        if (regExpTest2(/\/>/i, value)) {
                          _removeAttribute(name, currentNode);
                          continue;
                        }
                        if (SAFE_FOR_TEMPLATES) {
                          value = stringReplace2(value, MUSTACHE_EXPR$$1, " ");
                          value = stringReplace2(value, ERB_EXPR$$1, " ");
                        }
                        var lcTag = transformCaseFunc(currentNode.nodeName);
                        if (!_isValidAttribute(lcTag, lcName, value)) {
                          continue;
                        }
                        try {
                          if (namespaceURI) {
                            currentNode.setAttributeNS(namespaceURI, name, value);
                          } else {
                            currentNode.setAttribute(name, value);
                          }
                          arrayPop2(DOMPurify.removed);
                        } catch (_) {
                        }
                      }
                      _executeHook("afterSanitizeAttributes", currentNode, null);
                    };
                    var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
                      var shadowNode = void 0;
                      var shadowIterator = _createIterator(fragment);
                      _executeHook("beforeSanitizeShadowDOM", fragment, null);
                      while (shadowNode = shadowIterator.nextNode()) {
                        _executeHook("uponSanitizeShadowNode", shadowNode, null);
                        if (_sanitizeElements(shadowNode)) {
                          continue;
                        }
                        if (shadowNode.content instanceof DocumentFragment) {
                          _sanitizeShadowDOM2(shadowNode.content);
                        }
                        _sanitizeAttributes(shadowNode);
                      }
                      _executeHook("afterSanitizeShadowDOM", fragment, null);
                    };
                    DOMPurify.sanitize = function(dirty, cfg) {
                      var body = void 0;
                      var importedNode = void 0;
                      var currentNode = void 0;
                      var oldNode = void 0;
                      var returnNode = void 0;
                      IS_EMPTY_INPUT = !dirty;
                      if (IS_EMPTY_INPUT) {
                        dirty = "<!-->";
                      }
                      if (typeof dirty !== "string" && !_isNode(dirty)) {
                        if (typeof dirty.toString !== "function") {
                          throw typeErrorCreate2("toString is not a function");
                        } else {
                          dirty = dirty.toString();
                          if (typeof dirty !== "string") {
                            throw typeErrorCreate2("dirty is not a string, aborting");
                          }
                        }
                      }
                      if (!DOMPurify.isSupported) {
                        if (_typeof2(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
                          if (typeof dirty === "string") {
                            return window2.toStaticHTML(dirty);
                          }
                          if (_isNode(dirty)) {
                            return window2.toStaticHTML(dirty.outerHTML);
                          }
                        }
                        return dirty;
                      }
                      if (!SET_CONFIG) {
                        _parseConfig(cfg);
                      }
                      DOMPurify.removed = [];
                      if (typeof dirty === "string") {
                        IN_PLACE = false;
                      }
                      if (IN_PLACE) ;
                      else if (dirty instanceof Node4) {
                        body = _initDocument("<!---->");
                        importedNode = body.ownerDocument.importNode(dirty, true);
                        if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
                          body = importedNode;
                        } else if (importedNode.nodeName === "HTML") {
                          body = importedNode;
                        } else {
                          body.appendChild(importedNode);
                        }
                      } else {
                        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
                        dirty.indexOf("<") === -1) {
                          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
                        }
                        body = _initDocument(dirty);
                        if (!body) {
                          return RETURN_DOM ? null : emptyHTML;
                        }
                      }
                      if (body && FORCE_BODY) {
                        _forceRemove(body.firstChild);
                      }
                      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
                      while (currentNode = nodeIterator.nextNode()) {
                        if (currentNode.nodeType === 3 && currentNode === oldNode) {
                          continue;
                        }
                        if (_sanitizeElements(currentNode)) {
                          continue;
                        }
                        if (currentNode.content instanceof DocumentFragment) {
                          _sanitizeShadowDOM(currentNode.content);
                        }
                        _sanitizeAttributes(currentNode);
                        oldNode = currentNode;
                      }
                      oldNode = null;
                      if (IN_PLACE) {
                        return dirty;
                      }
                      if (RETURN_DOM) {
                        if (RETURN_DOM_FRAGMENT) {
                          returnNode = createDocumentFragment.call(body.ownerDocument);
                          while (body.firstChild) {
                            returnNode.appendChild(body.firstChild);
                          }
                        } else {
                          returnNode = body;
                        }
                        if (RETURN_DOM_IMPORT) {
                          returnNode = importNode.call(originalDocument, returnNode, true);
                        }
                        return returnNode;
                      }
                      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
                      if (SAFE_FOR_TEMPLATES) {
                        serializedHTML = stringReplace2(serializedHTML, MUSTACHE_EXPR$$1, " ");
                        serializedHTML = stringReplace2(serializedHTML, ERB_EXPR$$1, " ");
                      }
                      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
                    };
                    DOMPurify.setConfig = function(cfg) {
                      _parseConfig(cfg);
                      SET_CONFIG = true;
                    };
                    DOMPurify.clearConfig = function() {
                      CONFIG = null;
                      SET_CONFIG = false;
                    };
                    DOMPurify.isValidAttribute = function(tag, attr, value) {
                      if (!CONFIG) {
                        _parseConfig({});
                      }
                      var lcTag = transformCaseFunc(tag);
                      var lcName = transformCaseFunc(attr);
                      return _isValidAttribute(lcTag, lcName, value);
                    };
                    DOMPurify.addHook = function(entryPoint, hookFunction) {
                      if (typeof hookFunction !== "function") {
                        return;
                      }
                      hooks[entryPoint] = hooks[entryPoint] || [];
                      arrayPush2(hooks[entryPoint], hookFunction);
                    };
                    DOMPurify.removeHook = function(entryPoint) {
                      if (hooks[entryPoint]) {
                        arrayPop2(hooks[entryPoint]);
                      }
                    };
                    DOMPurify.removeHooks = function(entryPoint) {
                      if (hooks[entryPoint]) {
                        hooks[entryPoint] = [];
                      }
                    };
                    DOMPurify.removeAllHooks = function() {
                      hooks = {};
                    };
                    return DOMPurify;
                  }
                  var purify2 = createDOMPurify2();
                  return purify2;
                });
              })
            ),
            /***/
            928: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isArray3 = __webpack_require__2(322);
                function inArray2(searchElement, array, startIndex) {
                  var i;
                  var length;
                  startIndex = startIndex || 0;
                  if (!isArray3(array)) {
                    return -1;
                  }
                  if (Array.prototype.indexOf) {
                    return Array.prototype.indexOf.call(array, searchElement, startIndex);
                  }
                  length = array.length;
                  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
                    if (array[i] === searchElement) {
                      return i;
                    }
                  }
                  return -1;
                }
                module2.exports = inArray2;
              })
            ),
            /***/
            690: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isArray3 = __webpack_require__2(322);
                var forEachArray2 = __webpack_require__2(893);
                var forEachOwnProperties3 = __webpack_require__2(956);
                function forEach6(obj, iteratee, context) {
                  if (isArray3(obj)) {
                    forEachArray2(obj, iteratee, context);
                  } else {
                    forEachOwnProperties3(obj, iteratee, context);
                  }
                }
                module2.exports = forEach6;
              })
            ),
            /***/
            893: (
              /***/
              (function(module2) {
                "use strict";
                function forEachArray2(arr, iteratee, context) {
                  var index3 = 0;
                  var len = arr.length;
                  context = context || null;
                  for (; index3 < len; index3 += 1) {
                    if (iteratee.call(context, arr[index3], index3, arr) === false) {
                      break;
                    }
                  }
                }
                module2.exports = forEachArray2;
              })
            ),
            /***/
            956: (
              /***/
              (function(module2) {
                "use strict";
                function forEachOwnProperties3(obj, iteratee, context) {
                  var key;
                  context = context || null;
                  for (key in obj) {
                    if (obj.hasOwnProperty(key)) {
                      if (iteratee.call(context, obj[key], key, obj) === false) {
                        break;
                      }
                    }
                  }
                }
                module2.exports = forEachOwnProperties3;
              })
            ),
            /***/
            990: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var forEachArray2 = __webpack_require__2(893);
                function toArray3(arrayLike) {
                  var arr;
                  try {
                    arr = Array.prototype.slice.call(arrayLike);
                  } catch (e) {
                    arr = [];
                    forEachArray2(arrayLike, function(value) {
                      arr.push(value);
                    });
                  }
                  return arr;
                }
                module2.exports = toArray3;
              })
            ),
            /***/
            755: (
              /***/
              (function(module2) {
                "use strict";
                var EVENT_KEY2 = "_feEventKey";
                function safeEvent2(element, type) {
                  var events = element[EVENT_KEY2];
                  var handlers2;
                  if (!events) {
                    events = element[EVENT_KEY2] = {};
                  }
                  handlers2 = events[type];
                  if (!handlers2) {
                    handlers2 = events[type] = [];
                  }
                  return handlers2;
                }
                module2.exports = safeEvent2;
              })
            ),
            /***/
            349: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isString3 = __webpack_require__2(758);
                var forEach6 = __webpack_require__2(690);
                var safeEvent2 = __webpack_require__2(755);
                function off2(element, types, handler) {
                  if (isString3(types)) {
                    forEach6(types.split(/\s+/g), function(type) {
                      unbindEvent2(element, type, handler);
                    });
                    return;
                  }
                  forEach6(types, function(func, type) {
                    unbindEvent2(element, type, func);
                  });
                }
                function unbindEvent2(element, type, handler) {
                  var events = safeEvent2(element, type);
                  var index3;
                  if (!handler) {
                    forEach6(events, function(item2) {
                      removeHandler2(element, type, item2.wrappedHandler);
                    });
                    events.splice(0, events.length);
                  } else {
                    forEach6(events, function(item2, idx) {
                      if (handler === item2.handler) {
                        removeHandler2(element, type, item2.wrappedHandler);
                        index3 = idx;
                        return false;
                      }
                      return true;
                    });
                    events.splice(index3, 1);
                  }
                }
                function removeHandler2(element, type, handler) {
                  if ("removeEventListener" in element) {
                    element.removeEventListener(type, handler);
                  } else if ("detachEvent" in element) {
                    element.detachEvent("on" + type, handler);
                  }
                }
                module2.exports = off2;
              })
            ),
            /***/
            348: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isString3 = __webpack_require__2(758);
                var forEach6 = __webpack_require__2(690);
                var safeEvent2 = __webpack_require__2(755);
                function on2(element, types, handler, context) {
                  if (isString3(types)) {
                    forEach6(types.split(/\s+/g), function(type) {
                      bindEvent2(element, type, handler, context);
                    });
                    return;
                  }
                  forEach6(types, function(func, type) {
                    bindEvent2(element, type, func, handler);
                  });
                }
                function bindEvent2(element, type, handler, context) {
                  function eventHandler(e) {
                    handler.call(context || element, e || window.event);
                  }
                  if ("addEventListener" in element) {
                    element.addEventListener(type, eventHandler);
                  } else if ("attachEvent" in element) {
                    element.attachEvent("on" + type, eventHandler);
                  }
                  memorizeHandler2(element, type, handler, eventHandler);
                }
                function memorizeHandler2(element, type, handler, wrappedHandler) {
                  var events = safeEvent2(element, type);
                  var existInEvents = false;
                  forEach6(events, function(obj) {
                    if (obj.handler === handler) {
                      existInEvents = true;
                      return false;
                    }
                    return true;
                  });
                  if (!existInEvents) {
                    events.push({
                      handler,
                      wrappedHandler
                    });
                  }
                }
                module2.exports = on2;
              })
            ),
            /***/
            24: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isArray3 = __webpack_require__2(322);
                var isUndefined3 = __webpack_require__2(929);
                function setClassName2(element, cssClass) {
                  cssClass = isArray3(cssClass) ? cssClass.join(" ") : cssClass;
                  cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
                  if (isUndefined3(element.className.baseVal)) {
                    element.className = cssClass;
                    return;
                  }
                  element.className.baseVal = cssClass;
                }
                module2.exports = setClassName2;
              })
            ),
            /***/
            204: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var forEach6 = __webpack_require__2(690);
                var inArray2 = __webpack_require__2(928);
                var getClass2 = __webpack_require__2(902);
                var setClassName2 = __webpack_require__2(24);
                function addClass2(element) {
                  var cssClass = Array.prototype.slice.call(arguments, 1);
                  var classList = element.classList;
                  var newClass = [];
                  var origin;
                  if (classList) {
                    forEach6(cssClass, function(name) {
                      element.classList.add(name);
                    });
                    return;
                  }
                  origin = getClass2(element);
                  if (origin) {
                    cssClass = [].concat(origin.split(/\s+/), cssClass);
                  }
                  forEach6(cssClass, function(cls2) {
                    if (inArray2(cls2, newClass) < 0) {
                      newClass.push(cls2);
                    }
                  });
                  setClassName2(element, newClass);
                }
                module2.exports = addClass2;
              })
            ),
            /***/
            522: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isString3 = __webpack_require__2(758);
                var forEach6 = __webpack_require__2(690);
                function css2(element, key, value) {
                  var style = element.style;
                  if (isString3(key)) {
                    style[key] = value;
                    return;
                  }
                  forEach6(key, function(v, k) {
                    style[k] = v;
                  });
                }
                module2.exports = css2;
              })
            ),
            /***/
            902: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isUndefined3 = __webpack_require__2(929);
                function getClass2(element) {
                  if (!element || !element.className) {
                    return "";
                  }
                  if (isUndefined3(element.className.baseVal)) {
                    return element.className;
                  }
                  return element.className.baseVal;
                }
                module2.exports = getClass2;
              })
            ),
            /***/
            714: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var inArray2 = __webpack_require__2(928);
                var getClass2 = __webpack_require__2(902);
                function hasClass2(element, cssClass) {
                  var origin;
                  if (element.classList) {
                    return element.classList.contains(cssClass);
                  }
                  origin = getClass2(element).split(/\s+/);
                  return inArray2(cssClass, origin) > -1;
                }
                module2.exports = hasClass2;
              })
            ),
            /***/
            471: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var inArray2 = __webpack_require__2(928);
                var toArray3 = __webpack_require__2(990);
                var elProto2 = Element.prototype;
                var matchSelector2 = elProto2.matches || elProto2.webkitMatchesSelector || elProto2.mozMatchesSelector || elProto2.msMatchesSelector || function(selector) {
                  var doc2 = this.document || this.ownerDocument;
                  return inArray2(this, toArray3(doc2.querySelectorAll(selector))) > -1;
                };
                function matches4(element, selector) {
                  return matchSelector2.call(element, selector);
                }
                module2.exports = matches4;
              })
            ),
            /***/
            462: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var forEachArray2 = __webpack_require__2(893);
                var inArray2 = __webpack_require__2(928);
                var getClass2 = __webpack_require__2(902);
                var setClassName2 = __webpack_require__2(24);
                function removeClass2(element) {
                  var cssClass = Array.prototype.slice.call(arguments, 1);
                  var classList = element.classList;
                  var origin, newClass;
                  if (classList) {
                    forEachArray2(cssClass, function(name) {
                      classList.remove(name);
                    });
                    return;
                  }
                  origin = getClass2(element).split(/\s+/);
                  newClass = [];
                  forEachArray2(origin, function(name) {
                    if (inArray2(name, cssClass) < 0) {
                      newClass.push(name);
                    }
                  });
                  setClassName2(element, newClass);
                }
                module2.exports = removeClass2;
              })
            ),
            /***/
            969: (
              /***/
              (function(module2) {
                "use strict";
                function extend2(target2, objects) {
                  var hasOwnProp = Object.prototype.hasOwnProperty;
                  var source, prop2, i, len;
                  for (i = 1, len = arguments.length; i < len; i += 1) {
                    source = arguments[i];
                    for (prop2 in source) {
                      if (hasOwnProp.call(source, prop2)) {
                        target2[prop2] = source[prop2];
                      }
                    }
                  }
                  return target2;
                }
                module2.exports = extend2;
              })
            ),
            /***/
            254: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var forEachOwnProperties3 = __webpack_require__2(956);
                function imagePing2(url, trackingInfo) {
                  var trackingElement = document.createElement("img");
                  var queryString = "";
                  forEachOwnProperties3(trackingInfo, function(value, key) {
                    queryString += "&" + key + "=" + value;
                  });
                  queryString = queryString.substring(1);
                  trackingElement.src = url + "?" + queryString;
                  trackingElement.style.display = "none";
                  document.body.appendChild(trackingElement);
                  document.body.removeChild(trackingElement);
                  return trackingElement;
                }
                module2.exports = imagePing2;
              })
            ),
            /***/
            391: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isUndefined3 = __webpack_require__2(929);
                var imagePing2 = __webpack_require__2(254);
                var ms7days2 = 7 * 24 * 60 * 60 * 1e3;
                function isExpired2(date) {
                  var now = (/* @__PURE__ */ new Date()).getTime();
                  return now - date > ms7days2;
                }
                function sendHostname3(appName, trackingId) {
                  var url = "https://www.google-analytics.com/collect";
                  var hostname = location.hostname;
                  var hitType = "event";
                  var eventCategory = "use";
                  var applicationKeyForStorage = "TOAST UI " + appName + " for " + hostname + ": Statistics";
                  var date = window.localStorage.getItem(applicationKeyForStorage);
                  if (!isUndefined3(window.tui) && window.tui.usageStatistics === false) {
                    return;
                  }
                  if (date && !isExpired2(date)) {
                    return;
                  }
                  window.localStorage.setItem(applicationKeyForStorage, (/* @__PURE__ */ new Date()).getTime());
                  setTimeout(function() {
                    if (document.readyState === "interactive" || document.readyState === "complete") {
                      imagePing2(url, {
                        v: 1,
                        t: hitType,
                        tid: trackingId,
                        cid: hostname,
                        dp: hostname,
                        dh: appName,
                        el: appName,
                        ec: eventCategory
                      });
                    }
                  }, 1e3);
                }
                module2.exports = sendHostname3;
              })
            ),
            /***/
            322: (
              /***/
              (function(module2) {
                "use strict";
                function isArray3(obj) {
                  return obj instanceof Array;
                }
                module2.exports = isArray3;
              })
            ),
            /***/
            65: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isUndefined3 = __webpack_require__2(929);
                var isNull3 = __webpack_require__2(934);
                function isExisty2(param) {
                  return !isUndefined3(param) && !isNull3(param);
                }
                module2.exports = isExisty2;
              })
            ),
            /***/
            404: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isTruthy2 = __webpack_require__2(790);
                function isFalsy2(obj) {
                  return !isTruthy2(obj);
                }
                module2.exports = isFalsy2;
              })
            ),
            /***/
            294: (
              /***/
              (function(module2) {
                "use strict";
                function isFunction2(obj) {
                  return obj instanceof Function;
                }
                module2.exports = isFunction2;
              })
            ),
            /***/
            934: (
              /***/
              (function(module2) {
                "use strict";
                function isNull3(obj) {
                  return obj === null;
                }
                module2.exports = isNull3;
              })
            ),
            /***/
            758: (
              /***/
              (function(module2) {
                "use strict";
                function isString3(obj) {
                  return typeof obj === "string" || obj instanceof String;
                }
                module2.exports = isString3;
              })
            ),
            /***/
            790: (
              /***/
              (function(module2, __unused_webpack_exports, __webpack_require__2) {
                "use strict";
                var isExisty2 = __webpack_require__2(65);
                function isTruthy2(obj) {
                  return isExisty2(obj) && obj !== false;
                }
                module2.exports = isTruthy2;
              })
            ),
            /***/
            929: (
              /***/
              (function(module2) {
                "use strict";
                function isUndefined3(obj) {
                  return obj === void 0;
                }
                module2.exports = isUndefined3;
              })
            ),
            /***/
            479: (
              /***/
              (function(module2) {
                "use strict";
                module2.exports = __WEBPACK_EXTERNAL_MODULE__479__;
              })
            ),
            /***/
            43: (
              /***/
              (function(module2) {
                "use strict";
                module2.exports = __WEBPACK_EXTERNAL_MODULE__43__;
              })
            ),
            /***/
            814: (
              /***/
              (function(module2) {
                "use strict";
                module2.exports = __WEBPACK_EXTERNAL_MODULE__814__;
              })
            ),
            /***/
            311: (
              /***/
              (function(module2) {
                "use strict";
                module2.exports = __WEBPACK_EXTERNAL_MODULE__311__;
              })
            )
            /******/
          };
          var __webpack_module_cache__ = {};
          function __webpack_require__(moduleId) {
            var cachedModule = __webpack_module_cache__[moduleId];
            if (cachedModule !== void 0) {
              return cachedModule.exports;
            }
            var module2 = __webpack_module_cache__[moduleId] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            return module2.exports;
          }
          !(function() {
            __webpack_require__.n = function(module2) {
              var getter = module2 && module2.__esModule ? (
                /******/
                function() {
                  return module2["default"];
                }
              ) : (
                /******/
                function() {
                  return module2;
                }
              );
              __webpack_require__.d(getter, { a: getter });
              return getter;
            };
          })();
          !(function() {
            __webpack_require__.d = function(exports2, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          })();
          !(function() {
            __webpack_require__.g = (function() {
              if (typeof globalThis === "object") return globalThis;
              try {
                return this || new Function("return this")();
              } catch (e) {
                if (typeof window === "object") return window;
              }
            })();
          })();
          !(function() {
            __webpack_require__.o = function(obj, prop2) {
              return Object.prototype.hasOwnProperty.call(obj, prop2);
            };
          })();
          var __webpack_exports__ = {};
          !(function() {
            "use strict";
            __webpack_require__.d(__webpack_exports__, {
              "default": function() {
                return (
                  /* binding */
                  indexViewer
                );
              }
            });
            ;
            var extendStatics3 = function(d, b) {
              extendStatics3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
              };
              return extendStatics3(d, b);
            };
            function __extends3(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              extendStatics3(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            }
            var tslib_es6_assign = function() {
              tslib_es6_assign = Object.assign || function __assign4(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
              };
              return tslib_es6_assign.apply(this, arguments);
            };
            function __rest(s, e) {
              var t = {};
              for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
              if (s != null && typeof Object.getOwnPropertySymbols === "function")
                for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                  if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
                }
              return t;
            }
            function __decorate(decorators, target3, key, desc) {
              var c = arguments.length, r = c < 3 ? target3 : desc === null ? desc = Object.getOwnPropertyDescriptor(target3, key) : desc, d;
              if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target3, key, desc);
              else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target3, key, r) : d(target3, key)) || r;
              return c > 3 && r && Object.defineProperty(target3, key, r), r;
            }
            function __param(paramIndex, decorator) {
              return function(target3, key) {
                decorator(target3, key, paramIndex);
              };
            }
            function __metadata(metadataKey, metadataValue) {
              if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
            }
            function __awaiter(thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P ? value : new P(function(resolve6) {
                  resolve6(value);
                });
              }
              return new (P || (P = Promise))(function(resolve6, reject) {
                function fulfilled(value) {
                  try {
                    step2(generator.next(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function rejected(value) {
                  try {
                    step2(generator["throw"](value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function step2(result2) {
                  result2.done ? resolve6(result2.value) : adopt(result2.value).then(fulfilled, rejected);
                }
                step2((generator = generator.apply(thisArg, _arguments || [])).next());
              });
            }
            function __generator(thisArg, body) {
              var _ = { label: 0, sent: function() {
                if (t[0] & 1) throw t[1];
                return t[1];
              }, trys: [], ops: [] }, f, y, t, g;
              return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
                return this;
              }), g;
              function verb(n) {
                return function(v) {
                  return step2([n, v]);
                };
              }
              function step2(op) {
                if (f) throw new TypeError("Generator is already executing.");
                while (_) try {
                  if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                  if (y = 0, t) op = [op[0] & 2, t.value];
                  switch (op[0]) {
                    case 0:
                    case 1:
                      t = op;
                      break;
                    case 4:
                      _.label++;
                      return { value: op[1], done: false };
                    case 5:
                      _.label++;
                      y = op[1];
                      op = [0];
                      continue;
                    case 7:
                      op = _.ops.pop();
                      _.trys.pop();
                      continue;
                    default:
                      if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                      }
                      if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                      }
                      if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                      }
                      if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                      }
                      if (t[2]) _.ops.pop();
                      _.trys.pop();
                      continue;
                  }
                  op = body.call(thisArg, _);
                } catch (e) {
                  op = [6, e];
                  y = 0;
                } finally {
                  f = t = 0;
                }
                if (op[0] & 5) throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
              }
            }
            var __createBinding = Object.create ? (function(o, m, k, k2) {
              if (k2 === void 0) k2 = k;
              Object.defineProperty(o, k2, { enumerable: true, get: function() {
                return m[k];
              } });
            }) : (function(o, m, k, k2) {
              if (k2 === void 0) k2 = k;
              o[k2] = m[k];
            });
            function __exportStar(m, o) {
              for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
            }
            function __values(o) {
              var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
              if (m) return m.call(o);
              if (o && typeof o.length === "number") return {
                next: function() {
                  if (o && i >= o.length) o = void 0;
                  return { value: o && o[i++], done: !o };
                }
              };
              throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
            }
            function __read(o, n) {
              var m = typeof Symbol === "function" && o[Symbol.iterator];
              if (!m) return o;
              var i = m.call(o), r, ar = [], e;
              try {
                while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
              } catch (error) {
                e = { error };
              } finally {
                try {
                  if (r && !r.done && (m = i["return"])) m.call(i);
                } finally {
                  if (e) throw e.error;
                }
              }
              return ar;
            }
            function __spread() {
              for (var ar = [], i = 0; i < arguments.length; i++)
                ar = ar.concat(__read(arguments[i]));
              return ar;
            }
            function __spreadArrays() {
              for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
              for (var r = Array(s), k = 0, i = 0; i < il; i++)
                for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                  r[k] = a[j];
              return r;
            }
            function __spreadArray2(to, from4, pack) {
              if (pack || arguments.length === 2) for (var i = 0, l = from4.length, ar; i < l; i++) {
                if (ar || !(i in from4)) {
                  if (!ar) ar = Array.prototype.slice.call(from4, 0, i);
                  ar[i] = from4[i];
                }
              }
              return to.concat(ar || Array.prototype.slice.call(from4));
            }
            function __await(v) {
              return this instanceof __await ? (this.v = v, this) : new __await(v);
            }
            function __asyncGenerator(thisArg, _arguments, generator) {
              if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
              var g = generator.apply(thisArg, _arguments || []), i, q = [];
              return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
              }, i;
              function verb(n) {
                if (g[n]) i[n] = function(v) {
                  return new Promise(function(a, b) {
                    q.push([n, v, a, b]) > 1 || resume(n, v);
                  });
                };
              }
              function resume(n, v) {
                try {
                  step2(g[n](v));
                } catch (e) {
                  settle(q[0][3], e);
                }
              }
              function step2(r) {
                r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
              }
              function fulfill(value) {
                resume("next", value);
              }
              function reject(value) {
                resume("throw", value);
              }
              function settle(f, v) {
                if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
              }
            }
            function __asyncDelegator(o) {
              var i, p;
              return i = {}, verb("next"), verb("throw", function(e) {
                throw e;
              }), verb("return"), i[Symbol.iterator] = function() {
                return this;
              }, i;
              function verb(n, f) {
                i[n] = o[n] ? function(v) {
                  return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v;
                } : f;
              }
            }
            function __asyncValues(o) {
              if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
              var m = o[Symbol.asyncIterator], i;
              return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
                return this;
              }, i);
              function verb(n) {
                i[n] = o[n] && function(v) {
                  return new Promise(function(resolve6, reject) {
                    v = o[n](v), settle(resolve6, reject, v.done, v.value);
                  });
                };
              }
              function settle(resolve6, reject, d, v) {
                Promise.resolve(v).then(function(v2) {
                  resolve6({ value: v2, done: d });
                }, reject);
              }
            }
            function __makeTemplateObject2(cooked, raw) {
              if (Object.defineProperty) {
                Object.defineProperty(cooked, "raw", { value: raw });
              } else {
                cooked.raw = raw;
              }
              return cooked;
            }
            ;
            var __setModuleDefault = Object.create ? (function(o, v) {
              Object.defineProperty(o, "default", { enumerable: true, value: v });
            }) : function(o, v) {
              o["default"] = v;
            };
            function __importStar(mod) {
              if (mod && mod.__esModule) return mod;
              var result2 = {};
              if (mod != null) {
                for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result2, mod, k);
              }
              __setModuleDefault(result2, mod);
              return result2;
            }
            function __importDefault2(mod) {
              return mod && mod.__esModule ? mod : { default: mod };
            }
            function __classPrivateFieldGet(receiver, state, kind, f) {
              if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
              if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
              return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
            }
            function __classPrivateFieldSet(receiver, state, value, kind, f) {
              if (kind === "m") throw new TypeError("Private method is not writable");
              if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
              if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
              return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
            }
            ;
            var esm_extendStatics = function(d, b) {
              esm_extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
                d2.__proto__ = b2;
              } || function(d2, b2) {
                for (var p in b2)
                  if (Object.prototype.hasOwnProperty.call(b2, p))
                    d2[p] = b2[p];
              };
              return esm_extendStatics(d, b);
            };
            function esm_extends(d, b) {
              if (typeof b !== "function" && b !== null)
                throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
              esm_extendStatics(d, b);
              function __() {
                this.constructor = d;
              }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            }
            var esm_assign = function() {
              esm_assign = Object.assign || function __assign4(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                      t[p] = s[p];
                }
                return t;
              };
              return esm_assign.apply(this, arguments);
            };
            function esm_spreadArray(to, from4, pack) {
              if (pack || arguments.length === 2)
                for (var i = 0, l = from4.length, ar; i < l; i++) {
                  if (ar || !(i in from4)) {
                    if (!ar)
                      ar = Array.prototype.slice.call(from4, 0, i);
                    ar[i] = from4[i];
                  }
                }
              return to.concat(ar || Array.prototype.slice.call(from4));
            }
            var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : {};
            var encodeCache2 = {};
            function getEncodeCache2(exclude) {
              var i, ch, cache3 = encodeCache2[exclude];
              if (cache3) {
                return cache3;
              }
              cache3 = encodeCache2[exclude] = [];
              for (i = 0; i < 128; i++) {
                ch = String.fromCharCode(i);
                if (/^[0-9a-z]$/i.test(ch)) {
                  cache3.push(ch);
                } else {
                  cache3.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
                }
              }
              for (i = 0; i < exclude.length; i++) {
                cache3[exclude.charCodeAt(i)] = exclude[i];
              }
              return cache3;
            }
            function encode$12(string, exclude, keepEscaped) {
              var i, l, code2, nextCode, cache3, result2 = "";
              if (typeof exclude !== "string") {
                keepEscaped = exclude;
                exclude = encode$12.defaultChars;
              }
              if (typeof keepEscaped === "undefined") {
                keepEscaped = true;
              }
              cache3 = getEncodeCache2(exclude);
              for (i = 0, l = string.length; i < l; i++) {
                code2 = string.charCodeAt(i);
                if (keepEscaped && code2 === 37 && i + 2 < l) {
                  if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
                    result2 += string.slice(i, i + 3);
                    i += 2;
                    continue;
                  }
                }
                if (code2 < 128) {
                  result2 += cache3[code2];
                  continue;
                }
                if (code2 >= 55296 && code2 <= 57343) {
                  if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
                    nextCode = string.charCodeAt(i + 1);
                    if (nextCode >= 56320 && nextCode <= 57343) {
                      result2 += encodeURIComponent(string[i] + string[i + 1]);
                      i++;
                      continue;
                    }
                  }
                  result2 += "%EF%BF%BD";
                  continue;
                }
                result2 += encodeURIComponent(string[i]);
              }
              return result2;
            }
            encode$12.defaultChars = ";/?:@&=+$,-_.!~*'()#";
            encode$12.componentChars = "-_.!~*'()";
            var encode_12 = encode$12;
            var lib2 = {};
            var decode2 = {};
            var Aacute$12 = "Á";
            var aacute$12 = "á";
            var Abreve2 = "Ă";
            var abreve2 = "ă";
            var ac2 = "∾";
            var acd2 = "∿";
            var acE2 = "∾̳";
            var Acirc$12 = "Â";
            var acirc$12 = "â";
            var acute$12 = "´";
            var Acy2 = "А";
            var acy2 = "а";
            var AElig$12 = "Æ";
            var aelig$12 = "æ";
            var af2 = "⁡";
            var Afr2 = "𝔄";
            var afr2 = "𝔞";
            var Agrave$12 = "À";
            var agrave$12 = "à";
            var alefsym2 = "ℵ";
            var aleph2 = "ℵ";
            var Alpha2 = "Α";
            var alpha2 = "α";
            var Amacr2 = "Ā";
            var amacr2 = "ā";
            var amalg2 = "⨿";
            var amp$22 = "&";
            var AMP$12 = "&";
            var andand2 = "⩕";
            var And2 = "⩓";
            var and2 = "∧";
            var andd2 = "⩜";
            var andslope2 = "⩘";
            var andv2 = "⩚";
            var ang2 = "∠";
            var ange2 = "⦤";
            var angle2 = "∠";
            var angmsdaa2 = "⦨";
            var angmsdab2 = "⦩";
            var angmsdac2 = "⦪";
            var angmsdad2 = "⦫";
            var angmsdae2 = "⦬";
            var angmsdaf2 = "⦭";
            var angmsdag2 = "⦮";
            var angmsdah2 = "⦯";
            var angmsd2 = "∡";
            var angrt2 = "∟";
            var angrtvb2 = "⊾";
            var angrtvbd2 = "⦝";
            var angsph2 = "∢";
            var angst2 = "Å";
            var angzarr2 = "⍼";
            var Aogon2 = "Ą";
            var aogon2 = "ą";
            var Aopf2 = "𝔸";
            var aopf2 = "𝕒";
            var apacir2 = "⩯";
            var ap2 = "≈";
            var apE2 = "⩰";
            var ape2 = "≊";
            var apid2 = "≋";
            var apos$12 = "'";
            var ApplyFunction2 = "⁡";
            var approx2 = "≈";
            var approxeq2 = "≊";
            var Aring$12 = "Å";
            var aring$12 = "å";
            var Ascr2 = "𝒜";
            var ascr2 = "𝒶";
            var Assign2 = "≔";
            var ast2 = "*";
            var asymp2 = "≈";
            var asympeq2 = "≍";
            var Atilde$12 = "Ã";
            var atilde$12 = "ã";
            var Auml$12 = "Ä";
            var auml$12 = "ä";
            var awconint2 = "∳";
            var awint2 = "⨑";
            var backcong2 = "≌";
            var backepsilon2 = "϶";
            var backprime2 = "‵";
            var backsim2 = "∽";
            var backsimeq2 = "⋍";
            var Backslash2 = "∖";
            var Barv2 = "⫧";
            var barvee2 = "⊽";
            var barwed2 = "⌅";
            var Barwed2 = "⌆";
            var barwedge2 = "⌅";
            var bbrk2 = "⎵";
            var bbrktbrk2 = "⎶";
            var bcong2 = "≌";
            var Bcy2 = "Б";
            var bcy2 = "б";
            var bdquo2 = "„";
            var becaus2 = "∵";
            var because2 = "∵";
            var Because2 = "∵";
            var bemptyv2 = "⦰";
            var bepsi2 = "϶";
            var bernou2 = "ℬ";
            var Bernoullis2 = "ℬ";
            var Beta2 = "Β";
            var beta2 = "β";
            var beth2 = "ℶ";
            var between2 = "≬";
            var Bfr2 = "𝔅";
            var bfr2 = "𝔟";
            var bigcap2 = "⋂";
            var bigcirc2 = "◯";
            var bigcup2 = "⋃";
            var bigodot2 = "⨀";
            var bigoplus2 = "⨁";
            var bigotimes2 = "⨂";
            var bigsqcup2 = "⨆";
            var bigstar2 = "★";
            var bigtriangledown2 = "▽";
            var bigtriangleup2 = "△";
            var biguplus2 = "⨄";
            var bigvee2 = "⋁";
            var bigwedge2 = "⋀";
            var bkarow2 = "⤍";
            var blacklozenge2 = "⧫";
            var blacksquare2 = "▪";
            var blacktriangle2 = "▴";
            var blacktriangledown2 = "▾";
            var blacktriangleleft2 = "◂";
            var blacktriangleright2 = "▸";
            var blank2 = "␣";
            var blk122 = "▒";
            var blk142 = "░";
            var blk342 = "▓";
            var block2 = "█";
            var bne2 = "=⃥";
            var bnequiv2 = "≡⃥";
            var bNot2 = "⫭";
            var bnot2 = "⌐";
            var Bopf2 = "𝔹";
            var bopf2 = "𝕓";
            var bot2 = "⊥";
            var bottom2 = "⊥";
            var bowtie2 = "⋈";
            var boxbox2 = "⧉";
            var boxdl2 = "┐";
            var boxdL2 = "╕";
            var boxDl2 = "╖";
            var boxDL2 = "╗";
            var boxdr2 = "┌";
            var boxdR2 = "╒";
            var boxDr2 = "╓";
            var boxDR2 = "╔";
            var boxh2 = "─";
            var boxH2 = "═";
            var boxhd2 = "┬";
            var boxHd2 = "╤";
            var boxhD2 = "╥";
            var boxHD2 = "╦";
            var boxhu2 = "┴";
            var boxHu2 = "╧";
            var boxhU2 = "╨";
            var boxHU2 = "╩";
            var boxminus2 = "⊟";
            var boxplus2 = "⊞";
            var boxtimes2 = "⊠";
            var boxul2 = "┘";
            var boxuL2 = "╛";
            var boxUl2 = "╜";
            var boxUL2 = "╝";
            var boxur2 = "└";
            var boxuR2 = "╘";
            var boxUr2 = "╙";
            var boxUR2 = "╚";
            var boxv2 = "│";
            var boxV2 = "║";
            var boxvh2 = "┼";
            var boxvH2 = "╪";
            var boxVh2 = "╫";
            var boxVH2 = "╬";
            var boxvl2 = "┤";
            var boxvL2 = "╡";
            var boxVl2 = "╢";
            var boxVL2 = "╣";
            var boxvr2 = "├";
            var boxvR2 = "╞";
            var boxVr2 = "╟";
            var boxVR2 = "╠";
            var bprime2 = "‵";
            var breve2 = "˘";
            var Breve2 = "˘";
            var brvbar$12 = "¦";
            var bscr2 = "𝒷";
            var Bscr2 = "ℬ";
            var bsemi2 = "⁏";
            var bsim2 = "∽";
            var bsime2 = "⋍";
            var bsolb2 = "⧅";
            var bsol2 = "\\";
            var bsolhsub2 = "⟈";
            var bull2 = "•";
            var bullet2 = "•";
            var bump2 = "≎";
            var bumpE2 = "⪮";
            var bumpe2 = "≏";
            var Bumpeq2 = "≎";
            var bumpeq2 = "≏";
            var Cacute2 = "Ć";
            var cacute2 = "ć";
            var capand2 = "⩄";
            var capbrcup2 = "⩉";
            var capcap2 = "⩋";
            var cap2 = "∩";
            var Cap2 = "⋒";
            var capcup2 = "⩇";
            var capdot2 = "⩀";
            var CapitalDifferentialD2 = "ⅅ";
            var caps2 = "∩︀";
            var caret2 = "⁁";
            var caron2 = "ˇ";
            var Cayleys2 = "ℭ";
            var ccaps2 = "⩍";
            var Ccaron2 = "Č";
            var ccaron2 = "č";
            var Ccedil$12 = "Ç";
            var ccedil$12 = "ç";
            var Ccirc2 = "Ĉ";
            var ccirc2 = "ĉ";
            var Cconint2 = "∰";
            var ccups2 = "⩌";
            var ccupssm2 = "⩐";
            var Cdot2 = "Ċ";
            var cdot2 = "ċ";
            var cedil$12 = "¸";
            var Cedilla2 = "¸";
            var cemptyv2 = "⦲";
            var cent$12 = "¢";
            var centerdot2 = "·";
            var CenterDot2 = "·";
            var cfr2 = "𝔠";
            var Cfr2 = "ℭ";
            var CHcy2 = "Ч";
            var chcy2 = "ч";
            var check3 = "✓";
            var checkmark2 = "✓";
            var Chi2 = "Χ";
            var chi2 = "χ";
            var circ2 = "ˆ";
            var circeq2 = "≗";
            var circlearrowleft2 = "↺";
            var circlearrowright2 = "↻";
            var circledast2 = "⊛";
            var circledcirc2 = "⊚";
            var circleddash2 = "⊝";
            var CircleDot2 = "⊙";
            var circledR2 = "®";
            var circledS2 = "Ⓢ";
            var CircleMinus2 = "⊖";
            var CirclePlus2 = "⊕";
            var CircleTimes2 = "⊗";
            var cir2 = "○";
            var cirE2 = "⧃";
            var cire2 = "≗";
            var cirfnint2 = "⨐";
            var cirmid2 = "⫯";
            var cirscir2 = "⧂";
            var ClockwiseContourIntegral2 = "∲";
            var CloseCurlyDoubleQuote2 = "”";
            var CloseCurlyQuote2 = "’";
            var clubs2 = "♣";
            var clubsuit2 = "♣";
            var colon2 = ":";
            var Colon2 = "∷";
            var Colone2 = "⩴";
            var colone2 = "≔";
            var coloneq2 = "≔";
            var comma2 = ",";
            var commat2 = "@";
            var comp2 = "∁";
            var compfn2 = "∘";
            var complement2 = "∁";
            var complexes2 = "ℂ";
            var cong2 = "≅";
            var congdot2 = "⩭";
            var Congruent2 = "≡";
            var conint2 = "∮";
            var Conint2 = "∯";
            var ContourIntegral2 = "∮";
            var copf2 = "𝕔";
            var Copf2 = "ℂ";
            var coprod2 = "∐";
            var Coproduct2 = "∐";
            var copy$12 = "©";
            var COPY$12 = "©";
            var copysr2 = "℗";
            var CounterClockwiseContourIntegral2 = "∳";
            var crarr2 = "↵";
            var cross2 = "✗";
            var Cross2 = "⨯";
            var Cscr2 = "𝒞";
            var cscr2 = "𝒸";
            var csub2 = "⫏";
            var csube2 = "⫑";
            var csup2 = "⫐";
            var csupe2 = "⫒";
            var ctdot2 = "⋯";
            var cudarrl2 = "⤸";
            var cudarrr2 = "⤵";
            var cuepr2 = "⋞";
            var cuesc2 = "⋟";
            var cularr2 = "↶";
            var cularrp2 = "⤽";
            var cupbrcap2 = "⩈";
            var cupcap2 = "⩆";
            var CupCap2 = "≍";
            var cup2 = "∪";
            var Cup2 = "⋓";
            var cupcup2 = "⩊";
            var cupdot2 = "⊍";
            var cupor2 = "⩅";
            var cups2 = "∪︀";
            var curarr2 = "↷";
            var curarrm2 = "⤼";
            var curlyeqprec2 = "⋞";
            var curlyeqsucc2 = "⋟";
            var curlyvee2 = "⋎";
            var curlywedge2 = "⋏";
            var curren$12 = "¤";
            var curvearrowleft2 = "↶";
            var curvearrowright2 = "↷";
            var cuvee2 = "⋎";
            var cuwed2 = "⋏";
            var cwconint2 = "∲";
            var cwint2 = "∱";
            var cylcty2 = "⌭";
            var dagger2 = "†";
            var Dagger2 = "‡";
            var daleth2 = "ℸ";
            var darr2 = "↓";
            var Darr2 = "↡";
            var dArr2 = "⇓";
            var dash2 = "‐";
            var Dashv2 = "⫤";
            var dashv2 = "⊣";
            var dbkarow2 = "⤏";
            var dblac2 = "˝";
            var Dcaron2 = "Ď";
            var dcaron2 = "ď";
            var Dcy2 = "Д";
            var dcy2 = "д";
            var ddagger2 = "‡";
            var ddarr2 = "⇊";
            var DD2 = "ⅅ";
            var dd2 = "ⅆ";
            var DDotrahd2 = "⤑";
            var ddotseq2 = "⩷";
            var deg$12 = "°";
            var Del2 = "∇";
            var Delta2 = "Δ";
            var delta2 = "δ";
            var demptyv2 = "⦱";
            var dfisht2 = "⥿";
            var Dfr2 = "𝔇";
            var dfr2 = "𝔡";
            var dHar2 = "⥥";
            var dharl2 = "⇃";
            var dharr2 = "⇂";
            var DiacriticalAcute2 = "´";
            var DiacriticalDot2 = "˙";
            var DiacriticalDoubleAcute2 = "˝";
            var DiacriticalGrave2 = "`";
            var DiacriticalTilde2 = "˜";
            var diam2 = "⋄";
            var diamond2 = "⋄";
            var Diamond2 = "⋄";
            var diamondsuit2 = "♦";
            var diams2 = "♦";
            var die2 = "¨";
            var DifferentialD2 = "ⅆ";
            var digamma2 = "ϝ";
            var disin2 = "⋲";
            var div2 = "÷";
            var divide$12 = "÷";
            var divideontimes2 = "⋇";
            var divonx2 = "⋇";
            var DJcy2 = "Ђ";
            var djcy2 = "ђ";
            var dlcorn2 = "⌞";
            var dlcrop2 = "⌍";
            var dollar2 = "$";
            var Dopf2 = "𝔻";
            var dopf2 = "𝕕";
            var Dot2 = "¨";
            var dot2 = "˙";
            var DotDot2 = "⃜";
            var doteq2 = "≐";
            var doteqdot2 = "≑";
            var DotEqual2 = "≐";
            var dotminus2 = "∸";
            var dotplus2 = "∔";
            var dotsquare2 = "⊡";
            var doublebarwedge2 = "⌆";
            var DoubleContourIntegral2 = "∯";
            var DoubleDot2 = "¨";
            var DoubleDownArrow2 = "⇓";
            var DoubleLeftArrow2 = "⇐";
            var DoubleLeftRightArrow2 = "⇔";
            var DoubleLeftTee2 = "⫤";
            var DoubleLongLeftArrow2 = "⟸";
            var DoubleLongLeftRightArrow2 = "⟺";
            var DoubleLongRightArrow2 = "⟹";
            var DoubleRightArrow2 = "⇒";
            var DoubleRightTee2 = "⊨";
            var DoubleUpArrow2 = "⇑";
            var DoubleUpDownArrow2 = "⇕";
            var DoubleVerticalBar2 = "∥";
            var DownArrowBar2 = "⤓";
            var downarrow2 = "↓";
            var DownArrow2 = "↓";
            var Downarrow2 = "⇓";
            var DownArrowUpArrow2 = "⇵";
            var DownBreve2 = "̑";
            var downdownarrows2 = "⇊";
            var downharpoonleft2 = "⇃";
            var downharpoonright2 = "⇂";
            var DownLeftRightVector2 = "⥐";
            var DownLeftTeeVector2 = "⥞";
            var DownLeftVectorBar2 = "⥖";
            var DownLeftVector2 = "↽";
            var DownRightTeeVector2 = "⥟";
            var DownRightVectorBar2 = "⥗";
            var DownRightVector2 = "⇁";
            var DownTeeArrow2 = "↧";
            var DownTee2 = "⊤";
            var drbkarow2 = "⤐";
            var drcorn2 = "⌟";
            var drcrop2 = "⌌";
            var Dscr2 = "𝒟";
            var dscr2 = "𝒹";
            var DScy2 = "Ѕ";
            var dscy2 = "ѕ";
            var dsol2 = "⧶";
            var Dstrok2 = "Đ";
            var dstrok2 = "đ";
            var dtdot2 = "⋱";
            var dtri2 = "▿";
            var dtrif2 = "▾";
            var duarr2 = "⇵";
            var duhar2 = "⥯";
            var dwangle2 = "⦦";
            var DZcy2 = "Џ";
            var dzcy2 = "џ";
            var dzigrarr2 = "⟿";
            var Eacute$12 = "É";
            var eacute$12 = "é";
            var easter2 = "⩮";
            var Ecaron2 = "Ě";
            var ecaron2 = "ě";
            var Ecirc$12 = "Ê";
            var ecirc$12 = "ê";
            var ecir2 = "≖";
            var ecolon2 = "≕";
            var Ecy2 = "Э";
            var ecy2 = "э";
            var eDDot2 = "⩷";
            var Edot2 = "Ė";
            var edot2 = "ė";
            var eDot2 = "≑";
            var ee2 = "ⅇ";
            var efDot2 = "≒";
            var Efr2 = "𝔈";
            var efr2 = "𝔢";
            var eg2 = "⪚";
            var Egrave$12 = "È";
            var egrave$12 = "è";
            var egs2 = "⪖";
            var egsdot2 = "⪘";
            var el2 = "⪙";
            var Element2 = "∈";
            var elinters2 = "⏧";
            var ell2 = "ℓ";
            var els2 = "⪕";
            var elsdot2 = "⪗";
            var Emacr2 = "Ē";
            var emacr2 = "ē";
            var empty3 = "∅";
            var emptyset2 = "∅";
            var EmptySmallSquare2 = "◻";
            var emptyv2 = "∅";
            var EmptyVerySmallSquare2 = "▫";
            var emsp132 = " ";
            var emsp142 = " ";
            var emsp2 = " ";
            var ENG2 = "Ŋ";
            var eng2 = "ŋ";
            var ensp2 = " ";
            var Eogon2 = "Ę";
            var eogon2 = "ę";
            var Eopf2 = "𝔼";
            var eopf2 = "𝕖";
            var epar2 = "⋕";
            var eparsl2 = "⧣";
            var eplus2 = "⩱";
            var epsi2 = "ε";
            var Epsilon2 = "Ε";
            var epsilon2 = "ε";
            var epsiv2 = "ϵ";
            var eqcirc2 = "≖";
            var eqcolon2 = "≕";
            var eqsim2 = "≂";
            var eqslantgtr2 = "⪖";
            var eqslantless2 = "⪕";
            var Equal2 = "⩵";
            var equals2 = "=";
            var EqualTilde2 = "≂";
            var equest2 = "≟";
            var Equilibrium2 = "⇌";
            var equiv2 = "≡";
            var equivDD2 = "⩸";
            var eqvparsl2 = "⧥";
            var erarr2 = "⥱";
            var erDot2 = "≓";
            var escr2 = "ℯ";
            var Escr2 = "ℰ";
            var esdot2 = "≐";
            var Esim2 = "⩳";
            var esim2 = "≂";
            var Eta2 = "Η";
            var eta2 = "η";
            var ETH$12 = "Ð";
            var eth$12 = "ð";
            var Euml$12 = "Ë";
            var euml$12 = "ë";
            var euro2 = "€";
            var excl2 = "!";
            var exist2 = "∃";
            var Exists2 = "∃";
            var expectation2 = "ℰ";
            var exponentiale2 = "ⅇ";
            var ExponentialE2 = "ⅇ";
            var fallingdotseq2 = "≒";
            var Fcy2 = "Ф";
            var fcy2 = "ф";
            var female2 = "♀";
            var ffilig2 = "ﬃ";
            var fflig2 = "ﬀ";
            var ffllig2 = "ﬄ";
            var Ffr2 = "𝔉";
            var ffr2 = "𝔣";
            var filig2 = "ﬁ";
            var FilledSmallSquare2 = "◼";
            var FilledVerySmallSquare2 = "▪";
            var fjlig2 = "fj";
            var flat2 = "♭";
            var fllig2 = "ﬂ";
            var fltns2 = "▱";
            var fnof2 = "ƒ";
            var Fopf2 = "𝔽";
            var fopf2 = "𝕗";
            var forall2 = "∀";
            var ForAll2 = "∀";
            var fork2 = "⋔";
            var forkv2 = "⫙";
            var Fouriertrf2 = "ℱ";
            var fpartint2 = "⨍";
            var frac12$12 = "½";
            var frac132 = "⅓";
            var frac14$12 = "¼";
            var frac152 = "⅕";
            var frac162 = "⅙";
            var frac182 = "⅛";
            var frac232 = "⅔";
            var frac252 = "⅖";
            var frac34$12 = "¾";
            var frac352 = "⅗";
            var frac382 = "⅜";
            var frac452 = "⅘";
            var frac562 = "⅚";
            var frac582 = "⅝";
            var frac782 = "⅞";
            var frasl2 = "⁄";
            var frown2 = "⌢";
            var fscr2 = "𝒻";
            var Fscr2 = "ℱ";
            var gacute2 = "ǵ";
            var Gamma2 = "Γ";
            var gamma2 = "γ";
            var Gammad2 = "Ϝ";
            var gammad2 = "ϝ";
            var gap2 = "⪆";
            var Gbreve2 = "Ğ";
            var gbreve2 = "ğ";
            var Gcedil2 = "Ģ";
            var Gcirc2 = "Ĝ";
            var gcirc2 = "ĝ";
            var Gcy2 = "Г";
            var gcy2 = "г";
            var Gdot2 = "Ġ";
            var gdot2 = "ġ";
            var ge2 = "≥";
            var gE2 = "≧";
            var gEl2 = "⪌";
            var gel2 = "⋛";
            var geq2 = "≥";
            var geqq2 = "≧";
            var geqslant2 = "⩾";
            var gescc2 = "⪩";
            var ges2 = "⩾";
            var gesdot2 = "⪀";
            var gesdoto2 = "⪂";
            var gesdotol2 = "⪄";
            var gesl2 = "⋛︀";
            var gesles2 = "⪔";
            var Gfr2 = "𝔊";
            var gfr2 = "𝔤";
            var gg2 = "≫";
            var Gg2 = "⋙";
            var ggg2 = "⋙";
            var gimel2 = "ℷ";
            var GJcy2 = "Ѓ";
            var gjcy2 = "ѓ";
            var gla2 = "⪥";
            var gl2 = "≷";
            var glE2 = "⪒";
            var glj2 = "⪤";
            var gnap2 = "⪊";
            var gnapprox2 = "⪊";
            var gne2 = "⪈";
            var gnE2 = "≩";
            var gneq2 = "⪈";
            var gneqq2 = "≩";
            var gnsim2 = "⋧";
            var Gopf2 = "𝔾";
            var gopf2 = "𝕘";
            var grave2 = "`";
            var GreaterEqual2 = "≥";
            var GreaterEqualLess2 = "⋛";
            var GreaterFullEqual2 = "≧";
            var GreaterGreater2 = "⪢";
            var GreaterLess2 = "≷";
            var GreaterSlantEqual2 = "⩾";
            var GreaterTilde2 = "≳";
            var Gscr2 = "𝒢";
            var gscr2 = "ℊ";
            var gsim2 = "≳";
            var gsime2 = "⪎";
            var gsiml2 = "⪐";
            var gtcc2 = "⪧";
            var gtcir2 = "⩺";
            var gt$22 = ">";
            var GT$12 = ">";
            var Gt2 = "≫";
            var gtdot2 = "⋗";
            var gtlPar2 = "⦕";
            var gtquest2 = "⩼";
            var gtrapprox2 = "⪆";
            var gtrarr2 = "⥸";
            var gtrdot2 = "⋗";
            var gtreqless2 = "⋛";
            var gtreqqless2 = "⪌";
            var gtrless2 = "≷";
            var gtrsim2 = "≳";
            var gvertneqq2 = "≩︀";
            var gvnE2 = "≩︀";
            var Hacek2 = "ˇ";
            var hairsp2 = " ";
            var half2 = "½";
            var hamilt2 = "ℋ";
            var HARDcy2 = "Ъ";
            var hardcy2 = "ъ";
            var harrcir2 = "⥈";
            var harr2 = "↔";
            var hArr2 = "⇔";
            var harrw2 = "↭";
            var Hat2 = "^";
            var hbar2 = "ℏ";
            var Hcirc2 = "Ĥ";
            var hcirc2 = "ĥ";
            var hearts2 = "♥";
            var heartsuit2 = "♥";
            var hellip2 = "…";
            var hercon2 = "⊹";
            var hfr2 = "𝔥";
            var Hfr2 = "ℌ";
            var HilbertSpace2 = "ℋ";
            var hksearow2 = "⤥";
            var hkswarow2 = "⤦";
            var hoarr2 = "⇿";
            var homtht2 = "∻";
            var hookleftarrow2 = "↩";
            var hookrightarrow2 = "↪";
            var hopf2 = "𝕙";
            var Hopf2 = "ℍ";
            var horbar2 = "―";
            var HorizontalLine2 = "─";
            var hscr2 = "𝒽";
            var Hscr2 = "ℋ";
            var hslash2 = "ℏ";
            var Hstrok2 = "Ħ";
            var hstrok2 = "ħ";
            var HumpDownHump2 = "≎";
            var HumpEqual2 = "≏";
            var hybull2 = "⁃";
            var hyphen2 = "‐";
            var Iacute$12 = "Í";
            var iacute$12 = "í";
            var ic2 = "⁣";
            var Icirc$12 = "Î";
            var icirc$12 = "î";
            var Icy2 = "И";
            var icy2 = "и";
            var Idot2 = "İ";
            var IEcy2 = "Е";
            var iecy2 = "е";
            var iexcl$12 = "¡";
            var iff2 = "⇔";
            var ifr2 = "𝔦";
            var Ifr2 = "ℑ";
            var Igrave$12 = "Ì";
            var igrave$12 = "ì";
            var ii2 = "ⅈ";
            var iiiint2 = "⨌";
            var iiint2 = "∭";
            var iinfin2 = "⧜";
            var iiota2 = "℩";
            var IJlig2 = "Ĳ";
            var ijlig2 = "ĳ";
            var Imacr2 = "Ī";
            var imacr2 = "ī";
            var esm_image = "ℑ";
            var ImaginaryI2 = "ⅈ";
            var imagline2 = "ℐ";
            var imagpart2 = "ℑ";
            var imath2 = "ı";
            var Im2 = "ℑ";
            var imof2 = "⊷";
            var imped2 = "Ƶ";
            var Implies2 = "⇒";
            var incare2 = "℅";
            var infin2 = "∞";
            var infintie2 = "⧝";
            var inodot2 = "ı";
            var intcal2 = "⊺";
            var esm_int = "∫";
            var Int2 = "∬";
            var integers2 = "ℤ";
            var Integral2 = "∫";
            var intercal2 = "⊺";
            var Intersection2 = "⋂";
            var intlarhk2 = "⨗";
            var intprod2 = "⨼";
            var InvisibleComma2 = "⁣";
            var InvisibleTimes2 = "⁢";
            var IOcy2 = "Ё";
            var iocy2 = "ё";
            var Iogon2 = "Į";
            var iogon2 = "į";
            var Iopf2 = "𝕀";
            var iopf2 = "𝕚";
            var Iota2 = "Ι";
            var iota2 = "ι";
            var iprod2 = "⨼";
            var iquest$12 = "¿";
            var iscr2 = "𝒾";
            var Iscr2 = "ℐ";
            var isin2 = "∈";
            var isindot2 = "⋵";
            var isinE2 = "⋹";
            var isins2 = "⋴";
            var isinsv2 = "⋳";
            var isinv2 = "∈";
            var it2 = "⁢";
            var Itilde2 = "Ĩ";
            var itilde2 = "ĩ";
            var Iukcy2 = "І";
            var iukcy2 = "і";
            var Iuml$12 = "Ï";
            var iuml$12 = "ï";
            var Jcirc2 = "Ĵ";
            var jcirc2 = "ĵ";
            var Jcy2 = "Й";
            var jcy2 = "й";
            var Jfr2 = "𝔍";
            var jfr2 = "𝔧";
            var jmath2 = "ȷ";
            var Jopf2 = "𝕁";
            var jopf2 = "𝕛";
            var Jscr2 = "𝒥";
            var jscr2 = "𝒿";
            var Jsercy2 = "Ј";
            var jsercy2 = "ј";
            var Jukcy2 = "Є";
            var jukcy2 = "є";
            var Kappa2 = "Κ";
            var kappa2 = "κ";
            var kappav2 = "ϰ";
            var Kcedil2 = "Ķ";
            var kcedil2 = "ķ";
            var Kcy2 = "К";
            var kcy2 = "к";
            var Kfr2 = "𝔎";
            var kfr2 = "𝔨";
            var kgreen2 = "ĸ";
            var KHcy2 = "Х";
            var khcy2 = "х";
            var KJcy2 = "Ќ";
            var kjcy2 = "ќ";
            var Kopf2 = "𝕂";
            var kopf2 = "𝕜";
            var Kscr2 = "𝒦";
            var kscr2 = "𝓀";
            var lAarr2 = "⇚";
            var Lacute2 = "Ĺ";
            var lacute2 = "ĺ";
            var laemptyv2 = "⦴";
            var lagran2 = "ℒ";
            var Lambda2 = "Λ";
            var lambda2 = "λ";
            var lang2 = "⟨";
            var Lang2 = "⟪";
            var langd2 = "⦑";
            var langle2 = "⟨";
            var lap2 = "⪅";
            var Laplacetrf2 = "ℒ";
            var laquo$12 = "«";
            var larrb2 = "⇤";
            var larrbfs2 = "⤟";
            var larr2 = "←";
            var Larr2 = "↞";
            var lArr2 = "⇐";
            var larrfs2 = "⤝";
            var larrhk2 = "↩";
            var larrlp2 = "↫";
            var larrpl2 = "⤹";
            var larrsim2 = "⥳";
            var larrtl2 = "↢";
            var latail2 = "⤙";
            var lAtail2 = "⤛";
            var lat2 = "⪫";
            var late2 = "⪭";
            var lates2 = "⪭︀";
            var lbarr2 = "⤌";
            var lBarr2 = "⤎";
            var lbbrk2 = "❲";
            var lbrace2 = "{";
            var lbrack2 = "[";
            var lbrke2 = "⦋";
            var lbrksld2 = "⦏";
            var lbrkslu2 = "⦍";
            var Lcaron2 = "Ľ";
            var lcaron2 = "ľ";
            var Lcedil2 = "Ļ";
            var lcedil2 = "ļ";
            var lceil2 = "⌈";
            var lcub2 = "{";
            var Lcy2 = "Л";
            var lcy2 = "л";
            var ldca2 = "⤶";
            var ldquo2 = "“";
            var ldquor2 = "„";
            var ldrdhar2 = "⥧";
            var ldrushar2 = "⥋";
            var ldsh2 = "↲";
            var le2 = "≤";
            var lE2 = "≦";
            var LeftAngleBracket2 = "⟨";
            var LeftArrowBar2 = "⇤";
            var leftarrow2 = "←";
            var LeftArrow2 = "←";
            var Leftarrow2 = "⇐";
            var LeftArrowRightArrow2 = "⇆";
            var leftarrowtail2 = "↢";
            var LeftCeiling2 = "⌈";
            var LeftDoubleBracket2 = "⟦";
            var LeftDownTeeVector2 = "⥡";
            var LeftDownVectorBar2 = "⥙";
            var LeftDownVector2 = "⇃";
            var LeftFloor2 = "⌊";
            var leftharpoondown2 = "↽";
            var leftharpoonup2 = "↼";
            var leftleftarrows2 = "⇇";
            var leftrightarrow2 = "↔";
            var LeftRightArrow2 = "↔";
            var Leftrightarrow2 = "⇔";
            var leftrightarrows2 = "⇆";
            var leftrightharpoons2 = "⇋";
            var leftrightsquigarrow2 = "↭";
            var LeftRightVector2 = "⥎";
            var LeftTeeArrow2 = "↤";
            var LeftTee2 = "⊣";
            var LeftTeeVector2 = "⥚";
            var leftthreetimes2 = "⋋";
            var LeftTriangleBar2 = "⧏";
            var LeftTriangle2 = "⊲";
            var LeftTriangleEqual2 = "⊴";
            var LeftUpDownVector2 = "⥑";
            var LeftUpTeeVector2 = "⥠";
            var LeftUpVectorBar2 = "⥘";
            var LeftUpVector2 = "↿";
            var LeftVectorBar2 = "⥒";
            var LeftVector2 = "↼";
            var lEg2 = "⪋";
            var leg2 = "⋚";
            var leq2 = "≤";
            var leqq2 = "≦";
            var leqslant2 = "⩽";
            var lescc2 = "⪨";
            var les2 = "⩽";
            var lesdot2 = "⩿";
            var lesdoto2 = "⪁";
            var lesdotor2 = "⪃";
            var lesg2 = "⋚︀";
            var lesges2 = "⪓";
            var lessapprox2 = "⪅";
            var lessdot2 = "⋖";
            var lesseqgtr2 = "⋚";
            var lesseqqgtr2 = "⪋";
            var LessEqualGreater2 = "⋚";
            var LessFullEqual2 = "≦";
            var LessGreater2 = "≶";
            var lessgtr2 = "≶";
            var LessLess2 = "⪡";
            var lesssim2 = "≲";
            var LessSlantEqual2 = "⩽";
            var LessTilde2 = "≲";
            var lfisht2 = "⥼";
            var lfloor2 = "⌊";
            var Lfr2 = "𝔏";
            var lfr2 = "𝔩";
            var lg2 = "≶";
            var lgE2 = "⪑";
            var lHar2 = "⥢";
            var lhard2 = "↽";
            var lharu2 = "↼";
            var lharul2 = "⥪";
            var lhblk2 = "▄";
            var LJcy2 = "Љ";
            var ljcy2 = "љ";
            var llarr2 = "⇇";
            var ll2 = "≪";
            var Ll2 = "⋘";
            var llcorner2 = "⌞";
            var Lleftarrow2 = "⇚";
            var llhard2 = "⥫";
            var lltri2 = "◺";
            var Lmidot2 = "Ŀ";
            var lmidot2 = "ŀ";
            var lmoustache2 = "⎰";
            var lmoust2 = "⎰";
            var lnap2 = "⪉";
            var lnapprox2 = "⪉";
            var lne2 = "⪇";
            var lnE2 = "≨";
            var lneq2 = "⪇";
            var lneqq2 = "≨";
            var lnsim2 = "⋦";
            var loang2 = "⟬";
            var loarr2 = "⇽";
            var lobrk2 = "⟦";
            var longleftarrow2 = "⟵";
            var LongLeftArrow2 = "⟵";
            var Longleftarrow2 = "⟸";
            var longleftrightarrow2 = "⟷";
            var LongLeftRightArrow2 = "⟷";
            var Longleftrightarrow2 = "⟺";
            var longmapsto2 = "⟼";
            var longrightarrow2 = "⟶";
            var LongRightArrow2 = "⟶";
            var Longrightarrow2 = "⟹";
            var looparrowleft2 = "↫";
            var looparrowright2 = "↬";
            var lopar2 = "⦅";
            var Lopf2 = "𝕃";
            var lopf2 = "𝕝";
            var loplus2 = "⨭";
            var lotimes2 = "⨴";
            var lowast2 = "∗";
            var lowbar2 = "_";
            var LowerLeftArrow2 = "↙";
            var LowerRightArrow2 = "↘";
            var loz2 = "◊";
            var lozenge2 = "◊";
            var lozf2 = "⧫";
            var lpar2 = "(";
            var lparlt2 = "⦓";
            var lrarr2 = "⇆";
            var lrcorner2 = "⌟";
            var lrhar2 = "⇋";
            var lrhard2 = "⥭";
            var lrm2 = "‎";
            var lrtri2 = "⊿";
            var lsaquo2 = "‹";
            var lscr2 = "𝓁";
            var Lscr2 = "ℒ";
            var lsh2 = "↰";
            var Lsh2 = "↰";
            var lsim2 = "≲";
            var lsime2 = "⪍";
            var lsimg2 = "⪏";
            var lsqb2 = "[";
            var lsquo2 = "‘";
            var lsquor2 = "‚";
            var Lstrok2 = "Ł";
            var lstrok2 = "ł";
            var ltcc2 = "⪦";
            var ltcir2 = "⩹";
            var lt$22 = "<";
            var LT$12 = "<";
            var Lt2 = "≪";
            var ltdot2 = "⋖";
            var lthree2 = "⋋";
            var ltimes2 = "⋉";
            var ltlarr2 = "⥶";
            var ltquest2 = "⩻";
            var ltri2 = "◃";
            var ltrie2 = "⊴";
            var ltrif2 = "◂";
            var ltrPar2 = "⦖";
            var lurdshar2 = "⥊";
            var luruhar2 = "⥦";
            var lvertneqq2 = "≨︀";
            var lvnE2 = "≨︀";
            var macr$12 = "¯";
            var male2 = "♂";
            var malt2 = "✠";
            var maltese2 = "✠";
            var map14 = "↦";
            var mapsto2 = "↦";
            var mapstodown2 = "↧";
            var mapstoleft2 = "↤";
            var mapstoup2 = "↥";
            var marker2 = "▮";
            var mcomma2 = "⨩";
            var Mcy2 = "М";
            var mcy2 = "м";
            var mdash2 = "—";
            var mDDot2 = "∺";
            var measuredangle2 = "∡";
            var MediumSpace2 = " ";
            var Mellintrf2 = "ℳ";
            var Mfr2 = "𝔐";
            var mfr2 = "𝔪";
            var mho2 = "℧";
            var micro$12 = "µ";
            var midast2 = "*";
            var midcir2 = "⫰";
            var mid2 = "∣";
            var middot$12 = "·";
            var minusb2 = "⊟";
            var minus2 = "−";
            var minusd2 = "∸";
            var minusdu2 = "⨪";
            var MinusPlus2 = "∓";
            var mlcp2 = "⫛";
            var mldr2 = "…";
            var mnplus2 = "∓";
            var models2 = "⊧";
            var Mopf2 = "𝕄";
            var mopf2 = "𝕞";
            var mp2 = "∓";
            var mscr2 = "𝓂";
            var Mscr2 = "ℳ";
            var mstpos2 = "∾";
            var Mu2 = "Μ";
            var mu2 = "μ";
            var multimap2 = "⊸";
            var mumap2 = "⊸";
            var nabla2 = "∇";
            var Nacute2 = "Ń";
            var nacute2 = "ń";
            var nang2 = "∠⃒";
            var nap2 = "≉";
            var napE2 = "⩰̸";
            var napid2 = "≋̸";
            var napos2 = "ŉ";
            var napprox2 = "≉";
            var natural2 = "♮";
            var naturals2 = "ℕ";
            var natur2 = "♮";
            var nbsp$12 = " ";
            var nbump2 = "≎̸";
            var nbumpe2 = "≏̸";
            var ncap2 = "⩃";
            var Ncaron2 = "Ň";
            var ncaron2 = "ň";
            var Ncedil2 = "Ņ";
            var ncedil2 = "ņ";
            var ncong2 = "≇";
            var ncongdot2 = "⩭̸";
            var ncup2 = "⩂";
            var Ncy2 = "Н";
            var ncy2 = "н";
            var ndash2 = "–";
            var nearhk2 = "⤤";
            var nearr2 = "↗";
            var neArr2 = "⇗";
            var nearrow2 = "↗";
            var ne2 = "≠";
            var nedot2 = "≐̸";
            var NegativeMediumSpace2 = "​";
            var NegativeThickSpace2 = "​";
            var NegativeThinSpace2 = "​";
            var NegativeVeryThinSpace2 = "​";
            var nequiv2 = "≢";
            var nesear2 = "⤨";
            var nesim2 = "≂̸";
            var NestedGreaterGreater2 = "≫";
            var NestedLessLess2 = "≪";
            var NewLine2 = "\n";
            var nexist2 = "∄";
            var nexists2 = "∄";
            var Nfr2 = "𝔑";
            var nfr2 = "𝔫";
            var ngE2 = "≧̸";
            var nge2 = "≱";
            var ngeq2 = "≱";
            var ngeqq2 = "≧̸";
            var ngeqslant2 = "⩾̸";
            var nges2 = "⩾̸";
            var nGg2 = "⋙̸";
            var ngsim2 = "≵";
            var nGt2 = "≫⃒";
            var ngt2 = "≯";
            var ngtr2 = "≯";
            var nGtv2 = "≫̸";
            var nharr2 = "↮";
            var nhArr2 = "⇎";
            var nhpar2 = "⫲";
            var ni2 = "∋";
            var nis2 = "⋼";
            var nisd2 = "⋺";
            var niv2 = "∋";
            var NJcy2 = "Њ";
            var njcy2 = "њ";
            var nlarr2 = "↚";
            var nlArr2 = "⇍";
            var nldr2 = "‥";
            var nlE2 = "≦̸";
            var nle2 = "≰";
            var nleftarrow2 = "↚";
            var nLeftarrow2 = "⇍";
            var nleftrightarrow2 = "↮";
            var nLeftrightarrow2 = "⇎";
            var nleq2 = "≰";
            var nleqq2 = "≦̸";
            var nleqslant2 = "⩽̸";
            var nles2 = "⩽̸";
            var nless2 = "≮";
            var nLl2 = "⋘̸";
            var nlsim2 = "≴";
            var nLt2 = "≪⃒";
            var nlt2 = "≮";
            var nltri2 = "⋪";
            var nltrie2 = "⋬";
            var nLtv2 = "≪̸";
            var nmid2 = "∤";
            var NoBreak2 = "⁠";
            var NonBreakingSpace2 = " ";
            var nopf2 = "𝕟";
            var Nopf2 = "ℕ";
            var Not2 = "⫬";
            var not$12 = "¬";
            var NotCongruent2 = "≢";
            var NotCupCap2 = "≭";
            var NotDoubleVerticalBar2 = "∦";
            var NotElement2 = "∉";
            var NotEqual2 = "≠";
            var NotEqualTilde2 = "≂̸";
            var NotExists2 = "∄";
            var NotGreater2 = "≯";
            var NotGreaterEqual2 = "≱";
            var NotGreaterFullEqual2 = "≧̸";
            var NotGreaterGreater2 = "≫̸";
            var NotGreaterLess2 = "≹";
            var NotGreaterSlantEqual2 = "⩾̸";
            var NotGreaterTilde2 = "≵";
            var NotHumpDownHump2 = "≎̸";
            var NotHumpEqual2 = "≏̸";
            var notin2 = "∉";
            var notindot2 = "⋵̸";
            var notinE2 = "⋹̸";
            var notinva2 = "∉";
            var notinvb2 = "⋷";
            var notinvc2 = "⋶";
            var NotLeftTriangleBar2 = "⧏̸";
            var NotLeftTriangle2 = "⋪";
            var NotLeftTriangleEqual2 = "⋬";
            var NotLess2 = "≮";
            var NotLessEqual2 = "≰";
            var NotLessGreater2 = "≸";
            var NotLessLess2 = "≪̸";
            var NotLessSlantEqual2 = "⩽̸";
            var NotLessTilde2 = "≴";
            var NotNestedGreaterGreater2 = "⪢̸";
            var NotNestedLessLess2 = "⪡̸";
            var notni2 = "∌";
            var notniva2 = "∌";
            var notnivb2 = "⋾";
            var notnivc2 = "⋽";
            var NotPrecedes2 = "⊀";
            var NotPrecedesEqual2 = "⪯̸";
            var NotPrecedesSlantEqual2 = "⋠";
            var NotReverseElement2 = "∌";
            var NotRightTriangleBar2 = "⧐̸";
            var NotRightTriangle2 = "⋫";
            var NotRightTriangleEqual2 = "⋭";
            var NotSquareSubset2 = "⊏̸";
            var NotSquareSubsetEqual2 = "⋢";
            var NotSquareSuperset2 = "⊐̸";
            var NotSquareSupersetEqual2 = "⋣";
            var NotSubset2 = "⊂⃒";
            var NotSubsetEqual2 = "⊈";
            var NotSucceeds2 = "⊁";
            var NotSucceedsEqual2 = "⪰̸";
            var NotSucceedsSlantEqual2 = "⋡";
            var NotSucceedsTilde2 = "≿̸";
            var NotSuperset2 = "⊃⃒";
            var NotSupersetEqual2 = "⊉";
            var NotTilde2 = "≁";
            var NotTildeEqual2 = "≄";
            var NotTildeFullEqual2 = "≇";
            var NotTildeTilde2 = "≉";
            var NotVerticalBar2 = "∤";
            var nparallel2 = "∦";
            var npar2 = "∦";
            var nparsl2 = "⫽⃥";
            var npart2 = "∂̸";
            var npolint2 = "⨔";
            var npr2 = "⊀";
            var nprcue2 = "⋠";
            var nprec2 = "⊀";
            var npreceq2 = "⪯̸";
            var npre2 = "⪯̸";
            var nrarrc2 = "⤳̸";
            var nrarr2 = "↛";
            var nrArr2 = "⇏";
            var nrarrw2 = "↝̸";
            var nrightarrow2 = "↛";
            var nRightarrow2 = "⇏";
            var nrtri2 = "⋫";
            var nrtrie2 = "⋭";
            var nsc2 = "⊁";
            var nsccue2 = "⋡";
            var nsce2 = "⪰̸";
            var Nscr2 = "𝒩";
            var nscr2 = "𝓃";
            var nshortmid2 = "∤";
            var nshortparallel2 = "∦";
            var nsim2 = "≁";
            var nsime2 = "≄";
            var nsimeq2 = "≄";
            var nsmid2 = "∤";
            var nspar2 = "∦";
            var nsqsube2 = "⋢";
            var nsqsupe2 = "⋣";
            var nsub2 = "⊄";
            var nsubE2 = "⫅̸";
            var nsube2 = "⊈";
            var nsubset2 = "⊂⃒";
            var nsubseteq2 = "⊈";
            var nsubseteqq2 = "⫅̸";
            var nsucc2 = "⊁";
            var nsucceq2 = "⪰̸";
            var nsup2 = "⊅";
            var nsupE2 = "⫆̸";
            var nsupe2 = "⊉";
            var nsupset2 = "⊃⃒";
            var nsupseteq2 = "⊉";
            var nsupseteqq2 = "⫆̸";
            var ntgl2 = "≹";
            var Ntilde$12 = "Ñ";
            var ntilde$12 = "ñ";
            var ntlg2 = "≸";
            var ntriangleleft2 = "⋪";
            var ntrianglelefteq2 = "⋬";
            var ntriangleright2 = "⋫";
            var ntrianglerighteq2 = "⋭";
            var Nu2 = "Ν";
            var nu2 = "ν";
            var num2 = "#";
            var numero2 = "№";
            var numsp2 = " ";
            var nvap2 = "≍⃒";
            var nvdash2 = "⊬";
            var nvDash2 = "⊭";
            var nVdash2 = "⊮";
            var nVDash2 = "⊯";
            var nvge2 = "≥⃒";
            var nvgt2 = ">⃒";
            var nvHarr2 = "⤄";
            var nvinfin2 = "⧞";
            var nvlArr2 = "⤂";
            var nvle2 = "≤⃒";
            var nvlt2 = "<⃒";
            var nvltrie2 = "⊴⃒";
            var nvrArr2 = "⤃";
            var nvrtrie2 = "⊵⃒";
            var nvsim2 = "∼⃒";
            var nwarhk2 = "⤣";
            var nwarr2 = "↖";
            var nwArr2 = "⇖";
            var nwarrow2 = "↖";
            var nwnear2 = "⤧";
            var Oacute$12 = "Ó";
            var oacute$12 = "ó";
            var oast2 = "⊛";
            var Ocirc$12 = "Ô";
            var ocirc$12 = "ô";
            var ocir2 = "⊚";
            var Ocy2 = "О";
            var ocy2 = "о";
            var odash2 = "⊝";
            var Odblac2 = "Ő";
            var odblac2 = "ő";
            var odiv2 = "⨸";
            var odot2 = "⊙";
            var odsold2 = "⦼";
            var OElig2 = "Œ";
            var oelig2 = "œ";
            var ofcir2 = "⦿";
            var Ofr2 = "𝔒";
            var ofr2 = "𝔬";
            var ogon2 = "˛";
            var Ograve$12 = "Ò";
            var ograve$12 = "ò";
            var ogt2 = "⧁";
            var ohbar2 = "⦵";
            var ohm2 = "Ω";
            var oint2 = "∮";
            var olarr2 = "↺";
            var olcir2 = "⦾";
            var olcross2 = "⦻";
            var oline2 = "‾";
            var olt2 = "⧀";
            var Omacr2 = "Ō";
            var omacr2 = "ō";
            var Omega2 = "Ω";
            var omega2 = "ω";
            var Omicron2 = "Ο";
            var omicron2 = "ο";
            var omid2 = "⦶";
            var ominus2 = "⊖";
            var Oopf2 = "𝕆";
            var oopf2 = "𝕠";
            var opar2 = "⦷";
            var OpenCurlyDoubleQuote2 = "“";
            var OpenCurlyQuote2 = "‘";
            var operp2 = "⦹";
            var oplus2 = "⊕";
            var orarr2 = "↻";
            var Or2 = "⩔";
            var or2 = "∨";
            var ord2 = "⩝";
            var order2 = "ℴ";
            var orderof2 = "ℴ";
            var ordf$12 = "ª";
            var ordm$12 = "º";
            var origof2 = "⊶";
            var oror2 = "⩖";
            var orslope2 = "⩗";
            var orv2 = "⩛";
            var oS2 = "Ⓢ";
            var Oscr2 = "𝒪";
            var oscr2 = "ℴ";
            var Oslash$12 = "Ø";
            var oslash$12 = "ø";
            var osol2 = "⊘";
            var Otilde$12 = "Õ";
            var otilde$12 = "õ";
            var otimesas2 = "⨶";
            var Otimes2 = "⨷";
            var otimes2 = "⊗";
            var Ouml$12 = "Ö";
            var ouml$12 = "ö";
            var ovbar2 = "⌽";
            var OverBar2 = "‾";
            var OverBrace2 = "⏞";
            var OverBracket2 = "⎴";
            var OverParenthesis2 = "⏜";
            var para$12 = "¶";
            var parallel2 = "∥";
            var par2 = "∥";
            var parsim2 = "⫳";
            var parsl2 = "⫽";
            var part2 = "∂";
            var PartialD2 = "∂";
            var Pcy2 = "П";
            var pcy2 = "п";
            var percnt2 = "%";
            var period2 = ".";
            var permil2 = "‰";
            var perp2 = "⊥";
            var pertenk2 = "‱";
            var Pfr2 = "𝔓";
            var pfr2 = "𝔭";
            var Phi2 = "Φ";
            var phi2 = "φ";
            var phiv2 = "ϕ";
            var phmmat2 = "ℳ";
            var phone2 = "☎";
            var Pi2 = "Π";
            var pi2 = "π";
            var pitchfork2 = "⋔";
            var piv2 = "ϖ";
            var planck2 = "ℏ";
            var planckh2 = "ℎ";
            var plankv2 = "ℏ";
            var plusacir2 = "⨣";
            var plusb2 = "⊞";
            var pluscir2 = "⨢";
            var plus2 = "+";
            var plusdo2 = "∔";
            var plusdu2 = "⨥";
            var pluse2 = "⩲";
            var PlusMinus2 = "±";
            var plusmn$12 = "±";
            var plussim2 = "⨦";
            var plustwo2 = "⨧";
            var pm2 = "±";
            var Poincareplane2 = "ℌ";
            var pointint2 = "⨕";
            var popf2 = "𝕡";
            var Popf2 = "ℙ";
            var pound$12 = "£";
            var prap2 = "⪷";
            var Pr2 = "⪻";
            var pr2 = "≺";
            var prcue2 = "≼";
            var precapprox2 = "⪷";
            var prec2 = "≺";
            var preccurlyeq2 = "≼";
            var Precedes2 = "≺";
            var PrecedesEqual2 = "⪯";
            var PrecedesSlantEqual2 = "≼";
            var PrecedesTilde2 = "≾";
            var preceq2 = "⪯";
            var precnapprox2 = "⪹";
            var precneqq2 = "⪵";
            var precnsim2 = "⋨";
            var pre2 = "⪯";
            var prE2 = "⪳";
            var precsim2 = "≾";
            var prime2 = "′";
            var Prime2 = "″";
            var primes2 = "ℙ";
            var prnap2 = "⪹";
            var prnE2 = "⪵";
            var prnsim2 = "⋨";
            var prod2 = "∏";
            var Product2 = "∏";
            var profalar2 = "⌮";
            var profline2 = "⌒";
            var profsurf2 = "⌓";
            var prop2 = "∝";
            var Proportional2 = "∝";
            var Proportion2 = "∷";
            var propto2 = "∝";
            var prsim2 = "≾";
            var prurel2 = "⊰";
            var Pscr2 = "𝒫";
            var pscr2 = "𝓅";
            var Psi2 = "Ψ";
            var psi2 = "ψ";
            var puncsp2 = " ";
            var Qfr2 = "𝔔";
            var qfr2 = "𝔮";
            var qint2 = "⨌";
            var qopf2 = "𝕢";
            var Qopf2 = "ℚ";
            var qprime2 = "⁗";
            var Qscr2 = "𝒬";
            var qscr2 = "𝓆";
            var quaternions2 = "ℍ";
            var quatint2 = "⨖";
            var quest2 = "?";
            var questeq2 = "≟";
            var quot$22 = '"';
            var QUOT$12 = '"';
            var rAarr2 = "⇛";
            var race2 = "∽̱";
            var Racute2 = "Ŕ";
            var racute2 = "ŕ";
            var radic2 = "√";
            var raemptyv2 = "⦳";
            var rang2 = "⟩";
            var Rang2 = "⟫";
            var rangd2 = "⦒";
            var range2 = "⦥";
            var rangle2 = "⟩";
            var raquo$12 = "»";
            var rarrap2 = "⥵";
            var rarrb2 = "⇥";
            var rarrbfs2 = "⤠";
            var rarrc2 = "⤳";
            var rarr2 = "→";
            var Rarr2 = "↠";
            var rArr2 = "⇒";
            var rarrfs2 = "⤞";
            var rarrhk2 = "↪";
            var rarrlp2 = "↬";
            var rarrpl2 = "⥅";
            var rarrsim2 = "⥴";
            var Rarrtl2 = "⤖";
            var rarrtl2 = "↣";
            var rarrw2 = "↝";
            var ratail2 = "⤚";
            var rAtail2 = "⤜";
            var ratio2 = "∶";
            var rationals2 = "ℚ";
            var rbarr2 = "⤍";
            var rBarr2 = "⤏";
            var RBarr2 = "⤐";
            var rbbrk2 = "❳";
            var rbrace2 = "}";
            var rbrack2 = "]";
            var rbrke2 = "⦌";
            var rbrksld2 = "⦎";
            var rbrkslu2 = "⦐";
            var Rcaron2 = "Ř";
            var rcaron2 = "ř";
            var Rcedil2 = "Ŗ";
            var rcedil2 = "ŗ";
            var rceil2 = "⌉";
            var rcub2 = "}";
            var Rcy2 = "Р";
            var rcy2 = "р";
            var rdca2 = "⤷";
            var rdldhar2 = "⥩";
            var rdquo2 = "”";
            var rdquor2 = "”";
            var rdsh2 = "↳";
            var real2 = "ℜ";
            var realine2 = "ℛ";
            var realpart2 = "ℜ";
            var reals2 = "ℝ";
            var Re2 = "ℜ";
            var rect2 = "▭";
            var reg$12 = "®";
            var REG$12 = "®";
            var ReverseElement2 = "∋";
            var ReverseEquilibrium2 = "⇋";
            var ReverseUpEquilibrium2 = "⥯";
            var rfisht2 = "⥽";
            var rfloor2 = "⌋";
            var rfr2 = "𝔯";
            var Rfr2 = "ℜ";
            var rHar2 = "⥤";
            var rhard2 = "⇁";
            var rharu2 = "⇀";
            var rharul2 = "⥬";
            var Rho2 = "Ρ";
            var rho2 = "ρ";
            var rhov2 = "ϱ";
            var RightAngleBracket2 = "⟩";
            var RightArrowBar2 = "⇥";
            var rightarrow2 = "→";
            var RightArrow2 = "→";
            var Rightarrow2 = "⇒";
            var RightArrowLeftArrow2 = "⇄";
            var rightarrowtail2 = "↣";
            var RightCeiling2 = "⌉";
            var RightDoubleBracket2 = "⟧";
            var RightDownTeeVector2 = "⥝";
            var RightDownVectorBar2 = "⥕";
            var RightDownVector2 = "⇂";
            var RightFloor2 = "⌋";
            var rightharpoondown2 = "⇁";
            var rightharpoonup2 = "⇀";
            var rightleftarrows2 = "⇄";
            var rightleftharpoons2 = "⇌";
            var rightrightarrows2 = "⇉";
            var rightsquigarrow2 = "↝";
            var RightTeeArrow2 = "↦";
            var RightTee2 = "⊢";
            var RightTeeVector2 = "⥛";
            var rightthreetimes2 = "⋌";
            var RightTriangleBar2 = "⧐";
            var RightTriangle2 = "⊳";
            var RightTriangleEqual2 = "⊵";
            var RightUpDownVector2 = "⥏";
            var RightUpTeeVector2 = "⥜";
            var RightUpVectorBar2 = "⥔";
            var RightUpVector2 = "↾";
            var RightVectorBar2 = "⥓";
            var RightVector2 = "⇀";
            var ring2 = "˚";
            var risingdotseq2 = "≓";
            var rlarr2 = "⇄";
            var rlhar2 = "⇌";
            var rlm2 = "‏";
            var rmoustache2 = "⎱";
            var rmoust2 = "⎱";
            var rnmid2 = "⫮";
            var roang2 = "⟭";
            var roarr2 = "⇾";
            var robrk2 = "⟧";
            var ropar2 = "⦆";
            var ropf2 = "𝕣";
            var Ropf2 = "ℝ";
            var roplus2 = "⨮";
            var rotimes2 = "⨵";
            var RoundImplies2 = "⥰";
            var rpar2 = ")";
            var rpargt2 = "⦔";
            var rppolint2 = "⨒";
            var rrarr2 = "⇉";
            var Rrightarrow2 = "⇛";
            var rsaquo2 = "›";
            var rscr2 = "𝓇";
            var Rscr2 = "ℛ";
            var rsh2 = "↱";
            var Rsh2 = "↱";
            var rsqb2 = "]";
            var rsquo2 = "’";
            var rsquor2 = "’";
            var rthree2 = "⋌";
            var rtimes2 = "⋊";
            var rtri2 = "▹";
            var rtrie2 = "⊵";
            var rtrif2 = "▸";
            var rtriltri2 = "⧎";
            var RuleDelayed2 = "⧴";
            var ruluhar2 = "⥨";
            var rx2 = "℞";
            var Sacute2 = "Ś";
            var sacute2 = "ś";
            var sbquo2 = "‚";
            var scap2 = "⪸";
            var Scaron2 = "Š";
            var scaron2 = "š";
            var Sc2 = "⪼";
            var sc2 = "≻";
            var sccue2 = "≽";
            var sce2 = "⪰";
            var scE2 = "⪴";
            var Scedil2 = "Ş";
            var scedil2 = "ş";
            var Scirc2 = "Ŝ";
            var scirc2 = "ŝ";
            var scnap2 = "⪺";
            var scnE2 = "⪶";
            var scnsim2 = "⋩";
            var scpolint2 = "⨓";
            var scsim2 = "≿";
            var Scy2 = "С";
            var scy2 = "с";
            var sdotb2 = "⊡";
            var sdot2 = "⋅";
            var sdote2 = "⩦";
            var searhk2 = "⤥";
            var searr2 = "↘";
            var seArr2 = "⇘";
            var searrow2 = "↘";
            var sect$12 = "§";
            var semi2 = ";";
            var seswar2 = "⤩";
            var setminus2 = "∖";
            var setmn2 = "∖";
            var sext2 = "✶";
            var Sfr2 = "𝔖";
            var sfr2 = "𝔰";
            var sfrown2 = "⌢";
            var sharp2 = "♯";
            var SHCHcy2 = "Щ";
            var shchcy2 = "щ";
            var SHcy2 = "Ш";
            var shcy2 = "ш";
            var ShortDownArrow2 = "↓";
            var ShortLeftArrow2 = "←";
            var shortmid2 = "∣";
            var shortparallel2 = "∥";
            var ShortRightArrow2 = "→";
            var ShortUpArrow2 = "↑";
            var shy$12 = "­";
            var Sigma2 = "Σ";
            var sigma2 = "σ";
            var sigmaf2 = "ς";
            var sigmav2 = "ς";
            var sim2 = "∼";
            var simdot2 = "⩪";
            var sime2 = "≃";
            var simeq2 = "≃";
            var simg2 = "⪞";
            var simgE2 = "⪠";
            var siml2 = "⪝";
            var simlE2 = "⪟";
            var simne2 = "≆";
            var simplus2 = "⨤";
            var simrarr2 = "⥲";
            var slarr2 = "←";
            var SmallCircle2 = "∘";
            var smallsetminus2 = "∖";
            var smashp2 = "⨳";
            var smeparsl2 = "⧤";
            var smid2 = "∣";
            var smile2 = "⌣";
            var smt2 = "⪪";
            var smte2 = "⪬";
            var smtes2 = "⪬︀";
            var SOFTcy2 = "Ь";
            var softcy2 = "ь";
            var solbar2 = "⌿";
            var solb2 = "⧄";
            var sol2 = "/";
            var Sopf2 = "𝕊";
            var sopf2 = "𝕤";
            var spades2 = "♠";
            var spadesuit2 = "♠";
            var spar2 = "∥";
            var sqcap2 = "⊓";
            var sqcaps2 = "⊓︀";
            var sqcup2 = "⊔";
            var sqcups2 = "⊔︀";
            var Sqrt2 = "√";
            var sqsub2 = "⊏";
            var sqsube2 = "⊑";
            var sqsubset2 = "⊏";
            var sqsubseteq2 = "⊑";
            var sqsup2 = "⊐";
            var sqsupe2 = "⊒";
            var sqsupset2 = "⊐";
            var sqsupseteq2 = "⊒";
            var square2 = "□";
            var Square2 = "□";
            var SquareIntersection2 = "⊓";
            var SquareSubset2 = "⊏";
            var SquareSubsetEqual2 = "⊑";
            var SquareSuperset2 = "⊐";
            var SquareSupersetEqual2 = "⊒";
            var SquareUnion2 = "⊔";
            var squarf2 = "▪";
            var squ2 = "□";
            var squf2 = "▪";
            var srarr2 = "→";
            var Sscr2 = "𝒮";
            var sscr2 = "𝓈";
            var ssetmn2 = "∖";
            var ssmile2 = "⌣";
            var sstarf2 = "⋆";
            var Star2 = "⋆";
            var star2 = "☆";
            var starf2 = "★";
            var straightepsilon2 = "ϵ";
            var straightphi2 = "ϕ";
            var strns2 = "¯";
            var sub2 = "⊂";
            var Sub2 = "⋐";
            var subdot2 = "⪽";
            var subE2 = "⫅";
            var sube2 = "⊆";
            var subedot2 = "⫃";
            var submult2 = "⫁";
            var subnE2 = "⫋";
            var subne2 = "⊊";
            var subplus2 = "⪿";
            var subrarr2 = "⥹";
            var subset2 = "⊂";
            var Subset2 = "⋐";
            var subseteq2 = "⊆";
            var subseteqq2 = "⫅";
            var SubsetEqual2 = "⊆";
            var subsetneq2 = "⊊";
            var subsetneqq2 = "⫋";
            var subsim2 = "⫇";
            var subsub2 = "⫕";
            var subsup2 = "⫓";
            var succapprox2 = "⪸";
            var succ2 = "≻";
            var succcurlyeq2 = "≽";
            var Succeeds2 = "≻";
            var SucceedsEqual2 = "⪰";
            var SucceedsSlantEqual2 = "≽";
            var SucceedsTilde2 = "≿";
            var succeq2 = "⪰";
            var succnapprox2 = "⪺";
            var succneqq2 = "⪶";
            var succnsim2 = "⋩";
            var succsim2 = "≿";
            var SuchThat2 = "∋";
            var sum2 = "∑";
            var Sum2 = "∑";
            var sung2 = "♪";
            var sup1$12 = "¹";
            var sup2$12 = "²";
            var sup3$12 = "³";
            var sup4 = "⊃";
            var Sup2 = "⋑";
            var supdot2 = "⪾";
            var supdsub2 = "⫘";
            var supE2 = "⫆";
            var supe2 = "⊇";
            var supedot2 = "⫄";
            var Superset2 = "⊃";
            var SupersetEqual2 = "⊇";
            var suphsol2 = "⟉";
            var suphsub2 = "⫗";
            var suplarr2 = "⥻";
            var supmult2 = "⫂";
            var supnE2 = "⫌";
            var supne2 = "⊋";
            var supplus2 = "⫀";
            var supset2 = "⊃";
            var Supset2 = "⋑";
            var supseteq2 = "⊇";
            var supseteqq2 = "⫆";
            var supsetneq2 = "⊋";
            var supsetneqq2 = "⫌";
            var supsim2 = "⫈";
            var supsub2 = "⫔";
            var supsup2 = "⫖";
            var swarhk2 = "⤦";
            var swarr2 = "↙";
            var swArr2 = "⇙";
            var swarrow2 = "↙";
            var swnwar2 = "⤪";
            var szlig$12 = "ß";
            var Tab2 = "	";
            var target2 = "⌖";
            var Tau2 = "Τ";
            var tau2 = "τ";
            var tbrk2 = "⎴";
            var Tcaron2 = "Ť";
            var tcaron2 = "ť";
            var Tcedil2 = "Ţ";
            var tcedil2 = "ţ";
            var Tcy2 = "Т";
            var tcy2 = "т";
            var tdot2 = "⃛";
            var telrec2 = "⌕";
            var Tfr2 = "𝔗";
            var tfr2 = "𝔱";
            var there42 = "∴";
            var therefore2 = "∴";
            var Therefore2 = "∴";
            var Theta2 = "Θ";
            var theta2 = "θ";
            var thetasym2 = "ϑ";
            var thetav2 = "ϑ";
            var thickapprox2 = "≈";
            var thicksim2 = "∼";
            var ThickSpace2 = "  ";
            var ThinSpace2 = " ";
            var thinsp2 = " ";
            var thkap2 = "≈";
            var thksim2 = "∼";
            var THORN$12 = "Þ";
            var thorn$12 = "þ";
            var tilde2 = "˜";
            var Tilde2 = "∼";
            var TildeEqual2 = "≃";
            var TildeFullEqual2 = "≅";
            var TildeTilde2 = "≈";
            var timesbar2 = "⨱";
            var timesb2 = "⊠";
            var times$12 = "×";
            var timesd2 = "⨰";
            var tint2 = "∭";
            var toea2 = "⤨";
            var topbot2 = "⌶";
            var topcir2 = "⫱";
            var esm_top = "⊤";
            var Topf2 = "𝕋";
            var topf2 = "𝕥";
            var topfork2 = "⫚";
            var tosa2 = "⤩";
            var tprime2 = "‴";
            var trade2 = "™";
            var TRADE2 = "™";
            var triangle2 = "▵";
            var triangledown2 = "▿";
            var triangleleft2 = "◃";
            var trianglelefteq2 = "⊴";
            var triangleq2 = "≜";
            var triangleright2 = "▹";
            var trianglerighteq2 = "⊵";
            var tridot2 = "◬";
            var trie2 = "≜";
            var triminus2 = "⨺";
            var TripleDot2 = "⃛";
            var triplus2 = "⨹";
            var trisb2 = "⧍";
            var tritime2 = "⨻";
            var trpezium2 = "⏢";
            var Tscr2 = "𝒯";
            var tscr2 = "𝓉";
            var TScy2 = "Ц";
            var tscy2 = "ц";
            var TSHcy2 = "Ћ";
            var tshcy2 = "ћ";
            var Tstrok2 = "Ŧ";
            var tstrok2 = "ŧ";
            var twixt2 = "≬";
            var twoheadleftarrow2 = "↞";
            var twoheadrightarrow2 = "↠";
            var Uacute$12 = "Ú";
            var uacute$12 = "ú";
            var uarr2 = "↑";
            var Uarr2 = "↟";
            var uArr2 = "⇑";
            var Uarrocir2 = "⥉";
            var Ubrcy2 = "Ў";
            var ubrcy2 = "ў";
            var Ubreve2 = "Ŭ";
            var ubreve2 = "ŭ";
            var Ucirc$12 = "Û";
            var ucirc$12 = "û";
            var Ucy2 = "У";
            var ucy2 = "у";
            var udarr2 = "⇅";
            var Udblac2 = "Ű";
            var udblac2 = "ű";
            var udhar2 = "⥮";
            var ufisht2 = "⥾";
            var Ufr2 = "𝔘";
            var ufr2 = "𝔲";
            var Ugrave$12 = "Ù";
            var ugrave$12 = "ù";
            var uHar2 = "⥣";
            var uharl2 = "↿";
            var uharr2 = "↾";
            var uhblk2 = "▀";
            var ulcorn2 = "⌜";
            var ulcorner2 = "⌜";
            var ulcrop2 = "⌏";
            var ultri2 = "◸";
            var Umacr2 = "Ū";
            var umacr2 = "ū";
            var uml$12 = "¨";
            var UnderBar2 = "_";
            var UnderBrace2 = "⏟";
            var UnderBracket2 = "⎵";
            var UnderParenthesis2 = "⏝";
            var Union2 = "⋃";
            var UnionPlus2 = "⊎";
            var Uogon2 = "Ų";
            var uogon2 = "ų";
            var Uopf2 = "𝕌";
            var uopf2 = "𝕦";
            var UpArrowBar2 = "⤒";
            var uparrow2 = "↑";
            var UpArrow2 = "↑";
            var Uparrow2 = "⇑";
            var UpArrowDownArrow2 = "⇅";
            var updownarrow2 = "↕";
            var UpDownArrow2 = "↕";
            var Updownarrow2 = "⇕";
            var UpEquilibrium2 = "⥮";
            var upharpoonleft2 = "↿";
            var upharpoonright2 = "↾";
            var uplus2 = "⊎";
            var UpperLeftArrow2 = "↖";
            var UpperRightArrow2 = "↗";
            var upsi2 = "υ";
            var Upsi2 = "ϒ";
            var upsih2 = "ϒ";
            var Upsilon2 = "Υ";
            var upsilon2 = "υ";
            var UpTeeArrow2 = "↥";
            var UpTee2 = "⊥";
            var upuparrows2 = "⇈";
            var urcorn2 = "⌝";
            var urcorner2 = "⌝";
            var urcrop2 = "⌎";
            var Uring2 = "Ů";
            var uring2 = "ů";
            var urtri2 = "◹";
            var Uscr2 = "𝒰";
            var uscr2 = "𝓊";
            var utdot2 = "⋰";
            var Utilde2 = "Ũ";
            var utilde2 = "ũ";
            var utri2 = "▵";
            var utrif2 = "▴";
            var uuarr2 = "⇈";
            var Uuml$12 = "Ü";
            var uuml$12 = "ü";
            var uwangle2 = "⦧";
            var vangrt2 = "⦜";
            var varepsilon2 = "ϵ";
            var varkappa2 = "ϰ";
            var varnothing2 = "∅";
            var varphi2 = "ϕ";
            var varpi2 = "ϖ";
            var varpropto2 = "∝";
            var varr2 = "↕";
            var vArr2 = "⇕";
            var varrho2 = "ϱ";
            var varsigma2 = "ς";
            var varsubsetneq2 = "⊊︀";
            var varsubsetneqq2 = "⫋︀";
            var varsupsetneq2 = "⊋︀";
            var varsupsetneqq2 = "⫌︀";
            var vartheta2 = "ϑ";
            var vartriangleleft2 = "⊲";
            var vartriangleright2 = "⊳";
            var vBar2 = "⫨";
            var Vbar2 = "⫫";
            var vBarv2 = "⫩";
            var Vcy2 = "В";
            var vcy2 = "в";
            var vdash2 = "⊢";
            var vDash2 = "⊨";
            var Vdash2 = "⊩";
            var VDash2 = "⊫";
            var Vdashl2 = "⫦";
            var veebar2 = "⊻";
            var vee2 = "∨";
            var Vee2 = "⋁";
            var veeeq2 = "≚";
            var vellip2 = "⋮";
            var verbar2 = "|";
            var Verbar2 = "‖";
            var vert2 = "|";
            var Vert2 = "‖";
            var VerticalBar2 = "∣";
            var VerticalLine2 = "|";
            var VerticalSeparator2 = "❘";
            var VerticalTilde2 = "≀";
            var VeryThinSpace2 = " ";
            var Vfr2 = "𝔙";
            var vfr2 = "𝔳";
            var vltri2 = "⊲";
            var vnsub2 = "⊂⃒";
            var vnsup2 = "⊃⃒";
            var Vopf2 = "𝕍";
            var vopf2 = "𝕧";
            var vprop2 = "∝";
            var vrtri2 = "⊳";
            var Vscr2 = "𝒱";
            var vscr2 = "𝓋";
            var vsubnE2 = "⫋︀";
            var vsubne2 = "⊊︀";
            var vsupnE2 = "⫌︀";
            var vsupne2 = "⊋︀";
            var Vvdash2 = "⊪";
            var vzigzag2 = "⦚";
            var Wcirc2 = "Ŵ";
            var wcirc2 = "ŵ";
            var wedbar2 = "⩟";
            var wedge2 = "∧";
            var Wedge2 = "⋀";
            var wedgeq2 = "≙";
            var weierp2 = "℘";
            var Wfr2 = "𝔚";
            var wfr2 = "𝔴";
            var Wopf2 = "𝕎";
            var wopf2 = "𝕨";
            var wp2 = "℘";
            var wr2 = "≀";
            var wreath2 = "≀";
            var Wscr2 = "𝒲";
            var wscr2 = "𝓌";
            var xcap2 = "⋂";
            var xcirc2 = "◯";
            var xcup2 = "⋃";
            var xdtri2 = "▽";
            var Xfr2 = "𝔛";
            var xfr2 = "𝔵";
            var xharr2 = "⟷";
            var xhArr2 = "⟺";
            var Xi2 = "Ξ";
            var xi2 = "ξ";
            var xlarr2 = "⟵";
            var xlArr2 = "⟸";
            var xmap2 = "⟼";
            var xnis2 = "⋻";
            var xodot2 = "⨀";
            var Xopf2 = "𝕏";
            var xopf2 = "𝕩";
            var xoplus2 = "⨁";
            var xotime2 = "⨂";
            var xrarr2 = "⟶";
            var xrArr2 = "⟹";
            var Xscr2 = "𝒳";
            var xscr2 = "𝓍";
            var xsqcup2 = "⨆";
            var xuplus2 = "⨄";
            var xutri2 = "△";
            var xvee2 = "⋁";
            var xwedge2 = "⋀";
            var Yacute$12 = "Ý";
            var yacute$12 = "ý";
            var YAcy2 = "Я";
            var yacy2 = "я";
            var Ycirc2 = "Ŷ";
            var ycirc2 = "ŷ";
            var Ycy2 = "Ы";
            var ycy2 = "ы";
            var yen$12 = "¥";
            var Yfr2 = "𝔜";
            var yfr2 = "𝔶";
            var YIcy2 = "Ї";
            var yicy2 = "ї";
            var Yopf2 = "𝕐";
            var yopf2 = "𝕪";
            var Yscr2 = "𝒴";
            var yscr2 = "𝓎";
            var YUcy2 = "Ю";
            var yucy2 = "ю";
            var yuml$12 = "ÿ";
            var Yuml2 = "Ÿ";
            var Zacute2 = "Ź";
            var zacute2 = "ź";
            var Zcaron2 = "Ž";
            var zcaron2 = "ž";
            var Zcy2 = "З";
            var zcy2 = "з";
            var Zdot2 = "Ż";
            var zdot2 = "ż";
            var zeetrf2 = "ℨ";
            var ZeroWidthSpace2 = "​";
            var Zeta2 = "Ζ";
            var zeta2 = "ζ";
            var zfr2 = "𝔷";
            var Zfr2 = "ℨ";
            var ZHcy2 = "Ж";
            var zhcy2 = "ж";
            var zigrarr2 = "⇝";
            var zopf2 = "𝕫";
            var Zopf2 = "ℤ";
            var Zscr2 = "𝒵";
            var zscr2 = "𝓏";
            var zwj2 = "‍";
            var zwnj2 = "‌";
            var require$$1$12 = {
              Aacute: Aacute$12,
              aacute: aacute$12,
              Abreve: Abreve2,
              abreve: abreve2,
              ac: ac2,
              acd: acd2,
              acE: acE2,
              Acirc: Acirc$12,
              acirc: acirc$12,
              acute: acute$12,
              Acy: Acy2,
              acy: acy2,
              AElig: AElig$12,
              aelig: aelig$12,
              af: af2,
              Afr: Afr2,
              afr: afr2,
              Agrave: Agrave$12,
              agrave: agrave$12,
              alefsym: alefsym2,
              aleph: aleph2,
              Alpha: Alpha2,
              alpha: alpha2,
              Amacr: Amacr2,
              amacr: amacr2,
              amalg: amalg2,
              amp: amp$22,
              AMP: AMP$12,
              andand: andand2,
              And: And2,
              and: and2,
              andd: andd2,
              andslope: andslope2,
              andv: andv2,
              ang: ang2,
              ange: ange2,
              angle: angle2,
              angmsdaa: angmsdaa2,
              angmsdab: angmsdab2,
              angmsdac: angmsdac2,
              angmsdad: angmsdad2,
              angmsdae: angmsdae2,
              angmsdaf: angmsdaf2,
              angmsdag: angmsdag2,
              angmsdah: angmsdah2,
              angmsd: angmsd2,
              angrt: angrt2,
              angrtvb: angrtvb2,
              angrtvbd: angrtvbd2,
              angsph: angsph2,
              angst: angst2,
              angzarr: angzarr2,
              Aogon: Aogon2,
              aogon: aogon2,
              Aopf: Aopf2,
              aopf: aopf2,
              apacir: apacir2,
              ap: ap2,
              apE: apE2,
              ape: ape2,
              apid: apid2,
              apos: apos$12,
              ApplyFunction: ApplyFunction2,
              approx: approx2,
              approxeq: approxeq2,
              Aring: Aring$12,
              aring: aring$12,
              Ascr: Ascr2,
              ascr: ascr2,
              Assign: Assign2,
              ast: ast2,
              asymp: asymp2,
              asympeq: asympeq2,
              Atilde: Atilde$12,
              atilde: atilde$12,
              Auml: Auml$12,
              auml: auml$12,
              awconint: awconint2,
              awint: awint2,
              backcong: backcong2,
              backepsilon: backepsilon2,
              backprime: backprime2,
              backsim: backsim2,
              backsimeq: backsimeq2,
              Backslash: Backslash2,
              Barv: Barv2,
              barvee: barvee2,
              barwed: barwed2,
              Barwed: Barwed2,
              barwedge: barwedge2,
              bbrk: bbrk2,
              bbrktbrk: bbrktbrk2,
              bcong: bcong2,
              Bcy: Bcy2,
              bcy: bcy2,
              bdquo: bdquo2,
              becaus: becaus2,
              because: because2,
              Because: Because2,
              bemptyv: bemptyv2,
              bepsi: bepsi2,
              bernou: bernou2,
              Bernoullis: Bernoullis2,
              Beta: Beta2,
              beta: beta2,
              beth: beth2,
              between: between2,
              Bfr: Bfr2,
              bfr: bfr2,
              bigcap: bigcap2,
              bigcirc: bigcirc2,
              bigcup: bigcup2,
              bigodot: bigodot2,
              bigoplus: bigoplus2,
              bigotimes: bigotimes2,
              bigsqcup: bigsqcup2,
              bigstar: bigstar2,
              bigtriangledown: bigtriangledown2,
              bigtriangleup: bigtriangleup2,
              biguplus: biguplus2,
              bigvee: bigvee2,
              bigwedge: bigwedge2,
              bkarow: bkarow2,
              blacklozenge: blacklozenge2,
              blacksquare: blacksquare2,
              blacktriangle: blacktriangle2,
              blacktriangledown: blacktriangledown2,
              blacktriangleleft: blacktriangleleft2,
              blacktriangleright: blacktriangleright2,
              blank: blank2,
              blk12: blk122,
              blk14: blk142,
              blk34: blk342,
              block: block2,
              bne: bne2,
              bnequiv: bnequiv2,
              bNot: bNot2,
              bnot: bnot2,
              Bopf: Bopf2,
              bopf: bopf2,
              bot: bot2,
              bottom: bottom2,
              bowtie: bowtie2,
              boxbox: boxbox2,
              boxdl: boxdl2,
              boxdL: boxdL2,
              boxDl: boxDl2,
              boxDL: boxDL2,
              boxdr: boxdr2,
              boxdR: boxdR2,
              boxDr: boxDr2,
              boxDR: boxDR2,
              boxh: boxh2,
              boxH: boxH2,
              boxhd: boxhd2,
              boxHd: boxHd2,
              boxhD: boxhD2,
              boxHD: boxHD2,
              boxhu: boxhu2,
              boxHu: boxHu2,
              boxhU: boxhU2,
              boxHU: boxHU2,
              boxminus: boxminus2,
              boxplus: boxplus2,
              boxtimes: boxtimes2,
              boxul: boxul2,
              boxuL: boxuL2,
              boxUl: boxUl2,
              boxUL: boxUL2,
              boxur: boxur2,
              boxuR: boxuR2,
              boxUr: boxUr2,
              boxUR: boxUR2,
              boxv: boxv2,
              boxV: boxV2,
              boxvh: boxvh2,
              boxvH: boxvH2,
              boxVh: boxVh2,
              boxVH: boxVH2,
              boxvl: boxvl2,
              boxvL: boxvL2,
              boxVl: boxVl2,
              boxVL: boxVL2,
              boxvr: boxvr2,
              boxvR: boxvR2,
              boxVr: boxVr2,
              boxVR: boxVR2,
              bprime: bprime2,
              breve: breve2,
              Breve: Breve2,
              brvbar: brvbar$12,
              bscr: bscr2,
              Bscr: Bscr2,
              bsemi: bsemi2,
              bsim: bsim2,
              bsime: bsime2,
              bsolb: bsolb2,
              bsol: bsol2,
              bsolhsub: bsolhsub2,
              bull: bull2,
              bullet: bullet2,
              bump: bump2,
              bumpE: bumpE2,
              bumpe: bumpe2,
              Bumpeq: Bumpeq2,
              bumpeq: bumpeq2,
              Cacute: Cacute2,
              cacute: cacute2,
              capand: capand2,
              capbrcup: capbrcup2,
              capcap: capcap2,
              cap: cap2,
              Cap: Cap2,
              capcup: capcup2,
              capdot: capdot2,
              CapitalDifferentialD: CapitalDifferentialD2,
              caps: caps2,
              caret: caret2,
              caron: caron2,
              Cayleys: Cayleys2,
              ccaps: ccaps2,
              Ccaron: Ccaron2,
              ccaron: ccaron2,
              Ccedil: Ccedil$12,
              ccedil: ccedil$12,
              Ccirc: Ccirc2,
              ccirc: ccirc2,
              Cconint: Cconint2,
              ccups: ccups2,
              ccupssm: ccupssm2,
              Cdot: Cdot2,
              cdot: cdot2,
              cedil: cedil$12,
              Cedilla: Cedilla2,
              cemptyv: cemptyv2,
              cent: cent$12,
              centerdot: centerdot2,
              CenterDot: CenterDot2,
              cfr: cfr2,
              Cfr: Cfr2,
              CHcy: CHcy2,
              chcy: chcy2,
              check: check3,
              checkmark: checkmark2,
              Chi: Chi2,
              chi: chi2,
              circ: circ2,
              circeq: circeq2,
              circlearrowleft: circlearrowleft2,
              circlearrowright: circlearrowright2,
              circledast: circledast2,
              circledcirc: circledcirc2,
              circleddash: circleddash2,
              CircleDot: CircleDot2,
              circledR: circledR2,
              circledS: circledS2,
              CircleMinus: CircleMinus2,
              CirclePlus: CirclePlus2,
              CircleTimes: CircleTimes2,
              cir: cir2,
              cirE: cirE2,
              cire: cire2,
              cirfnint: cirfnint2,
              cirmid: cirmid2,
              cirscir: cirscir2,
              ClockwiseContourIntegral: ClockwiseContourIntegral2,
              CloseCurlyDoubleQuote: CloseCurlyDoubleQuote2,
              CloseCurlyQuote: CloseCurlyQuote2,
              clubs: clubs2,
              clubsuit: clubsuit2,
              colon: colon2,
              Colon: Colon2,
              Colone: Colone2,
              colone: colone2,
              coloneq: coloneq2,
              comma: comma2,
              commat: commat2,
              comp: comp2,
              compfn: compfn2,
              complement: complement2,
              complexes: complexes2,
              cong: cong2,
              congdot: congdot2,
              Congruent: Congruent2,
              conint: conint2,
              Conint: Conint2,
              ContourIntegral: ContourIntegral2,
              copf: copf2,
              Copf: Copf2,
              coprod: coprod2,
              Coproduct: Coproduct2,
              copy: copy$12,
              COPY: COPY$12,
              copysr: copysr2,
              CounterClockwiseContourIntegral: CounterClockwiseContourIntegral2,
              crarr: crarr2,
              cross: cross2,
              Cross: Cross2,
              Cscr: Cscr2,
              cscr: cscr2,
              csub: csub2,
              csube: csube2,
              csup: csup2,
              csupe: csupe2,
              ctdot: ctdot2,
              cudarrl: cudarrl2,
              cudarrr: cudarrr2,
              cuepr: cuepr2,
              cuesc: cuesc2,
              cularr: cularr2,
              cularrp: cularrp2,
              cupbrcap: cupbrcap2,
              cupcap: cupcap2,
              CupCap: CupCap2,
              cup: cup2,
              Cup: Cup2,
              cupcup: cupcup2,
              cupdot: cupdot2,
              cupor: cupor2,
              cups: cups2,
              curarr: curarr2,
              curarrm: curarrm2,
              curlyeqprec: curlyeqprec2,
              curlyeqsucc: curlyeqsucc2,
              curlyvee: curlyvee2,
              curlywedge: curlywedge2,
              curren: curren$12,
              curvearrowleft: curvearrowleft2,
              curvearrowright: curvearrowright2,
              cuvee: cuvee2,
              cuwed: cuwed2,
              cwconint: cwconint2,
              cwint: cwint2,
              cylcty: cylcty2,
              dagger: dagger2,
              Dagger: Dagger2,
              daleth: daleth2,
              darr: darr2,
              Darr: Darr2,
              dArr: dArr2,
              dash: dash2,
              Dashv: Dashv2,
              dashv: dashv2,
              dbkarow: dbkarow2,
              dblac: dblac2,
              Dcaron: Dcaron2,
              dcaron: dcaron2,
              Dcy: Dcy2,
              dcy: dcy2,
              ddagger: ddagger2,
              ddarr: ddarr2,
              DD: DD2,
              dd: dd2,
              DDotrahd: DDotrahd2,
              ddotseq: ddotseq2,
              deg: deg$12,
              Del: Del2,
              Delta: Delta2,
              delta: delta2,
              demptyv: demptyv2,
              dfisht: dfisht2,
              Dfr: Dfr2,
              dfr: dfr2,
              dHar: dHar2,
              dharl: dharl2,
              dharr: dharr2,
              DiacriticalAcute: DiacriticalAcute2,
              DiacriticalDot: DiacriticalDot2,
              DiacriticalDoubleAcute: DiacriticalDoubleAcute2,
              DiacriticalGrave: DiacriticalGrave2,
              DiacriticalTilde: DiacriticalTilde2,
              diam: diam2,
              diamond: diamond2,
              Diamond: Diamond2,
              diamondsuit: diamondsuit2,
              diams: diams2,
              die: die2,
              DifferentialD: DifferentialD2,
              digamma: digamma2,
              disin: disin2,
              div: div2,
              divide: divide$12,
              divideontimes: divideontimes2,
              divonx: divonx2,
              DJcy: DJcy2,
              djcy: djcy2,
              dlcorn: dlcorn2,
              dlcrop: dlcrop2,
              dollar: dollar2,
              Dopf: Dopf2,
              dopf: dopf2,
              Dot: Dot2,
              dot: dot2,
              DotDot: DotDot2,
              doteq: doteq2,
              doteqdot: doteqdot2,
              DotEqual: DotEqual2,
              dotminus: dotminus2,
              dotplus: dotplus2,
              dotsquare: dotsquare2,
              doublebarwedge: doublebarwedge2,
              DoubleContourIntegral: DoubleContourIntegral2,
              DoubleDot: DoubleDot2,
              DoubleDownArrow: DoubleDownArrow2,
              DoubleLeftArrow: DoubleLeftArrow2,
              DoubleLeftRightArrow: DoubleLeftRightArrow2,
              DoubleLeftTee: DoubleLeftTee2,
              DoubleLongLeftArrow: DoubleLongLeftArrow2,
              DoubleLongLeftRightArrow: DoubleLongLeftRightArrow2,
              DoubleLongRightArrow: DoubleLongRightArrow2,
              DoubleRightArrow: DoubleRightArrow2,
              DoubleRightTee: DoubleRightTee2,
              DoubleUpArrow: DoubleUpArrow2,
              DoubleUpDownArrow: DoubleUpDownArrow2,
              DoubleVerticalBar: DoubleVerticalBar2,
              DownArrowBar: DownArrowBar2,
              downarrow: downarrow2,
              DownArrow: DownArrow2,
              Downarrow: Downarrow2,
              DownArrowUpArrow: DownArrowUpArrow2,
              DownBreve: DownBreve2,
              downdownarrows: downdownarrows2,
              downharpoonleft: downharpoonleft2,
              downharpoonright: downharpoonright2,
              DownLeftRightVector: DownLeftRightVector2,
              DownLeftTeeVector: DownLeftTeeVector2,
              DownLeftVectorBar: DownLeftVectorBar2,
              DownLeftVector: DownLeftVector2,
              DownRightTeeVector: DownRightTeeVector2,
              DownRightVectorBar: DownRightVectorBar2,
              DownRightVector: DownRightVector2,
              DownTeeArrow: DownTeeArrow2,
              DownTee: DownTee2,
              drbkarow: drbkarow2,
              drcorn: drcorn2,
              drcrop: drcrop2,
              Dscr: Dscr2,
              dscr: dscr2,
              DScy: DScy2,
              dscy: dscy2,
              dsol: dsol2,
              Dstrok: Dstrok2,
              dstrok: dstrok2,
              dtdot: dtdot2,
              dtri: dtri2,
              dtrif: dtrif2,
              duarr: duarr2,
              duhar: duhar2,
              dwangle: dwangle2,
              DZcy: DZcy2,
              dzcy: dzcy2,
              dzigrarr: dzigrarr2,
              Eacute: Eacute$12,
              eacute: eacute$12,
              easter: easter2,
              Ecaron: Ecaron2,
              ecaron: ecaron2,
              Ecirc: Ecirc$12,
              ecirc: ecirc$12,
              ecir: ecir2,
              ecolon: ecolon2,
              Ecy: Ecy2,
              ecy: ecy2,
              eDDot: eDDot2,
              Edot: Edot2,
              edot: edot2,
              eDot: eDot2,
              ee: ee2,
              efDot: efDot2,
              Efr: Efr2,
              efr: efr2,
              eg: eg2,
              Egrave: Egrave$12,
              egrave: egrave$12,
              egs: egs2,
              egsdot: egsdot2,
              el: el2,
              Element: Element2,
              elinters: elinters2,
              ell: ell2,
              els: els2,
              elsdot: elsdot2,
              Emacr: Emacr2,
              emacr: emacr2,
              empty: empty3,
              emptyset: emptyset2,
              EmptySmallSquare: EmptySmallSquare2,
              emptyv: emptyv2,
              EmptyVerySmallSquare: EmptyVerySmallSquare2,
              emsp13: emsp132,
              emsp14: emsp142,
              emsp: emsp2,
              ENG: ENG2,
              eng: eng2,
              ensp: ensp2,
              Eogon: Eogon2,
              eogon: eogon2,
              Eopf: Eopf2,
              eopf: eopf2,
              epar: epar2,
              eparsl: eparsl2,
              eplus: eplus2,
              epsi: epsi2,
              Epsilon: Epsilon2,
              epsilon: epsilon2,
              epsiv: epsiv2,
              eqcirc: eqcirc2,
              eqcolon: eqcolon2,
              eqsim: eqsim2,
              eqslantgtr: eqslantgtr2,
              eqslantless: eqslantless2,
              Equal: Equal2,
              equals: equals2,
              EqualTilde: EqualTilde2,
              equest: equest2,
              Equilibrium: Equilibrium2,
              equiv: equiv2,
              equivDD: equivDD2,
              eqvparsl: eqvparsl2,
              erarr: erarr2,
              erDot: erDot2,
              escr: escr2,
              Escr: Escr2,
              esdot: esdot2,
              Esim: Esim2,
              esim: esim2,
              Eta: Eta2,
              eta: eta2,
              ETH: ETH$12,
              eth: eth$12,
              Euml: Euml$12,
              euml: euml$12,
              euro: euro2,
              excl: excl2,
              exist: exist2,
              Exists: Exists2,
              expectation: expectation2,
              exponentiale: exponentiale2,
              ExponentialE: ExponentialE2,
              fallingdotseq: fallingdotseq2,
              Fcy: Fcy2,
              fcy: fcy2,
              female: female2,
              ffilig: ffilig2,
              fflig: fflig2,
              ffllig: ffllig2,
              Ffr: Ffr2,
              ffr: ffr2,
              filig: filig2,
              FilledSmallSquare: FilledSmallSquare2,
              FilledVerySmallSquare: FilledVerySmallSquare2,
              fjlig: fjlig2,
              flat: flat2,
              fllig: fllig2,
              fltns: fltns2,
              fnof: fnof2,
              Fopf: Fopf2,
              fopf: fopf2,
              forall: forall2,
              ForAll: ForAll2,
              fork: fork2,
              forkv: forkv2,
              Fouriertrf: Fouriertrf2,
              fpartint: fpartint2,
              frac12: frac12$12,
              frac13: frac132,
              frac14: frac14$12,
              frac15: frac152,
              frac16: frac162,
              frac18: frac182,
              frac23: frac232,
              frac25: frac252,
              frac34: frac34$12,
              frac35: frac352,
              frac38: frac382,
              frac45: frac452,
              frac56: frac562,
              frac58: frac582,
              frac78: frac782,
              frasl: frasl2,
              frown: frown2,
              fscr: fscr2,
              Fscr: Fscr2,
              gacute: gacute2,
              Gamma: Gamma2,
              gamma: gamma2,
              Gammad: Gammad2,
              gammad: gammad2,
              gap: gap2,
              Gbreve: Gbreve2,
              gbreve: gbreve2,
              Gcedil: Gcedil2,
              Gcirc: Gcirc2,
              gcirc: gcirc2,
              Gcy: Gcy2,
              gcy: gcy2,
              Gdot: Gdot2,
              gdot: gdot2,
              ge: ge2,
              gE: gE2,
              gEl: gEl2,
              gel: gel2,
              geq: geq2,
              geqq: geqq2,
              geqslant: geqslant2,
              gescc: gescc2,
              ges: ges2,
              gesdot: gesdot2,
              gesdoto: gesdoto2,
              gesdotol: gesdotol2,
              gesl: gesl2,
              gesles: gesles2,
              Gfr: Gfr2,
              gfr: gfr2,
              gg: gg2,
              Gg: Gg2,
              ggg: ggg2,
              gimel: gimel2,
              GJcy: GJcy2,
              gjcy: gjcy2,
              gla: gla2,
              gl: gl2,
              glE: glE2,
              glj: glj2,
              gnap: gnap2,
              gnapprox: gnapprox2,
              gne: gne2,
              gnE: gnE2,
              gneq: gneq2,
              gneqq: gneqq2,
              gnsim: gnsim2,
              Gopf: Gopf2,
              gopf: gopf2,
              grave: grave2,
              GreaterEqual: GreaterEqual2,
              GreaterEqualLess: GreaterEqualLess2,
              GreaterFullEqual: GreaterFullEqual2,
              GreaterGreater: GreaterGreater2,
              GreaterLess: GreaterLess2,
              GreaterSlantEqual: GreaterSlantEqual2,
              GreaterTilde: GreaterTilde2,
              Gscr: Gscr2,
              gscr: gscr2,
              gsim: gsim2,
              gsime: gsime2,
              gsiml: gsiml2,
              gtcc: gtcc2,
              gtcir: gtcir2,
              gt: gt$22,
              GT: GT$12,
              Gt: Gt2,
              gtdot: gtdot2,
              gtlPar: gtlPar2,
              gtquest: gtquest2,
              gtrapprox: gtrapprox2,
              gtrarr: gtrarr2,
              gtrdot: gtrdot2,
              gtreqless: gtreqless2,
              gtreqqless: gtreqqless2,
              gtrless: gtrless2,
              gtrsim: gtrsim2,
              gvertneqq: gvertneqq2,
              gvnE: gvnE2,
              Hacek: Hacek2,
              hairsp: hairsp2,
              half: half2,
              hamilt: hamilt2,
              HARDcy: HARDcy2,
              hardcy: hardcy2,
              harrcir: harrcir2,
              harr: harr2,
              hArr: hArr2,
              harrw: harrw2,
              Hat: Hat2,
              hbar: hbar2,
              Hcirc: Hcirc2,
              hcirc: hcirc2,
              hearts: hearts2,
              heartsuit: heartsuit2,
              hellip: hellip2,
              hercon: hercon2,
              hfr: hfr2,
              Hfr: Hfr2,
              HilbertSpace: HilbertSpace2,
              hksearow: hksearow2,
              hkswarow: hkswarow2,
              hoarr: hoarr2,
              homtht: homtht2,
              hookleftarrow: hookleftarrow2,
              hookrightarrow: hookrightarrow2,
              hopf: hopf2,
              Hopf: Hopf2,
              horbar: horbar2,
              HorizontalLine: HorizontalLine2,
              hscr: hscr2,
              Hscr: Hscr2,
              hslash: hslash2,
              Hstrok: Hstrok2,
              hstrok: hstrok2,
              HumpDownHump: HumpDownHump2,
              HumpEqual: HumpEqual2,
              hybull: hybull2,
              hyphen: hyphen2,
              Iacute: Iacute$12,
              iacute: iacute$12,
              ic: ic2,
              Icirc: Icirc$12,
              icirc: icirc$12,
              Icy: Icy2,
              icy: icy2,
              Idot: Idot2,
              IEcy: IEcy2,
              iecy: iecy2,
              iexcl: iexcl$12,
              iff: iff2,
              ifr: ifr2,
              Ifr: Ifr2,
              Igrave: Igrave$12,
              igrave: igrave$12,
              ii: ii2,
              iiiint: iiiint2,
              iiint: iiint2,
              iinfin: iinfin2,
              iiota: iiota2,
              IJlig: IJlig2,
              ijlig: ijlig2,
              Imacr: Imacr2,
              imacr: imacr2,
              image: esm_image,
              ImaginaryI: ImaginaryI2,
              imagline: imagline2,
              imagpart: imagpart2,
              imath: imath2,
              Im: Im2,
              imof: imof2,
              imped: imped2,
              Implies: Implies2,
              incare: incare2,
              "in": "∈",
              infin: infin2,
              infintie: infintie2,
              inodot: inodot2,
              intcal: intcal2,
              int: esm_int,
              Int: Int2,
              integers: integers2,
              Integral: Integral2,
              intercal: intercal2,
              Intersection: Intersection2,
              intlarhk: intlarhk2,
              intprod: intprod2,
              InvisibleComma: InvisibleComma2,
              InvisibleTimes: InvisibleTimes2,
              IOcy: IOcy2,
              iocy: iocy2,
              Iogon: Iogon2,
              iogon: iogon2,
              Iopf: Iopf2,
              iopf: iopf2,
              Iota: Iota2,
              iota: iota2,
              iprod: iprod2,
              iquest: iquest$12,
              iscr: iscr2,
              Iscr: Iscr2,
              isin: isin2,
              isindot: isindot2,
              isinE: isinE2,
              isins: isins2,
              isinsv: isinsv2,
              isinv: isinv2,
              it: it2,
              Itilde: Itilde2,
              itilde: itilde2,
              Iukcy: Iukcy2,
              iukcy: iukcy2,
              Iuml: Iuml$12,
              iuml: iuml$12,
              Jcirc: Jcirc2,
              jcirc: jcirc2,
              Jcy: Jcy2,
              jcy: jcy2,
              Jfr: Jfr2,
              jfr: jfr2,
              jmath: jmath2,
              Jopf: Jopf2,
              jopf: jopf2,
              Jscr: Jscr2,
              jscr: jscr2,
              Jsercy: Jsercy2,
              jsercy: jsercy2,
              Jukcy: Jukcy2,
              jukcy: jukcy2,
              Kappa: Kappa2,
              kappa: kappa2,
              kappav: kappav2,
              Kcedil: Kcedil2,
              kcedil: kcedil2,
              Kcy: Kcy2,
              kcy: kcy2,
              Kfr: Kfr2,
              kfr: kfr2,
              kgreen: kgreen2,
              KHcy: KHcy2,
              khcy: khcy2,
              KJcy: KJcy2,
              kjcy: kjcy2,
              Kopf: Kopf2,
              kopf: kopf2,
              Kscr: Kscr2,
              kscr: kscr2,
              lAarr: lAarr2,
              Lacute: Lacute2,
              lacute: lacute2,
              laemptyv: laemptyv2,
              lagran: lagran2,
              Lambda: Lambda2,
              lambda: lambda2,
              lang: lang2,
              Lang: Lang2,
              langd: langd2,
              langle: langle2,
              lap: lap2,
              Laplacetrf: Laplacetrf2,
              laquo: laquo$12,
              larrb: larrb2,
              larrbfs: larrbfs2,
              larr: larr2,
              Larr: Larr2,
              lArr: lArr2,
              larrfs: larrfs2,
              larrhk: larrhk2,
              larrlp: larrlp2,
              larrpl: larrpl2,
              larrsim: larrsim2,
              larrtl: larrtl2,
              latail: latail2,
              lAtail: lAtail2,
              lat: lat2,
              late: late2,
              lates: lates2,
              lbarr: lbarr2,
              lBarr: lBarr2,
              lbbrk: lbbrk2,
              lbrace: lbrace2,
              lbrack: lbrack2,
              lbrke: lbrke2,
              lbrksld: lbrksld2,
              lbrkslu: lbrkslu2,
              Lcaron: Lcaron2,
              lcaron: lcaron2,
              Lcedil: Lcedil2,
              lcedil: lcedil2,
              lceil: lceil2,
              lcub: lcub2,
              Lcy: Lcy2,
              lcy: lcy2,
              ldca: ldca2,
              ldquo: ldquo2,
              ldquor: ldquor2,
              ldrdhar: ldrdhar2,
              ldrushar: ldrushar2,
              ldsh: ldsh2,
              le: le2,
              lE: lE2,
              LeftAngleBracket: LeftAngleBracket2,
              LeftArrowBar: LeftArrowBar2,
              leftarrow: leftarrow2,
              LeftArrow: LeftArrow2,
              Leftarrow: Leftarrow2,
              LeftArrowRightArrow: LeftArrowRightArrow2,
              leftarrowtail: leftarrowtail2,
              LeftCeiling: LeftCeiling2,
              LeftDoubleBracket: LeftDoubleBracket2,
              LeftDownTeeVector: LeftDownTeeVector2,
              LeftDownVectorBar: LeftDownVectorBar2,
              LeftDownVector: LeftDownVector2,
              LeftFloor: LeftFloor2,
              leftharpoondown: leftharpoondown2,
              leftharpoonup: leftharpoonup2,
              leftleftarrows: leftleftarrows2,
              leftrightarrow: leftrightarrow2,
              LeftRightArrow: LeftRightArrow2,
              Leftrightarrow: Leftrightarrow2,
              leftrightarrows: leftrightarrows2,
              leftrightharpoons: leftrightharpoons2,
              leftrightsquigarrow: leftrightsquigarrow2,
              LeftRightVector: LeftRightVector2,
              LeftTeeArrow: LeftTeeArrow2,
              LeftTee: LeftTee2,
              LeftTeeVector: LeftTeeVector2,
              leftthreetimes: leftthreetimes2,
              LeftTriangleBar: LeftTriangleBar2,
              LeftTriangle: LeftTriangle2,
              LeftTriangleEqual: LeftTriangleEqual2,
              LeftUpDownVector: LeftUpDownVector2,
              LeftUpTeeVector: LeftUpTeeVector2,
              LeftUpVectorBar: LeftUpVectorBar2,
              LeftUpVector: LeftUpVector2,
              LeftVectorBar: LeftVectorBar2,
              LeftVector: LeftVector2,
              lEg: lEg2,
              leg: leg2,
              leq: leq2,
              leqq: leqq2,
              leqslant: leqslant2,
              lescc: lescc2,
              les: les2,
              lesdot: lesdot2,
              lesdoto: lesdoto2,
              lesdotor: lesdotor2,
              lesg: lesg2,
              lesges: lesges2,
              lessapprox: lessapprox2,
              lessdot: lessdot2,
              lesseqgtr: lesseqgtr2,
              lesseqqgtr: lesseqqgtr2,
              LessEqualGreater: LessEqualGreater2,
              LessFullEqual: LessFullEqual2,
              LessGreater: LessGreater2,
              lessgtr: lessgtr2,
              LessLess: LessLess2,
              lesssim: lesssim2,
              LessSlantEqual: LessSlantEqual2,
              LessTilde: LessTilde2,
              lfisht: lfisht2,
              lfloor: lfloor2,
              Lfr: Lfr2,
              lfr: lfr2,
              lg: lg2,
              lgE: lgE2,
              lHar: lHar2,
              lhard: lhard2,
              lharu: lharu2,
              lharul: lharul2,
              lhblk: lhblk2,
              LJcy: LJcy2,
              ljcy: ljcy2,
              llarr: llarr2,
              ll: ll2,
              Ll: Ll2,
              llcorner: llcorner2,
              Lleftarrow: Lleftarrow2,
              llhard: llhard2,
              lltri: lltri2,
              Lmidot: Lmidot2,
              lmidot: lmidot2,
              lmoustache: lmoustache2,
              lmoust: lmoust2,
              lnap: lnap2,
              lnapprox: lnapprox2,
              lne: lne2,
              lnE: lnE2,
              lneq: lneq2,
              lneqq: lneqq2,
              lnsim: lnsim2,
              loang: loang2,
              loarr: loarr2,
              lobrk: lobrk2,
              longleftarrow: longleftarrow2,
              LongLeftArrow: LongLeftArrow2,
              Longleftarrow: Longleftarrow2,
              longleftrightarrow: longleftrightarrow2,
              LongLeftRightArrow: LongLeftRightArrow2,
              Longleftrightarrow: Longleftrightarrow2,
              longmapsto: longmapsto2,
              longrightarrow: longrightarrow2,
              LongRightArrow: LongRightArrow2,
              Longrightarrow: Longrightarrow2,
              looparrowleft: looparrowleft2,
              looparrowright: looparrowright2,
              lopar: lopar2,
              Lopf: Lopf2,
              lopf: lopf2,
              loplus: loplus2,
              lotimes: lotimes2,
              lowast: lowast2,
              lowbar: lowbar2,
              LowerLeftArrow: LowerLeftArrow2,
              LowerRightArrow: LowerRightArrow2,
              loz: loz2,
              lozenge: lozenge2,
              lozf: lozf2,
              lpar: lpar2,
              lparlt: lparlt2,
              lrarr: lrarr2,
              lrcorner: lrcorner2,
              lrhar: lrhar2,
              lrhard: lrhard2,
              lrm: lrm2,
              lrtri: lrtri2,
              lsaquo: lsaquo2,
              lscr: lscr2,
              Lscr: Lscr2,
              lsh: lsh2,
              Lsh: Lsh2,
              lsim: lsim2,
              lsime: lsime2,
              lsimg: lsimg2,
              lsqb: lsqb2,
              lsquo: lsquo2,
              lsquor: lsquor2,
              Lstrok: Lstrok2,
              lstrok: lstrok2,
              ltcc: ltcc2,
              ltcir: ltcir2,
              lt: lt$22,
              LT: LT$12,
              Lt: Lt2,
              ltdot: ltdot2,
              lthree: lthree2,
              ltimes: ltimes2,
              ltlarr: ltlarr2,
              ltquest: ltquest2,
              ltri: ltri2,
              ltrie: ltrie2,
              ltrif: ltrif2,
              ltrPar: ltrPar2,
              lurdshar: lurdshar2,
              luruhar: luruhar2,
              lvertneqq: lvertneqq2,
              lvnE: lvnE2,
              macr: macr$12,
              male: male2,
              malt: malt2,
              maltese: maltese2,
              "Map": "⤅",
              map: map14,
              mapsto: mapsto2,
              mapstodown: mapstodown2,
              mapstoleft: mapstoleft2,
              mapstoup: mapstoup2,
              marker: marker2,
              mcomma: mcomma2,
              Mcy: Mcy2,
              mcy: mcy2,
              mdash: mdash2,
              mDDot: mDDot2,
              measuredangle: measuredangle2,
              MediumSpace: MediumSpace2,
              Mellintrf: Mellintrf2,
              Mfr: Mfr2,
              mfr: mfr2,
              mho: mho2,
              micro: micro$12,
              midast: midast2,
              midcir: midcir2,
              mid: mid2,
              middot: middot$12,
              minusb: minusb2,
              minus: minus2,
              minusd: minusd2,
              minusdu: minusdu2,
              MinusPlus: MinusPlus2,
              mlcp: mlcp2,
              mldr: mldr2,
              mnplus: mnplus2,
              models: models2,
              Mopf: Mopf2,
              mopf: mopf2,
              mp: mp2,
              mscr: mscr2,
              Mscr: Mscr2,
              mstpos: mstpos2,
              Mu: Mu2,
              mu: mu2,
              multimap: multimap2,
              mumap: mumap2,
              nabla: nabla2,
              Nacute: Nacute2,
              nacute: nacute2,
              nang: nang2,
              nap: nap2,
              napE: napE2,
              napid: napid2,
              napos: napos2,
              napprox: napprox2,
              natural: natural2,
              naturals: naturals2,
              natur: natur2,
              nbsp: nbsp$12,
              nbump: nbump2,
              nbumpe: nbumpe2,
              ncap: ncap2,
              Ncaron: Ncaron2,
              ncaron: ncaron2,
              Ncedil: Ncedil2,
              ncedil: ncedil2,
              ncong: ncong2,
              ncongdot: ncongdot2,
              ncup: ncup2,
              Ncy: Ncy2,
              ncy: ncy2,
              ndash: ndash2,
              nearhk: nearhk2,
              nearr: nearr2,
              neArr: neArr2,
              nearrow: nearrow2,
              ne: ne2,
              nedot: nedot2,
              NegativeMediumSpace: NegativeMediumSpace2,
              NegativeThickSpace: NegativeThickSpace2,
              NegativeThinSpace: NegativeThinSpace2,
              NegativeVeryThinSpace: NegativeVeryThinSpace2,
              nequiv: nequiv2,
              nesear: nesear2,
              nesim: nesim2,
              NestedGreaterGreater: NestedGreaterGreater2,
              NestedLessLess: NestedLessLess2,
              NewLine: NewLine2,
              nexist: nexist2,
              nexists: nexists2,
              Nfr: Nfr2,
              nfr: nfr2,
              ngE: ngE2,
              nge: nge2,
              ngeq: ngeq2,
              ngeqq: ngeqq2,
              ngeqslant: ngeqslant2,
              nges: nges2,
              nGg: nGg2,
              ngsim: ngsim2,
              nGt: nGt2,
              ngt: ngt2,
              ngtr: ngtr2,
              nGtv: nGtv2,
              nharr: nharr2,
              nhArr: nhArr2,
              nhpar: nhpar2,
              ni: ni2,
              nis: nis2,
              nisd: nisd2,
              niv: niv2,
              NJcy: NJcy2,
              njcy: njcy2,
              nlarr: nlarr2,
              nlArr: nlArr2,
              nldr: nldr2,
              nlE: nlE2,
              nle: nle2,
              nleftarrow: nleftarrow2,
              nLeftarrow: nLeftarrow2,
              nleftrightarrow: nleftrightarrow2,
              nLeftrightarrow: nLeftrightarrow2,
              nleq: nleq2,
              nleqq: nleqq2,
              nleqslant: nleqslant2,
              nles: nles2,
              nless: nless2,
              nLl: nLl2,
              nlsim: nlsim2,
              nLt: nLt2,
              nlt: nlt2,
              nltri: nltri2,
              nltrie: nltrie2,
              nLtv: nLtv2,
              nmid: nmid2,
              NoBreak: NoBreak2,
              NonBreakingSpace: NonBreakingSpace2,
              nopf: nopf2,
              Nopf: Nopf2,
              Not: Not2,
              not: not$12,
              NotCongruent: NotCongruent2,
              NotCupCap: NotCupCap2,
              NotDoubleVerticalBar: NotDoubleVerticalBar2,
              NotElement: NotElement2,
              NotEqual: NotEqual2,
              NotEqualTilde: NotEqualTilde2,
              NotExists: NotExists2,
              NotGreater: NotGreater2,
              NotGreaterEqual: NotGreaterEqual2,
              NotGreaterFullEqual: NotGreaterFullEqual2,
              NotGreaterGreater: NotGreaterGreater2,
              NotGreaterLess: NotGreaterLess2,
              NotGreaterSlantEqual: NotGreaterSlantEqual2,
              NotGreaterTilde: NotGreaterTilde2,
              NotHumpDownHump: NotHumpDownHump2,
              NotHumpEqual: NotHumpEqual2,
              notin: notin2,
              notindot: notindot2,
              notinE: notinE2,
              notinva: notinva2,
              notinvb: notinvb2,
              notinvc: notinvc2,
              NotLeftTriangleBar: NotLeftTriangleBar2,
              NotLeftTriangle: NotLeftTriangle2,
              NotLeftTriangleEqual: NotLeftTriangleEqual2,
              NotLess: NotLess2,
              NotLessEqual: NotLessEqual2,
              NotLessGreater: NotLessGreater2,
              NotLessLess: NotLessLess2,
              NotLessSlantEqual: NotLessSlantEqual2,
              NotLessTilde: NotLessTilde2,
              NotNestedGreaterGreater: NotNestedGreaterGreater2,
              NotNestedLessLess: NotNestedLessLess2,
              notni: notni2,
              notniva: notniva2,
              notnivb: notnivb2,
              notnivc: notnivc2,
              NotPrecedes: NotPrecedes2,
              NotPrecedesEqual: NotPrecedesEqual2,
              NotPrecedesSlantEqual: NotPrecedesSlantEqual2,
              NotReverseElement: NotReverseElement2,
              NotRightTriangleBar: NotRightTriangleBar2,
              NotRightTriangle: NotRightTriangle2,
              NotRightTriangleEqual: NotRightTriangleEqual2,
              NotSquareSubset: NotSquareSubset2,
              NotSquareSubsetEqual: NotSquareSubsetEqual2,
              NotSquareSuperset: NotSquareSuperset2,
              NotSquareSupersetEqual: NotSquareSupersetEqual2,
              NotSubset: NotSubset2,
              NotSubsetEqual: NotSubsetEqual2,
              NotSucceeds: NotSucceeds2,
              NotSucceedsEqual: NotSucceedsEqual2,
              NotSucceedsSlantEqual: NotSucceedsSlantEqual2,
              NotSucceedsTilde: NotSucceedsTilde2,
              NotSuperset: NotSuperset2,
              NotSupersetEqual: NotSupersetEqual2,
              NotTilde: NotTilde2,
              NotTildeEqual: NotTildeEqual2,
              NotTildeFullEqual: NotTildeFullEqual2,
              NotTildeTilde: NotTildeTilde2,
              NotVerticalBar: NotVerticalBar2,
              nparallel: nparallel2,
              npar: npar2,
              nparsl: nparsl2,
              npart: npart2,
              npolint: npolint2,
              npr: npr2,
              nprcue: nprcue2,
              nprec: nprec2,
              npreceq: npreceq2,
              npre: npre2,
              nrarrc: nrarrc2,
              nrarr: nrarr2,
              nrArr: nrArr2,
              nrarrw: nrarrw2,
              nrightarrow: nrightarrow2,
              nRightarrow: nRightarrow2,
              nrtri: nrtri2,
              nrtrie: nrtrie2,
              nsc: nsc2,
              nsccue: nsccue2,
              nsce: nsce2,
              Nscr: Nscr2,
              nscr: nscr2,
              nshortmid: nshortmid2,
              nshortparallel: nshortparallel2,
              nsim: nsim2,
              nsime: nsime2,
              nsimeq: nsimeq2,
              nsmid: nsmid2,
              nspar: nspar2,
              nsqsube: nsqsube2,
              nsqsupe: nsqsupe2,
              nsub: nsub2,
              nsubE: nsubE2,
              nsube: nsube2,
              nsubset: nsubset2,
              nsubseteq: nsubseteq2,
              nsubseteqq: nsubseteqq2,
              nsucc: nsucc2,
              nsucceq: nsucceq2,
              nsup: nsup2,
              nsupE: nsupE2,
              nsupe: nsupe2,
              nsupset: nsupset2,
              nsupseteq: nsupseteq2,
              nsupseteqq: nsupseteqq2,
              ntgl: ntgl2,
              Ntilde: Ntilde$12,
              ntilde: ntilde$12,
              ntlg: ntlg2,
              ntriangleleft: ntriangleleft2,
              ntrianglelefteq: ntrianglelefteq2,
              ntriangleright: ntriangleright2,
              ntrianglerighteq: ntrianglerighteq2,
              Nu: Nu2,
              nu: nu2,
              num: num2,
              numero: numero2,
              numsp: numsp2,
              nvap: nvap2,
              nvdash: nvdash2,
              nvDash: nvDash2,
              nVdash: nVdash2,
              nVDash: nVDash2,
              nvge: nvge2,
              nvgt: nvgt2,
              nvHarr: nvHarr2,
              nvinfin: nvinfin2,
              nvlArr: nvlArr2,
              nvle: nvle2,
              nvlt: nvlt2,
              nvltrie: nvltrie2,
              nvrArr: nvrArr2,
              nvrtrie: nvrtrie2,
              nvsim: nvsim2,
              nwarhk: nwarhk2,
              nwarr: nwarr2,
              nwArr: nwArr2,
              nwarrow: nwarrow2,
              nwnear: nwnear2,
              Oacute: Oacute$12,
              oacute: oacute$12,
              oast: oast2,
              Ocirc: Ocirc$12,
              ocirc: ocirc$12,
              ocir: ocir2,
              Ocy: Ocy2,
              ocy: ocy2,
              odash: odash2,
              Odblac: Odblac2,
              odblac: odblac2,
              odiv: odiv2,
              odot: odot2,
              odsold: odsold2,
              OElig: OElig2,
              oelig: oelig2,
              ofcir: ofcir2,
              Ofr: Ofr2,
              ofr: ofr2,
              ogon: ogon2,
              Ograve: Ograve$12,
              ograve: ograve$12,
              ogt: ogt2,
              ohbar: ohbar2,
              ohm: ohm2,
              oint: oint2,
              olarr: olarr2,
              olcir: olcir2,
              olcross: olcross2,
              oline: oline2,
              olt: olt2,
              Omacr: Omacr2,
              omacr: omacr2,
              Omega: Omega2,
              omega: omega2,
              Omicron: Omicron2,
              omicron: omicron2,
              omid: omid2,
              ominus: ominus2,
              Oopf: Oopf2,
              oopf: oopf2,
              opar: opar2,
              OpenCurlyDoubleQuote: OpenCurlyDoubleQuote2,
              OpenCurlyQuote: OpenCurlyQuote2,
              operp: operp2,
              oplus: oplus2,
              orarr: orarr2,
              Or: Or2,
              or: or2,
              ord: ord2,
              order: order2,
              orderof: orderof2,
              ordf: ordf$12,
              ordm: ordm$12,
              origof: origof2,
              oror: oror2,
              orslope: orslope2,
              orv: orv2,
              oS: oS2,
              Oscr: Oscr2,
              oscr: oscr2,
              Oslash: Oslash$12,
              oslash: oslash$12,
              osol: osol2,
              Otilde: Otilde$12,
              otilde: otilde$12,
              otimesas: otimesas2,
              Otimes: Otimes2,
              otimes: otimes2,
              Ouml: Ouml$12,
              ouml: ouml$12,
              ovbar: ovbar2,
              OverBar: OverBar2,
              OverBrace: OverBrace2,
              OverBracket: OverBracket2,
              OverParenthesis: OverParenthesis2,
              para: para$12,
              parallel: parallel2,
              par: par2,
              parsim: parsim2,
              parsl: parsl2,
              part: part2,
              PartialD: PartialD2,
              Pcy: Pcy2,
              pcy: pcy2,
              percnt: percnt2,
              period: period2,
              permil: permil2,
              perp: perp2,
              pertenk: pertenk2,
              Pfr: Pfr2,
              pfr: pfr2,
              Phi: Phi2,
              phi: phi2,
              phiv: phiv2,
              phmmat: phmmat2,
              phone: phone2,
              Pi: Pi2,
              pi: pi2,
              pitchfork: pitchfork2,
              piv: piv2,
              planck: planck2,
              planckh: planckh2,
              plankv: plankv2,
              plusacir: plusacir2,
              plusb: plusb2,
              pluscir: pluscir2,
              plus: plus2,
              plusdo: plusdo2,
              plusdu: plusdu2,
              pluse: pluse2,
              PlusMinus: PlusMinus2,
              plusmn: plusmn$12,
              plussim: plussim2,
              plustwo: plustwo2,
              pm: pm2,
              Poincareplane: Poincareplane2,
              pointint: pointint2,
              popf: popf2,
              Popf: Popf2,
              pound: pound$12,
              prap: prap2,
              Pr: Pr2,
              pr: pr2,
              prcue: prcue2,
              precapprox: precapprox2,
              prec: prec2,
              preccurlyeq: preccurlyeq2,
              Precedes: Precedes2,
              PrecedesEqual: PrecedesEqual2,
              PrecedesSlantEqual: PrecedesSlantEqual2,
              PrecedesTilde: PrecedesTilde2,
              preceq: preceq2,
              precnapprox: precnapprox2,
              precneqq: precneqq2,
              precnsim: precnsim2,
              pre: pre2,
              prE: prE2,
              precsim: precsim2,
              prime: prime2,
              Prime: Prime2,
              primes: primes2,
              prnap: prnap2,
              prnE: prnE2,
              prnsim: prnsim2,
              prod: prod2,
              Product: Product2,
              profalar: profalar2,
              profline: profline2,
              profsurf: profsurf2,
              prop: prop2,
              Proportional: Proportional2,
              Proportion: Proportion2,
              propto: propto2,
              prsim: prsim2,
              prurel: prurel2,
              Pscr: Pscr2,
              pscr: pscr2,
              Psi: Psi2,
              psi: psi2,
              puncsp: puncsp2,
              Qfr: Qfr2,
              qfr: qfr2,
              qint: qint2,
              qopf: qopf2,
              Qopf: Qopf2,
              qprime: qprime2,
              Qscr: Qscr2,
              qscr: qscr2,
              quaternions: quaternions2,
              quatint: quatint2,
              quest: quest2,
              questeq: questeq2,
              quot: quot$22,
              QUOT: QUOT$12,
              rAarr: rAarr2,
              race: race2,
              Racute: Racute2,
              racute: racute2,
              radic: radic2,
              raemptyv: raemptyv2,
              rang: rang2,
              Rang: Rang2,
              rangd: rangd2,
              range: range2,
              rangle: rangle2,
              raquo: raquo$12,
              rarrap: rarrap2,
              rarrb: rarrb2,
              rarrbfs: rarrbfs2,
              rarrc: rarrc2,
              rarr: rarr2,
              Rarr: Rarr2,
              rArr: rArr2,
              rarrfs: rarrfs2,
              rarrhk: rarrhk2,
              rarrlp: rarrlp2,
              rarrpl: rarrpl2,
              rarrsim: rarrsim2,
              Rarrtl: Rarrtl2,
              rarrtl: rarrtl2,
              rarrw: rarrw2,
              ratail: ratail2,
              rAtail: rAtail2,
              ratio: ratio2,
              rationals: rationals2,
              rbarr: rbarr2,
              rBarr: rBarr2,
              RBarr: RBarr2,
              rbbrk: rbbrk2,
              rbrace: rbrace2,
              rbrack: rbrack2,
              rbrke: rbrke2,
              rbrksld: rbrksld2,
              rbrkslu: rbrkslu2,
              Rcaron: Rcaron2,
              rcaron: rcaron2,
              Rcedil: Rcedil2,
              rcedil: rcedil2,
              rceil: rceil2,
              rcub: rcub2,
              Rcy: Rcy2,
              rcy: rcy2,
              rdca: rdca2,
              rdldhar: rdldhar2,
              rdquo: rdquo2,
              rdquor: rdquor2,
              rdsh: rdsh2,
              real: real2,
              realine: realine2,
              realpart: realpart2,
              reals: reals2,
              Re: Re2,
              rect: rect2,
              reg: reg$12,
              REG: REG$12,
              ReverseElement: ReverseElement2,
              ReverseEquilibrium: ReverseEquilibrium2,
              ReverseUpEquilibrium: ReverseUpEquilibrium2,
              rfisht: rfisht2,
              rfloor: rfloor2,
              rfr: rfr2,
              Rfr: Rfr2,
              rHar: rHar2,
              rhard: rhard2,
              rharu: rharu2,
              rharul: rharul2,
              Rho: Rho2,
              rho: rho2,
              rhov: rhov2,
              RightAngleBracket: RightAngleBracket2,
              RightArrowBar: RightArrowBar2,
              rightarrow: rightarrow2,
              RightArrow: RightArrow2,
              Rightarrow: Rightarrow2,
              RightArrowLeftArrow: RightArrowLeftArrow2,
              rightarrowtail: rightarrowtail2,
              RightCeiling: RightCeiling2,
              RightDoubleBracket: RightDoubleBracket2,
              RightDownTeeVector: RightDownTeeVector2,
              RightDownVectorBar: RightDownVectorBar2,
              RightDownVector: RightDownVector2,
              RightFloor: RightFloor2,
              rightharpoondown: rightharpoondown2,
              rightharpoonup: rightharpoonup2,
              rightleftarrows: rightleftarrows2,
              rightleftharpoons: rightleftharpoons2,
              rightrightarrows: rightrightarrows2,
              rightsquigarrow: rightsquigarrow2,
              RightTeeArrow: RightTeeArrow2,
              RightTee: RightTee2,
              RightTeeVector: RightTeeVector2,
              rightthreetimes: rightthreetimes2,
              RightTriangleBar: RightTriangleBar2,
              RightTriangle: RightTriangle2,
              RightTriangleEqual: RightTriangleEqual2,
              RightUpDownVector: RightUpDownVector2,
              RightUpTeeVector: RightUpTeeVector2,
              RightUpVectorBar: RightUpVectorBar2,
              RightUpVector: RightUpVector2,
              RightVectorBar: RightVectorBar2,
              RightVector: RightVector2,
              ring: ring2,
              risingdotseq: risingdotseq2,
              rlarr: rlarr2,
              rlhar: rlhar2,
              rlm: rlm2,
              rmoustache: rmoustache2,
              rmoust: rmoust2,
              rnmid: rnmid2,
              roang: roang2,
              roarr: roarr2,
              robrk: robrk2,
              ropar: ropar2,
              ropf: ropf2,
              Ropf: Ropf2,
              roplus: roplus2,
              rotimes: rotimes2,
              RoundImplies: RoundImplies2,
              rpar: rpar2,
              rpargt: rpargt2,
              rppolint: rppolint2,
              rrarr: rrarr2,
              Rrightarrow: Rrightarrow2,
              rsaquo: rsaquo2,
              rscr: rscr2,
              Rscr: Rscr2,
              rsh: rsh2,
              Rsh: Rsh2,
              rsqb: rsqb2,
              rsquo: rsquo2,
              rsquor: rsquor2,
              rthree: rthree2,
              rtimes: rtimes2,
              rtri: rtri2,
              rtrie: rtrie2,
              rtrif: rtrif2,
              rtriltri: rtriltri2,
              RuleDelayed: RuleDelayed2,
              ruluhar: ruluhar2,
              rx: rx2,
              Sacute: Sacute2,
              sacute: sacute2,
              sbquo: sbquo2,
              scap: scap2,
              Scaron: Scaron2,
              scaron: scaron2,
              Sc: Sc2,
              sc: sc2,
              sccue: sccue2,
              sce: sce2,
              scE: scE2,
              Scedil: Scedil2,
              scedil: scedil2,
              Scirc: Scirc2,
              scirc: scirc2,
              scnap: scnap2,
              scnE: scnE2,
              scnsim: scnsim2,
              scpolint: scpolint2,
              scsim: scsim2,
              Scy: Scy2,
              scy: scy2,
              sdotb: sdotb2,
              sdot: sdot2,
              sdote: sdote2,
              searhk: searhk2,
              searr: searr2,
              seArr: seArr2,
              searrow: searrow2,
              sect: sect$12,
              semi: semi2,
              seswar: seswar2,
              setminus: setminus2,
              setmn: setmn2,
              sext: sext2,
              Sfr: Sfr2,
              sfr: sfr2,
              sfrown: sfrown2,
              sharp: sharp2,
              SHCHcy: SHCHcy2,
              shchcy: shchcy2,
              SHcy: SHcy2,
              shcy: shcy2,
              ShortDownArrow: ShortDownArrow2,
              ShortLeftArrow: ShortLeftArrow2,
              shortmid: shortmid2,
              shortparallel: shortparallel2,
              ShortRightArrow: ShortRightArrow2,
              ShortUpArrow: ShortUpArrow2,
              shy: shy$12,
              Sigma: Sigma2,
              sigma: sigma2,
              sigmaf: sigmaf2,
              sigmav: sigmav2,
              sim: sim2,
              simdot: simdot2,
              sime: sime2,
              simeq: simeq2,
              simg: simg2,
              simgE: simgE2,
              siml: siml2,
              simlE: simlE2,
              simne: simne2,
              simplus: simplus2,
              simrarr: simrarr2,
              slarr: slarr2,
              SmallCircle: SmallCircle2,
              smallsetminus: smallsetminus2,
              smashp: smashp2,
              smeparsl: smeparsl2,
              smid: smid2,
              smile: smile2,
              smt: smt2,
              smte: smte2,
              smtes: smtes2,
              SOFTcy: SOFTcy2,
              softcy: softcy2,
              solbar: solbar2,
              solb: solb2,
              sol: sol2,
              Sopf: Sopf2,
              sopf: sopf2,
              spades: spades2,
              spadesuit: spadesuit2,
              spar: spar2,
              sqcap: sqcap2,
              sqcaps: sqcaps2,
              sqcup: sqcup2,
              sqcups: sqcups2,
              Sqrt: Sqrt2,
              sqsub: sqsub2,
              sqsube: sqsube2,
              sqsubset: sqsubset2,
              sqsubseteq: sqsubseteq2,
              sqsup: sqsup2,
              sqsupe: sqsupe2,
              sqsupset: sqsupset2,
              sqsupseteq: sqsupseteq2,
              square: square2,
              Square: Square2,
              SquareIntersection: SquareIntersection2,
              SquareSubset: SquareSubset2,
              SquareSubsetEqual: SquareSubsetEqual2,
              SquareSuperset: SquareSuperset2,
              SquareSupersetEqual: SquareSupersetEqual2,
              SquareUnion: SquareUnion2,
              squarf: squarf2,
              squ: squ2,
              squf: squf2,
              srarr: srarr2,
              Sscr: Sscr2,
              sscr: sscr2,
              ssetmn: ssetmn2,
              ssmile: ssmile2,
              sstarf: sstarf2,
              Star: Star2,
              star: star2,
              starf: starf2,
              straightepsilon: straightepsilon2,
              straightphi: straightphi2,
              strns: strns2,
              sub: sub2,
              Sub: Sub2,
              subdot: subdot2,
              subE: subE2,
              sube: sube2,
              subedot: subedot2,
              submult: submult2,
              subnE: subnE2,
              subne: subne2,
              subplus: subplus2,
              subrarr: subrarr2,
              subset: subset2,
              Subset: Subset2,
              subseteq: subseteq2,
              subseteqq: subseteqq2,
              SubsetEqual: SubsetEqual2,
              subsetneq: subsetneq2,
              subsetneqq: subsetneqq2,
              subsim: subsim2,
              subsub: subsub2,
              subsup: subsup2,
              succapprox: succapprox2,
              succ: succ2,
              succcurlyeq: succcurlyeq2,
              Succeeds: Succeeds2,
              SucceedsEqual: SucceedsEqual2,
              SucceedsSlantEqual: SucceedsSlantEqual2,
              SucceedsTilde: SucceedsTilde2,
              succeq: succeq2,
              succnapprox: succnapprox2,
              succneqq: succneqq2,
              succnsim: succnsim2,
              succsim: succsim2,
              SuchThat: SuchThat2,
              sum: sum2,
              Sum: Sum2,
              sung: sung2,
              sup1: sup1$12,
              sup2: sup2$12,
              sup3: sup3$12,
              sup: sup4,
              Sup: Sup2,
              supdot: supdot2,
              supdsub: supdsub2,
              supE: supE2,
              supe: supe2,
              supedot: supedot2,
              Superset: Superset2,
              SupersetEqual: SupersetEqual2,
              suphsol: suphsol2,
              suphsub: suphsub2,
              suplarr: suplarr2,
              supmult: supmult2,
              supnE: supnE2,
              supne: supne2,
              supplus: supplus2,
              supset: supset2,
              Supset: Supset2,
              supseteq: supseteq2,
              supseteqq: supseteqq2,
              supsetneq: supsetneq2,
              supsetneqq: supsetneqq2,
              supsim: supsim2,
              supsub: supsub2,
              supsup: supsup2,
              swarhk: swarhk2,
              swarr: swarr2,
              swArr: swArr2,
              swarrow: swarrow2,
              swnwar: swnwar2,
              szlig: szlig$12,
              Tab: Tab2,
              target: target2,
              Tau: Tau2,
              tau: tau2,
              tbrk: tbrk2,
              Tcaron: Tcaron2,
              tcaron: tcaron2,
              Tcedil: Tcedil2,
              tcedil: tcedil2,
              Tcy: Tcy2,
              tcy: tcy2,
              tdot: tdot2,
              telrec: telrec2,
              Tfr: Tfr2,
              tfr: tfr2,
              there4: there42,
              therefore: therefore2,
              Therefore: Therefore2,
              Theta: Theta2,
              theta: theta2,
              thetasym: thetasym2,
              thetav: thetav2,
              thickapprox: thickapprox2,
              thicksim: thicksim2,
              ThickSpace: ThickSpace2,
              ThinSpace: ThinSpace2,
              thinsp: thinsp2,
              thkap: thkap2,
              thksim: thksim2,
              THORN: THORN$12,
              thorn: thorn$12,
              tilde: tilde2,
              Tilde: Tilde2,
              TildeEqual: TildeEqual2,
              TildeFullEqual: TildeFullEqual2,
              TildeTilde: TildeTilde2,
              timesbar: timesbar2,
              timesb: timesb2,
              times: times$12,
              timesd: timesd2,
              tint: tint2,
              toea: toea2,
              topbot: topbot2,
              topcir: topcir2,
              top: esm_top,
              Topf: Topf2,
              topf: topf2,
              topfork: topfork2,
              tosa: tosa2,
              tprime: tprime2,
              trade: trade2,
              TRADE: TRADE2,
              triangle: triangle2,
              triangledown: triangledown2,
              triangleleft: triangleleft2,
              trianglelefteq: trianglelefteq2,
              triangleq: triangleq2,
              triangleright: triangleright2,
              trianglerighteq: trianglerighteq2,
              tridot: tridot2,
              trie: trie2,
              triminus: triminus2,
              TripleDot: TripleDot2,
              triplus: triplus2,
              trisb: trisb2,
              tritime: tritime2,
              trpezium: trpezium2,
              Tscr: Tscr2,
              tscr: tscr2,
              TScy: TScy2,
              tscy: tscy2,
              TSHcy: TSHcy2,
              tshcy: tshcy2,
              Tstrok: Tstrok2,
              tstrok: tstrok2,
              twixt: twixt2,
              twoheadleftarrow: twoheadleftarrow2,
              twoheadrightarrow: twoheadrightarrow2,
              Uacute: Uacute$12,
              uacute: uacute$12,
              uarr: uarr2,
              Uarr: Uarr2,
              uArr: uArr2,
              Uarrocir: Uarrocir2,
              Ubrcy: Ubrcy2,
              ubrcy: ubrcy2,
              Ubreve: Ubreve2,
              ubreve: ubreve2,
              Ucirc: Ucirc$12,
              ucirc: ucirc$12,
              Ucy: Ucy2,
              ucy: ucy2,
              udarr: udarr2,
              Udblac: Udblac2,
              udblac: udblac2,
              udhar: udhar2,
              ufisht: ufisht2,
              Ufr: Ufr2,
              ufr: ufr2,
              Ugrave: Ugrave$12,
              ugrave: ugrave$12,
              uHar: uHar2,
              uharl: uharl2,
              uharr: uharr2,
              uhblk: uhblk2,
              ulcorn: ulcorn2,
              ulcorner: ulcorner2,
              ulcrop: ulcrop2,
              ultri: ultri2,
              Umacr: Umacr2,
              umacr: umacr2,
              uml: uml$12,
              UnderBar: UnderBar2,
              UnderBrace: UnderBrace2,
              UnderBracket: UnderBracket2,
              UnderParenthesis: UnderParenthesis2,
              Union: Union2,
              UnionPlus: UnionPlus2,
              Uogon: Uogon2,
              uogon: uogon2,
              Uopf: Uopf2,
              uopf: uopf2,
              UpArrowBar: UpArrowBar2,
              uparrow: uparrow2,
              UpArrow: UpArrow2,
              Uparrow: Uparrow2,
              UpArrowDownArrow: UpArrowDownArrow2,
              updownarrow: updownarrow2,
              UpDownArrow: UpDownArrow2,
              Updownarrow: Updownarrow2,
              UpEquilibrium: UpEquilibrium2,
              upharpoonleft: upharpoonleft2,
              upharpoonright: upharpoonright2,
              uplus: uplus2,
              UpperLeftArrow: UpperLeftArrow2,
              UpperRightArrow: UpperRightArrow2,
              upsi: upsi2,
              Upsi: Upsi2,
              upsih: upsih2,
              Upsilon: Upsilon2,
              upsilon: upsilon2,
              UpTeeArrow: UpTeeArrow2,
              UpTee: UpTee2,
              upuparrows: upuparrows2,
              urcorn: urcorn2,
              urcorner: urcorner2,
              urcrop: urcrop2,
              Uring: Uring2,
              uring: uring2,
              urtri: urtri2,
              Uscr: Uscr2,
              uscr: uscr2,
              utdot: utdot2,
              Utilde: Utilde2,
              utilde: utilde2,
              utri: utri2,
              utrif: utrif2,
              uuarr: uuarr2,
              Uuml: Uuml$12,
              uuml: uuml$12,
              uwangle: uwangle2,
              vangrt: vangrt2,
              varepsilon: varepsilon2,
              varkappa: varkappa2,
              varnothing: varnothing2,
              varphi: varphi2,
              varpi: varpi2,
              varpropto: varpropto2,
              varr: varr2,
              vArr: vArr2,
              varrho: varrho2,
              varsigma: varsigma2,
              varsubsetneq: varsubsetneq2,
              varsubsetneqq: varsubsetneqq2,
              varsupsetneq: varsupsetneq2,
              varsupsetneqq: varsupsetneqq2,
              vartheta: vartheta2,
              vartriangleleft: vartriangleleft2,
              vartriangleright: vartriangleright2,
              vBar: vBar2,
              Vbar: Vbar2,
              vBarv: vBarv2,
              Vcy: Vcy2,
              vcy: vcy2,
              vdash: vdash2,
              vDash: vDash2,
              Vdash: Vdash2,
              VDash: VDash2,
              Vdashl: Vdashl2,
              veebar: veebar2,
              vee: vee2,
              Vee: Vee2,
              veeeq: veeeq2,
              vellip: vellip2,
              verbar: verbar2,
              Verbar: Verbar2,
              vert: vert2,
              Vert: Vert2,
              VerticalBar: VerticalBar2,
              VerticalLine: VerticalLine2,
              VerticalSeparator: VerticalSeparator2,
              VerticalTilde: VerticalTilde2,
              VeryThinSpace: VeryThinSpace2,
              Vfr: Vfr2,
              vfr: vfr2,
              vltri: vltri2,
              vnsub: vnsub2,
              vnsup: vnsup2,
              Vopf: Vopf2,
              vopf: vopf2,
              vprop: vprop2,
              vrtri: vrtri2,
              Vscr: Vscr2,
              vscr: vscr2,
              vsubnE: vsubnE2,
              vsubne: vsubne2,
              vsupnE: vsupnE2,
              vsupne: vsupne2,
              Vvdash: Vvdash2,
              vzigzag: vzigzag2,
              Wcirc: Wcirc2,
              wcirc: wcirc2,
              wedbar: wedbar2,
              wedge: wedge2,
              Wedge: Wedge2,
              wedgeq: wedgeq2,
              weierp: weierp2,
              Wfr: Wfr2,
              wfr: wfr2,
              Wopf: Wopf2,
              wopf: wopf2,
              wp: wp2,
              wr: wr2,
              wreath: wreath2,
              Wscr: Wscr2,
              wscr: wscr2,
              xcap: xcap2,
              xcirc: xcirc2,
              xcup: xcup2,
              xdtri: xdtri2,
              Xfr: Xfr2,
              xfr: xfr2,
              xharr: xharr2,
              xhArr: xhArr2,
              Xi: Xi2,
              xi: xi2,
              xlarr: xlarr2,
              xlArr: xlArr2,
              xmap: xmap2,
              xnis: xnis2,
              xodot: xodot2,
              Xopf: Xopf2,
              xopf: xopf2,
              xoplus: xoplus2,
              xotime: xotime2,
              xrarr: xrarr2,
              xrArr: xrArr2,
              Xscr: Xscr2,
              xscr: xscr2,
              xsqcup: xsqcup2,
              xuplus: xuplus2,
              xutri: xutri2,
              xvee: xvee2,
              xwedge: xwedge2,
              Yacute: Yacute$12,
              yacute: yacute$12,
              YAcy: YAcy2,
              yacy: yacy2,
              Ycirc: Ycirc2,
              ycirc: ycirc2,
              Ycy: Ycy2,
              ycy: ycy2,
              yen: yen$12,
              Yfr: Yfr2,
              yfr: yfr2,
              YIcy: YIcy2,
              yicy: yicy2,
              Yopf: Yopf2,
              yopf: yopf2,
              Yscr: Yscr2,
              yscr: yscr2,
              YUcy: YUcy2,
              yucy: yucy2,
              yuml: yuml$12,
              Yuml: Yuml2,
              Zacute: Zacute2,
              zacute: zacute2,
              Zcaron: Zcaron2,
              zcaron: zcaron2,
              Zcy: Zcy2,
              zcy: zcy2,
              Zdot: Zdot2,
              zdot: zdot2,
              zeetrf: zeetrf2,
              ZeroWidthSpace: ZeroWidthSpace2,
              Zeta: Zeta2,
              zeta: zeta2,
              zfr: zfr2,
              Zfr: Zfr2,
              ZHcy: ZHcy2,
              zhcy: zhcy2,
              zigrarr: zigrarr2,
              zopf: zopf2,
              Zopf: Zopf2,
              Zscr: Zscr2,
              zscr: zscr2,
              zwj: zwj2,
              zwnj: zwnj2
            };
            var Aacute2 = "Á";
            var aacute2 = "á";
            var Acirc2 = "Â";
            var acirc2 = "â";
            var acute2 = "´";
            var AElig2 = "Æ";
            var aelig2 = "æ";
            var Agrave2 = "À";
            var agrave2 = "à";
            var amp$12 = "&";
            var AMP2 = "&";
            var Aring2 = "Å";
            var aring2 = "å";
            var Atilde2 = "Ã";
            var atilde2 = "ã";
            var Auml2 = "Ä";
            var auml2 = "ä";
            var brvbar2 = "¦";
            var Ccedil2 = "Ç";
            var ccedil2 = "ç";
            var cedil2 = "¸";
            var cent2 = "¢";
            var copy6 = "©";
            var COPY2 = "©";
            var curren2 = "¤";
            var deg2 = "°";
            var divide2 = "÷";
            var Eacute2 = "É";
            var eacute2 = "é";
            var Ecirc2 = "Ê";
            var ecirc2 = "ê";
            var Egrave2 = "È";
            var egrave2 = "è";
            var ETH2 = "Ð";
            var eth2 = "ð";
            var Euml2 = "Ë";
            var euml2 = "ë";
            var frac122 = "½";
            var frac142 = "¼";
            var frac342 = "¾";
            var gt$12 = ">";
            var GT2 = ">";
            var Iacute2 = "Í";
            var iacute2 = "í";
            var Icirc2 = "Î";
            var icirc2 = "î";
            var iexcl2 = "¡";
            var Igrave2 = "Ì";
            var igrave2 = "ì";
            var iquest2 = "¿";
            var Iuml2 = "Ï";
            var iuml2 = "ï";
            var laquo2 = "«";
            var lt$12 = "<";
            var LT2 = "<";
            var macr2 = "¯";
            var micro2 = "µ";
            var middot2 = "·";
            var nbsp2 = " ";
            var not2 = "¬";
            var Ntilde2 = "Ñ";
            var ntilde2 = "ñ";
            var Oacute2 = "Ó";
            var oacute2 = "ó";
            var Ocirc2 = "Ô";
            var ocirc2 = "ô";
            var Ograve2 = "Ò";
            var ograve2 = "ò";
            var ordf2 = "ª";
            var ordm2 = "º";
            var Oslash2 = "Ø";
            var oslash2 = "ø";
            var Otilde2 = "Õ";
            var otilde2 = "õ";
            var Ouml2 = "Ö";
            var ouml2 = "ö";
            var para2 = "¶";
            var plusmn2 = "±";
            var pound2 = "£";
            var quot$12 = '"';
            var QUOT2 = '"';
            var raquo2 = "»";
            var reg2 = "®";
            var REG2 = "®";
            var sect2 = "§";
            var shy2 = "­";
            var sup12 = "¹";
            var sup22 = "²";
            var sup32 = "³";
            var szlig2 = "ß";
            var THORN2 = "Þ";
            var thorn2 = "þ";
            var times2 = "×";
            var Uacute2 = "Ú";
            var uacute2 = "ú";
            var Ucirc2 = "Û";
            var ucirc2 = "û";
            var Ugrave2 = "Ù";
            var ugrave2 = "ù";
            var uml2 = "¨";
            var Uuml2 = "Ü";
            var uuml2 = "ü";
            var Yacute2 = "Ý";
            var yacute2 = "ý";
            var yen2 = "¥";
            var yuml2 = "ÿ";
            var require$$12 = {
              Aacute: Aacute2,
              aacute: aacute2,
              Acirc: Acirc2,
              acirc: acirc2,
              acute: acute2,
              AElig: AElig2,
              aelig: aelig2,
              Agrave: Agrave2,
              agrave: agrave2,
              amp: amp$12,
              AMP: AMP2,
              Aring: Aring2,
              aring: aring2,
              Atilde: Atilde2,
              atilde: atilde2,
              Auml: Auml2,
              auml: auml2,
              brvbar: brvbar2,
              Ccedil: Ccedil2,
              ccedil: ccedil2,
              cedil: cedil2,
              cent: cent2,
              copy: copy6,
              COPY: COPY2,
              curren: curren2,
              deg: deg2,
              divide: divide2,
              Eacute: Eacute2,
              eacute: eacute2,
              Ecirc: Ecirc2,
              ecirc: ecirc2,
              Egrave: Egrave2,
              egrave: egrave2,
              ETH: ETH2,
              eth: eth2,
              Euml: Euml2,
              euml: euml2,
              frac12: frac122,
              frac14: frac142,
              frac34: frac342,
              gt: gt$12,
              GT: GT2,
              Iacute: Iacute2,
              iacute: iacute2,
              Icirc: Icirc2,
              icirc: icirc2,
              iexcl: iexcl2,
              Igrave: Igrave2,
              igrave: igrave2,
              iquest: iquest2,
              Iuml: Iuml2,
              iuml: iuml2,
              laquo: laquo2,
              lt: lt$12,
              LT: LT2,
              macr: macr2,
              micro: micro2,
              middot: middot2,
              nbsp: nbsp2,
              not: not2,
              Ntilde: Ntilde2,
              ntilde: ntilde2,
              Oacute: Oacute2,
              oacute: oacute2,
              Ocirc: Ocirc2,
              ocirc: ocirc2,
              Ograve: Ograve2,
              ograve: ograve2,
              ordf: ordf2,
              ordm: ordm2,
              Oslash: Oslash2,
              oslash: oslash2,
              Otilde: Otilde2,
              otilde: otilde2,
              Ouml: Ouml2,
              ouml: ouml2,
              para: para2,
              plusmn: plusmn2,
              pound: pound2,
              quot: quot$12,
              QUOT: QUOT2,
              raquo: raquo2,
              reg: reg2,
              REG: REG2,
              sect: sect2,
              shy: shy2,
              sup1: sup12,
              sup2: sup22,
              sup3: sup32,
              szlig: szlig2,
              THORN: THORN2,
              thorn: thorn2,
              times: times2,
              Uacute: Uacute2,
              uacute: uacute2,
              Ucirc: Ucirc2,
              ucirc: ucirc2,
              Ugrave: Ugrave2,
              ugrave: ugrave2,
              uml: uml2,
              Uuml: Uuml2,
              uuml: uuml2,
              Yacute: Yacute2,
              yacute: yacute2,
              yen: yen2,
              yuml: yuml2
            };
            var amp2 = "&";
            var apos2 = "'";
            var gt2 = ">";
            var lt2 = "<";
            var quot2 = '"';
            var require$$0$12 = {
              amp: amp2,
              apos: apos2,
              gt: gt2,
              lt: lt2,
              quot: quot2
            };
            var decode_codepoint2 = {};
            var require$$02 = {
              "0": 65533,
              "128": 8364,
              "130": 8218,
              "131": 402,
              "132": 8222,
              "133": 8230,
              "134": 8224,
              "135": 8225,
              "136": 710,
              "137": 8240,
              "138": 352,
              "139": 8249,
              "140": 338,
              "142": 381,
              "145": 8216,
              "146": 8217,
              "147": 8220,
              "148": 8221,
              "149": 8226,
              "150": 8211,
              "151": 8212,
              "152": 732,
              "153": 8482,
              "154": 353,
              "155": 8250,
              "156": 339,
              "158": 382,
              "159": 376
            };
            var __importDefault$22 = commonjsGlobal2 && commonjsGlobal2.__importDefault || function(mod) {
              return mod && mod.__esModule ? mod : { "default": mod };
            };
            Object.defineProperty(decode_codepoint2, "__esModule", { value: true });
            var decode_json_12 = __importDefault$22(require$$02);
            var fromCodePoint$22 = (
              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
              String.fromCodePoint || function(codePoint) {
                var output = "";
                if (codePoint > 65535) {
                  codePoint -= 65536;
                  output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
                  codePoint = 56320 | codePoint & 1023;
                }
                output += String.fromCharCode(codePoint);
                return output;
              }
            );
            function decodeCodePoint2(codePoint) {
              if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
                return "�";
              }
              if (codePoint in decode_json_12.default) {
                codePoint = decode_json_12.default[codePoint];
              }
              return fromCodePoint$22(codePoint);
            }
            decode_codepoint2.default = decodeCodePoint2;
            var __importDefault$12 = commonjsGlobal2 && commonjsGlobal2.__importDefault || function(mod) {
              return mod && mod.__esModule ? mod : { "default": mod };
            };
            Object.defineProperty(decode2, "__esModule", { value: true });
            decode2.decodeHTML = decode2.decodeHTMLStrict = decode2.decodeXML = void 0;
            var entities_json_1$12 = __importDefault$12(require$$1$12);
            var legacy_json_12 = __importDefault$12(require$$12);
            var xml_json_1$12 = __importDefault$12(require$$0$12);
            var decode_codepoint_12 = __importDefault$12(decode_codepoint2);
            var strictEntityRe2 = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
            decode2.decodeXML = getStrictDecoder2(xml_json_1$12.default);
            decode2.decodeHTMLStrict = getStrictDecoder2(entities_json_1$12.default);
            function getStrictDecoder2(map15) {
              var replace3 = getReplacer2(map15);
              return function(str) {
                return String(str).replace(strictEntityRe2, replace3);
              };
            }
            var sorter2 = function(a, b) {
              return a < b ? 1 : -1;
            };
            decode2.decodeHTML = (function() {
              var legacy = Object.keys(legacy_json_12.default).sort(sorter2);
              var keys2 = Object.keys(entities_json_1$12.default).sort(sorter2);
              for (var i = 0, j = 0; i < keys2.length; i++) {
                if (legacy[j] === keys2[i]) {
                  keys2[i] += ";?";
                  j++;
                } else {
                  keys2[i] += ";";
                }
              }
              var re = new RegExp("&(?:" + keys2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
              var replace3 = getReplacer2(entities_json_1$12.default);
              function replacer(str) {
                if (str.substr(-1) !== ";")
                  str += ";";
                return replace3(str);
              }
              return function(str) {
                return String(str).replace(re, replacer);
              };
            })();
            function getReplacer2(map15) {
              return function replace3(str) {
                if (str.charAt(1) === "#") {
                  var secondChar = str.charAt(2);
                  if (secondChar === "X" || secondChar === "x") {
                    return decode_codepoint_12.default(parseInt(str.substr(3), 16));
                  }
                  return decode_codepoint_12.default(parseInt(str.substr(2), 10));
                }
                return map15[str.slice(1, -1)] || str;
              };
            }
            var encode2 = {};
            var esm_importDefault = commonjsGlobal2 && commonjsGlobal2.__importDefault || function(mod) {
              return mod && mod.__esModule ? mod : { "default": mod };
            };
            Object.defineProperty(encode2, "__esModule", { value: true });
            encode2.escapeUTF8 = encode2.escape = encode2.encodeNonAsciiHTML = encode2.encodeHTML = encode2.encodeXML = void 0;
            var xml_json_12 = esm_importDefault(require$$0$12);
            var inverseXML2 = getInverseObj2(xml_json_12.default);
            var xmlReplacer2 = getInverseReplacer2(inverseXML2);
            encode2.encodeXML = getASCIIEncoder2(inverseXML2);
            var entities_json_12 = esm_importDefault(require$$1$12);
            var inverseHTML2 = getInverseObj2(entities_json_12.default);
            var htmlReplacer2 = getInverseReplacer2(inverseHTML2);
            encode2.encodeHTML = getInverse2(inverseHTML2, htmlReplacer2);
            encode2.encodeNonAsciiHTML = getASCIIEncoder2(inverseHTML2);
            function getInverseObj2(obj) {
              return Object.keys(obj).sort().reduce(function(inverse, name) {
                inverse[obj[name]] = "&" + name + ";";
                return inverse;
              }, {});
            }
            function getInverseReplacer2(inverse) {
              var single = [];
              var multiple = [];
              for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
                var k = _a[_i];
                if (k.length === 1) {
                  single.push("\\" + k);
                } else {
                  multiple.push(k);
                }
              }
              single.sort();
              for (var start3 = 0; start3 < single.length - 1; start3++) {
                var end2 = start3;
                while (end2 < single.length - 1 && single[end2].charCodeAt(1) + 1 === single[end2 + 1].charCodeAt(1)) {
                  end2 += 1;
                }
                var count = 1 + end2 - start3;
                if (count < 3)
                  continue;
                single.splice(start3, count, single[start3] + "-" + single[end2]);
              }
              multiple.unshift("[" + single.join("") + "]");
              return new RegExp(multiple.join("|"), "g");
            }
            var reNonASCII2 = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
            var getCodePoint2 = (
              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
              String.prototype.codePointAt != null ? (
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                function(str) {
                  return str.codePointAt(0);
                }
              ) : (
                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                function(c) {
                  return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
                }
              )
            );
            function singleCharReplacer2(c) {
              return "&#x" + (c.length > 1 ? getCodePoint2(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
            }
            function getInverse2(inverse, re) {
              return function(data) {
                return data.replace(re, function(name) {
                  return inverse[name];
                }).replace(reNonASCII2, singleCharReplacer2);
              };
            }
            var reEscapeChars2 = new RegExp(xmlReplacer2.source + "|" + reNonASCII2.source, "g");
            function esm_escape(data) {
              return data.replace(reEscapeChars2, singleCharReplacer2);
            }
            encode2.escape = esm_escape;
            function escapeUTF82(data) {
              return data.replace(xmlReplacer2, singleCharReplacer2);
            }
            encode2.escapeUTF8 = escapeUTF82;
            function getASCIIEncoder2(obj) {
              return function(data) {
                return data.replace(reEscapeChars2, function(c) {
                  return obj[c] || singleCharReplacer2(c);
                });
              };
            }
            (function(exports2) {
              Object.defineProperty(exports2, "__esModule", { value: true });
              exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.escapeUTF8 = exports2.escape = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = void 0;
              var decode_1 = decode2;
              var encode_13 = encode2;
              function decode$1(data, level) {
                return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
              }
              exports2.decode = decode$1;
              function decodeStrict(data, level) {
                return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
              }
              exports2.decodeStrict = decodeStrict;
              function encode$13(data, level) {
                return (!level || level <= 0 ? encode_13.encodeXML : encode_13.encodeHTML)(data);
              }
              exports2.encode = encode$13;
              var encode_2 = encode2;
              Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
                return encode_2.encodeXML;
              } });
              Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
                return encode_2.encodeHTML;
              } });
              Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
                return encode_2.encodeNonAsciiHTML;
              } });
              Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
                return encode_2.escape;
              } });
              Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
                return encode_2.escapeUTF8;
              } });
              Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
                return encode_2.encodeHTML;
              } });
              Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
                return encode_2.encodeHTML;
              } });
              var decode_2 = decode2;
              Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
                return decode_2.decodeXML;
              } });
              Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
                return decode_2.decodeHTML;
              } });
              Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
                return decode_2.decodeHTMLStrict;
              } });
              Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
                return decode_2.decodeHTML;
              } });
              Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
                return decode_2.decodeHTML;
              } });
              Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
                return decode_2.decodeHTMLStrict;
              } });
              Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
                return decode_2.decodeHTMLStrict;
              } });
              Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
                return decode_2.decodeXML;
              } });
            })(lib2);
            var ENTITY2 = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});";
            var C_BACKSLASH$12 = 92;
            var reBackslashOrAmp2 = /[\\&]/;
            var ESCAPABLE2 = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]";
            var reEntityOrEscapedChar2 = new RegExp("\\\\" + ESCAPABLE2 + "|" + ENTITY2, "gi");
            var XMLSPECIAL2 = '[&<>"]';
            var reXmlSpecial2 = new RegExp(XMLSPECIAL2, "g");
            var unescapeChar2 = function(s) {
              if (s.charCodeAt(0) === C_BACKSLASH$12) {
                return s.charAt(1);
              }
              return lib2.decodeHTML(s);
            };
            function unescapeString2(s) {
              if (reBackslashOrAmp2.test(s)) {
                return s.replace(reEntityOrEscapedChar2, unescapeChar2);
              }
              return s;
            }
            function normalizeURI2(uri) {
              try {
                return encode_12(uri);
              } catch (err2) {
                return uri;
              }
            }
            function replaceUnsafeChar2(s) {
              switch (s) {
                case "&":
                  return "&amp;";
                case "<":
                  return "&lt;";
                case ">":
                  return "&gt;";
                case '"':
                  return "&quot;";
                default:
                  return s;
              }
            }
            function escapeXml2(s) {
              if (reXmlSpecial2.test(s)) {
                return s.replace(reXmlSpecial2, replaceUnsafeChar2);
              }
              return s;
            }
            function repeat2(str, count) {
              var arr = [];
              for (var i = 0; i < count; i++) {
                arr.push(str);
              }
              return arr.join("");
            }
            function isEmpty2(str) {
              if (!str) {
                return true;
              }
              return !/[^ \t]+/.test(str);
            }
            var NodeWalker2 = (
              /** @class */
              (function() {
                function NodeWalker3(root) {
                  this.current = root;
                  this.root = root;
                  this.entering = true;
                }
                NodeWalker3.prototype.next = function() {
                  var cur = this.current;
                  var entering = this.entering;
                  if (cur === null) {
                    return null;
                  }
                  var container = isContainer2(cur);
                  if (entering && container) {
                    if (cur.firstChild) {
                      this.current = cur.firstChild;
                      this.entering = true;
                    } else {
                      this.entering = false;
                    }
                  } else if (cur === this.root) {
                    this.current = null;
                  } else if (cur.next === null) {
                    this.current = cur.parent;
                    this.entering = false;
                  } else {
                    this.current = cur.next;
                    this.entering = true;
                  }
                  return { entering, node: cur };
                };
                NodeWalker3.prototype.resumeAt = function(node4, entering) {
                  this.current = node4;
                  this.entering = entering === true;
                };
                return NodeWalker3;
              })()
            );
            function isContainer2(node4) {
              switch (node4.type) {
                case "document":
                case "blockQuote":
                case "list":
                case "item":
                case "paragraph":
                case "heading":
                case "emph":
                case "strong":
                case "strike":
                case "link":
                case "image":
                case "table":
                case "tableHead":
                case "tableBody":
                case "tableRow":
                case "tableCell":
                case "tableDelimRow":
                case "customInline":
                  return true;
                default:
                  return false;
              }
            }
            var lastNodeId2 = 1;
            var nodeMap2 = {};
            function getNodeById2(id) {
              return nodeMap2[id];
            }
            function removeNodeById2(id) {
              delete nodeMap2[id];
            }
            function removeAllNode2() {
              nodeMap2 = {};
            }
            var esm_Node = (
              /** @class */
              (function() {
                function Node4(nodeType2, sourcepos) {
                  this.parent = null;
                  this.prev = null;
                  this.next = null;
                  this.firstChild = null;
                  this.lastChild = null;
                  this.literal = null;
                  if (nodeType2 === "document") {
                    this.id = -1;
                  } else {
                    this.id = lastNodeId2++;
                  }
                  this.type = nodeType2;
                  this.sourcepos = sourcepos;
                  nodeMap2[this.id] = this;
                }
                Node4.prototype.isContainer = function() {
                  return isContainer2(this);
                };
                Node4.prototype.unlink = function() {
                  if (this.prev) {
                    this.prev.next = this.next;
                  } else if (this.parent) {
                    this.parent.firstChild = this.next;
                  }
                  if (this.next) {
                    this.next.prev = this.prev;
                  } else if (this.parent) {
                    this.parent.lastChild = this.prev;
                  }
                  this.parent = null;
                  this.next = null;
                  this.prev = null;
                };
                Node4.prototype.replaceWith = function(node4) {
                  this.insertBefore(node4);
                  this.unlink();
                };
                Node4.prototype.insertAfter = function(sibling) {
                  sibling.unlink();
                  sibling.next = this.next;
                  if (sibling.next) {
                    sibling.next.prev = sibling;
                  }
                  sibling.prev = this;
                  this.next = sibling;
                  if (this.parent) {
                    sibling.parent = this.parent;
                    if (!sibling.next) {
                      sibling.parent.lastChild = sibling;
                    }
                  }
                };
                Node4.prototype.insertBefore = function(sibling) {
                  sibling.unlink();
                  sibling.prev = this.prev;
                  if (sibling.prev) {
                    sibling.prev.next = sibling;
                  }
                  sibling.next = this;
                  this.prev = sibling;
                  sibling.parent = this.parent;
                  if (!sibling.prev) {
                    sibling.parent.firstChild = sibling;
                  }
                };
                Node4.prototype.appendChild = function(child3) {
                  child3.unlink();
                  child3.parent = this;
                  if (this.lastChild) {
                    this.lastChild.next = child3;
                    child3.prev = this.lastChild;
                    this.lastChild = child3;
                  } else {
                    this.firstChild = child3;
                    this.lastChild = child3;
                  }
                };
                Node4.prototype.prependChild = function(child3) {
                  child3.unlink();
                  child3.parent = this;
                  if (this.firstChild) {
                    this.firstChild.prev = child3;
                    child3.next = this.firstChild;
                    this.firstChild = child3;
                  } else {
                    this.firstChild = child3;
                    this.lastChild = child3;
                  }
                };
                Node4.prototype.walker = function() {
                  return new NodeWalker2(this);
                };
                return Node4;
              })()
            );
            var BlockNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(BlockNode3, _super);
                function BlockNode3(nodeType2, sourcepos) {
                  var _this = _super.call(this, nodeType2, sourcepos) || this;
                  _this.open = true;
                  _this.lineOffsets = null;
                  _this.stringContent = null;
                  _this.lastLineBlank = false;
                  _this.lastLineChecked = false;
                  _this.type = nodeType2;
                  return _this;
                }
                return BlockNode3;
              })(esm_Node)
            );
            var ListNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(ListNode3, _super);
                function ListNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.listData = null;
                  return _this;
                }
                return ListNode3;
              })(BlockNode2)
            );
            var HeadingNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(HeadingNode3, _super);
                function HeadingNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.level = 0;
                  _this.headingType = "atx";
                  return _this;
                }
                return HeadingNode3;
              })(BlockNode2)
            );
            var CodeBlockNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(CodeBlockNode3, _super);
                function CodeBlockNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.isFenced = false;
                  _this.fenceChar = null;
                  _this.fenceLength = 0;
                  _this.fenceOffset = -1;
                  _this.info = null;
                  _this.infoPadding = 0;
                  return _this;
                }
                return CodeBlockNode3;
              })(BlockNode2)
            );
            var TableNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(TableNode3, _super);
                function TableNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.columns = [];
                  return _this;
                }
                return TableNode3;
              })(BlockNode2)
            );
            var TableCellNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(TableCellNode3, _super);
                function TableCellNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.startIdx = 0;
                  _this.endIdx = 0;
                  _this.paddingLeft = 0;
                  _this.paddingRight = 0;
                  _this.ignored = false;
                  return _this;
                }
                return TableCellNode3;
              })(BlockNode2)
            );
            var RefDefNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(RefDefNode3, _super);
                function RefDefNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.title = "";
                  _this.dest = "";
                  _this.label = "";
                  return _this;
                }
                return RefDefNode3;
              })(BlockNode2)
            );
            var CustomBlockNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(CustomBlockNode3, _super);
                function CustomBlockNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.syntaxLength = 0;
                  _this.offset = -1;
                  _this.info = "";
                  return _this;
                }
                return CustomBlockNode3;
              })(BlockNode2)
            );
            var HtmlBlockNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(HtmlBlockNode3, _super);
                function HtmlBlockNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.htmlBlockType = -1;
                  return _this;
                }
                return HtmlBlockNode3;
              })(BlockNode2)
            );
            var LinkNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(LinkNode3, _super);
                function LinkNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.destination = null;
                  _this.title = null;
                  _this.extendedAutolink = false;
                  return _this;
                }
                return LinkNode3;
              })(esm_Node)
            );
            var CodeNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(CodeNode3, _super);
                function CodeNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.tickCount = 0;
                  return _this;
                }
                return CodeNode3;
              })(esm_Node)
            );
            var CustomInlineNode2 = (
              /** @class */
              (function(_super) {
                esm_extends(CustomInlineNode3, _super);
                function CustomInlineNode3() {
                  var _this = _super !== null && _super.apply(this, arguments) || this;
                  _this.info = "";
                  return _this;
                }
                return CustomInlineNode3;
              })(esm_Node)
            );
            function createNode2(type, sourcepos) {
              switch (type) {
                case "heading":
                  return new HeadingNode2(type, sourcepos);
                case "list":
                case "item":
                  return new ListNode2(type, sourcepos);
                case "link":
                case "image":
                  return new LinkNode2(type, sourcepos);
                case "codeBlock":
                  return new CodeBlockNode2(type, sourcepos);
                case "htmlBlock":
                  return new HtmlBlockNode2(type, sourcepos);
                case "table":
                  return new TableNode2(type, sourcepos);
                case "tableCell":
                  return new TableCellNode2(type, sourcepos);
                case "document":
                case "paragraph":
                case "blockQuote":
                case "thematicBreak":
                case "tableRow":
                case "tableBody":
                case "tableHead":
                case "frontMatter":
                  return new BlockNode2(type, sourcepos);
                case "code":
                  return new CodeNode2(type, sourcepos);
                case "refDef":
                  return new RefDefNode2(type, sourcepos);
                case "customBlock":
                  return new CustomBlockNode2(type, sourcepos);
                case "customInline":
                  return new CustomInlineNode2(type, sourcepos);
                default:
                  return new esm_Node(type, sourcepos);
              }
            }
            function isCodeBlock2(node4) {
              return node4.type === "codeBlock";
            }
            function isHtmlBlock2(node4) {
              return node4.type === "htmlBlock";
            }
            function isHeading2(node4) {
              return node4.type === "heading";
            }
            function isList2(node4) {
              return node4.type === "list";
            }
            function isTable2(node4) {
              return node4.type === "table";
            }
            function isRefDef2(node4) {
              return node4.type === "refDef";
            }
            function isCustomBlock2(node4) {
              return node4.type === "customBlock";
            }
            function isCustomInline2(node4) {
              return node4.type === "customInline";
            }
            function esm_text(s, sourcepos) {
              var node4 = createNode2("text", sourcepos);
              node4.literal = s;
              return node4;
            }
            var TAGNAME2 = "[A-Za-z][A-Za-z0-9-]*";
            var ATTRIBUTENAME2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
            var UNQUOTEDVALUE2 = "[^\"'=<>`\\x00-\\x20]+";
            var SINGLEQUOTEDVALUE2 = "'[^']*'";
            var DOUBLEQUOTEDVALUE2 = '"[^"]*"';
            var ATTRIBUTEVALUE2 = "(?:" + UNQUOTEDVALUE2 + "|" + SINGLEQUOTEDVALUE2 + "|" + DOUBLEQUOTEDVALUE2 + ")";
            var ATTRIBUTEVALUESPEC2 = "(?:\\s*=\\s*" + ATTRIBUTEVALUE2 + ")";
            var ATTRIBUTE2 = "(?:\\s+" + ATTRIBUTENAME2 + ATTRIBUTEVALUESPEC2 + "?)";
            var OPENTAG2 = "<" + TAGNAME2 + ATTRIBUTE2 + "*\\s*/?>";
            var CLOSETAG2 = "</" + TAGNAME2 + "\\s*[>]";
            var HTMLCOMMENT2 = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
            var PROCESSINGINSTRUCTION2 = "[<][?].*?[?][>]";
            var DECLARATION2 = "<![A-Z]+\\s+[^>]*>";
            var CDATA2 = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
            var HTMLTAG2 = "(?:" + OPENTAG2 + "|" + CLOSETAG2 + "|" + HTMLCOMMENT2 + "|" + PROCESSINGINSTRUCTION2 + "|" + DECLARATION2 + "|" + CDATA2 + ")";
            var reHtmlTag2 = new RegExp("^" + HTMLTAG2, "i");
            var fromCodePoint2;
            if (String.fromCodePoint) {
              fromCodePoint2 = function(_) {
                try {
                  return String.fromCodePoint(_);
                } catch (e) {
                  if (e instanceof RangeError) {
                    return String.fromCharCode(65533);
                  }
                  throw e;
                }
              };
            } else {
              var stringFromCharCode_1 = String.fromCharCode;
              var floor_1 = Math.floor;
              fromCodePoint2 = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                var MAX_SIZE = 16384;
                var codeUnits = [];
                var highSurrogate;
                var lowSurrogate;
                var index3 = -1;
                var length = args.length;
                if (!length) {
                  return "";
                }
                var result2 = "";
                while (++index3 < length) {
                  var codePoint = Number(args[index3]);
                  if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                  codePoint < 0 || // not a valid Unicode code point
                  codePoint > 1114111 || // not a valid Unicode code point
                  floor_1(codePoint) !== codePoint) {
                    return String.fromCharCode(65533);
                  }
                  if (codePoint <= 65535) {
                    codeUnits.push(codePoint);
                  } else {
                    codePoint -= 65536;
                    highSurrogate = (codePoint >> 10) + 55296;
                    lowSurrogate = codePoint % 1024 + 56320;
                    codeUnits.push(highSurrogate, lowSurrogate);
                  }
                  if (index3 + 1 === length || codeUnits.length > MAX_SIZE) {
                    result2 += stringFromCharCode_1.apply(void 0, codeUnits);
                    codeUnits.length = 0;
                  }
                }
                return result2;
              };
            }
            var fromCodePoint$12 = fromCodePoint2;
            var DOMAIN2 = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+";
            var PATH2 = "[^<\\s]*[^<?!.,:*_?~\\s]";
            var EMAIL2 = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
            function trimUnmatchedTrailingParens2(source) {
              var trailingParen = /\)+$/.exec(source);
              if (trailingParen) {
                var count = 0;
                for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
                  var ch = source_1[_i];
                  if (ch === "(") {
                    if (count < 0) {
                      count = 1;
                    } else {
                      count += 1;
                    }
                  } else if (ch === ")") {
                    count -= 1;
                  }
                }
                if (count < 0) {
                  var trimCount = Math.min(-count, trailingParen[0].length);
                  return source.substring(0, source.length - trimCount);
                }
              }
              return source;
            }
            function trimTrailingEntity2(source) {
              return source.replace(/&[A-Za-z0-9]+;$/, "");
            }
            function parseEmailLink2(source) {
              var reEmailLink = new RegExp(EMAIL2, "g");
              var result2 = [];
              var m;
              while (m = reEmailLink.exec(source)) {
                var text_1 = m[0];
                if (!/[_-]+$/.test(text_1)) {
                  result2.push({
                    text: text_1,
                    range: [m.index, m.index + text_1.length - 1],
                    url: "mailto:" + text_1
                  });
                }
              }
              return result2;
            }
            function parseUrlLink2(source) {
              var reWwwAutolink = new RegExp("(www|https?://)." + DOMAIN2 + PATH2, "g");
              var result2 = [];
              var m;
              while (m = reWwwAutolink.exec(source)) {
                var text_2 = trimTrailingEntity2(trimUnmatchedTrailingParens2(m[0]));
                var scheme = m[1] === "www" ? "http://" : "";
                result2.push({
                  text: text_2,
                  range: [m.index, m.index + text_2.length - 1],
                  url: "" + scheme + text_2
                });
              }
              return result2;
            }
            function baseAutolinkParser2(source) {
              return esm_spreadArray(esm_spreadArray([], parseUrlLink2(source)), parseEmailLink2(source)).sort(function(a, b) {
                return a.range[0] - b.range[0];
              });
            }
            function convertExtAutoLinks2(walker, autolinkParser) {
              if (typeof autolinkParser === "boolean") {
                autolinkParser = baseAutolinkParser2;
              }
              var event;
              var _loop_1 = function() {
                var entering = event.entering, node4 = event.node;
                if (entering && node4.type === "text" && node4.parent.type !== "link") {
                  var literal = node4.literal;
                  var linkInfos = autolinkParser(literal);
                  if (!linkInfos || !linkInfos.length) {
                    return "continue";
                  }
                  var lastIdx = 0;
                  var _a = node4.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];
                  var sourcepos = function(startIdx, endIdx) {
                    return [
                      [lineNum_1, chPos_1 + startIdx],
                      [lineNum_1, chPos_1 + endIdx]
                    ];
                  };
                  var newNodes = [];
                  for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {
                    var _b = linkInfos_1[_i], range3 = _b.range, url = _b.url, linkText = _b.text;
                    if (range3[0] > lastIdx) {
                      newNodes.push(esm_text(literal.substring(lastIdx, range3[0]), sourcepos(lastIdx, range3[0] - 1)));
                    }
                    var linkNode = createNode2("link", sourcepos.apply(void 0, range3));
                    linkNode.appendChild(esm_text(linkText, sourcepos.apply(void 0, range3)));
                    linkNode.destination = url;
                    linkNode.extendedAutolink = true;
                    newNodes.push(linkNode);
                    lastIdx = range3[1] + 1;
                  }
                  if (lastIdx < literal.length) {
                    newNodes.push(esm_text(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));
                  }
                  for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {
                    var newNode = newNodes_1[_c];
                    node4.insertBefore(newNode);
                  }
                  node4.unlink();
                }
              };
              while (event = walker.next()) {
                _loop_1();
              }
            }
            function last2(arr) {
              return arr[arr.length - 1];
            }
            function normalizeReference2(str) {
              return str.slice(1, str.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
            }
            function iterateObject2(obj, iteratee) {
              Object.keys(obj).forEach(function(key) {
                iteratee(key, obj[key]);
              });
            }
            function omit2(obj) {
              var propNames = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                propNames[_i - 1] = arguments[_i];
              }
              var resultMap = esm_assign({}, obj);
              propNames.forEach(function(key) {
                delete resultMap[key];
              });
              return resultMap;
            }
            function isEmptyObj2(obj) {
              return !Object.keys(obj).length;
            }
            function clearObj2(obj) {
              Object.keys(obj).forEach(function(key) {
                delete obj[key];
              });
            }
            var C_NEWLINE2 = 10;
            var C_ASTERISK2 = 42;
            var C_UNDERSCORE2 = 95;
            var C_BACKTICK2 = 96;
            var C_OPEN_BRACKET$12 = 91;
            var C_CLOSE_BRACKET2 = 93;
            var C_TILDE2 = 126;
            var C_LESSTHAN$12 = 60;
            var C_BANG2 = 33;
            var C_BACKSLASH2 = 92;
            var C_AMPERSAND2 = 38;
            var C_OPEN_PAREN2 = 40;
            var C_CLOSE_PAREN2 = 41;
            var C_COLON2 = 58;
            var C_SINGLEQUOTE2 = 39;
            var C_DOUBLEQUOTE2 = 34;
            var C_DOLLAR2 = 36;
            var ESCAPED_CHAR2 = "\\\\" + ESCAPABLE2;
            var rePunctuation2 = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/);
            var reLinkTitle2 = new RegExp('^(?:"(' + ESCAPED_CHAR2 + '|[^"\\x00])*"|' + ("'(" + ESCAPED_CHAR2 + "|[^'\\x00])*'") + "|" + ("\\((" + ESCAPED_CHAR2 + "|[^()\\x00])*\\))"));
            var reLinkDestinationBraces2 = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/;
            var reEscapable2 = new RegExp("^" + ESCAPABLE2);
            var reEntityHere2 = new RegExp("^" + ENTITY2, "i");
            var reTicks2 = /`+/;
            var reTicksHere2 = /^`+/;
            var reEllipses2 = /\.\.\./g;
            var reDash2 = /--+/g;
            var reEmailAutolink2 = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
            var reAutolink2 = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i;
            var reSpnl2 = /^ *(?:\n *)?/;
            var reWhitespaceChar2 = /^[ \t\n\x0b\x0c\x0d]/;
            var reUnicodeWhitespaceChar2 = /^\s/;
            var reFinalSpace2 = / *$/;
            var reInitialSpace2 = /^ */;
            var reSpaceAtEndOfLine2 = /^ *(?:\n|$)/;
            var reLinkLabel2 = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/;
            var reMain2 = /^[^\n`\[\]\\!<&*_'"~$]+/m;
            var InlineParser2 = (
              /** @class */
              (function() {
                function InlineParser3(options) {
                  this.subject = "";
                  this.delimiters = null;
                  this.brackets = null;
                  this.pos = 0;
                  this.lineStartNum = 0;
                  this.lineIdx = 0;
                  this.lineOffsets = [0];
                  this.linePosOffset = 0;
                  this.refMap = {};
                  this.refLinkCandidateMap = {};
                  this.refDefCandidateMap = {};
                  this.options = options;
                }
                InlineParser3.prototype.sourcepos = function(start3, end2) {
                  var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];
                  var lineNum = this.lineStartNum + this.lineIdx;
                  var startpos = [lineNum, start3 + linePosOffset];
                  if (typeof end2 === "number") {
                    return [startpos, [lineNum, end2 + linePosOffset]];
                  }
                  return startpos;
                };
                InlineParser3.prototype.nextLine = function() {
                  this.lineIdx += 1;
                  this.linePosOffset = -this.pos;
                };
                InlineParser3.prototype.match = function(re) {
                  var m = re.exec(this.subject.slice(this.pos));
                  if (m === null) {
                    return null;
                  }
                  this.pos += m.index + m[0].length;
                  return m[0];
                };
                InlineParser3.prototype.peek = function() {
                  if (this.pos < this.subject.length) {
                    return this.subject.charCodeAt(this.pos);
                  }
                  return -1;
                };
                InlineParser3.prototype.spnl = function() {
                  this.match(reSpnl2);
                  return true;
                };
                InlineParser3.prototype.parseBackticks = function(block3) {
                  var startpos = this.pos + 1;
                  var ticks = this.match(reTicksHere2);
                  if (ticks === null) {
                    return false;
                  }
                  var afterOpenTicks = this.pos;
                  var matched;
                  while ((matched = this.match(reTicks2)) !== null) {
                    if (matched === ticks) {
                      var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);
                      var sourcepos = this.sourcepos(startpos, this.pos);
                      var lines = contents.split("\n");
                      if (lines.length > 1) {
                        var lastLine = last2(lines);
                        this.lineIdx += lines.length - 1;
                        this.linePosOffset = -(this.pos - lastLine.length - ticks.length);
                        sourcepos[1] = this.sourcepos(this.pos);
                        contents = lines.join(" ");
                      }
                      var node4 = createNode2("code", sourcepos);
                      if (contents.length > 0 && contents.match(/[^ ]/) !== null && contents[0] == " " && contents[contents.length - 1] == " ") {
                        node4.literal = contents.slice(1, contents.length - 1);
                      } else {
                        node4.literal = contents;
                      }
                      node4.tickCount = ticks.length;
                      block3.appendChild(node4);
                      return true;
                    }
                  }
                  this.pos = afterOpenTicks;
                  block3.appendChild(esm_text(ticks, this.sourcepos(startpos, this.pos - 1)));
                  return true;
                };
                InlineParser3.prototype.parseBackslash = function(block3) {
                  var subj = this.subject;
                  var node4;
                  this.pos += 1;
                  var startpos = this.pos;
                  if (this.peek() === C_NEWLINE2) {
                    this.pos += 1;
                    node4 = createNode2("linebreak", this.sourcepos(this.pos - 1, this.pos));
                    block3.appendChild(node4);
                    this.nextLine();
                  } else if (reEscapable2.test(subj.charAt(this.pos))) {
                    block3.appendChild(esm_text(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));
                    this.pos += 1;
                  } else {
                    block3.appendChild(esm_text("\\", this.sourcepos(startpos, startpos)));
                  }
                  return true;
                };
                InlineParser3.prototype.parseAutolink = function(block3) {
                  var m;
                  var dest;
                  var node4;
                  var startpos = this.pos + 1;
                  if (m = this.match(reEmailAutolink2)) {
                    dest = m.slice(1, m.length - 1);
                    node4 = createNode2("link", this.sourcepos(startpos, this.pos));
                    node4.destination = normalizeURI2("mailto:" + dest);
                    node4.title = "";
                    node4.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));
                    block3.appendChild(node4);
                    return true;
                  }
                  if (m = this.match(reAutolink2)) {
                    dest = m.slice(1, m.length - 1);
                    node4 = createNode2("link", this.sourcepos(startpos, this.pos));
                    node4.destination = normalizeURI2(dest);
                    node4.title = "";
                    node4.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));
                    block3.appendChild(node4);
                    return true;
                  }
                  return false;
                };
                InlineParser3.prototype.parseHtmlTag = function(block3) {
                  var startpos = this.pos + 1;
                  var m = this.match(reHtmlTag2);
                  if (m === null) {
                    return false;
                  }
                  var node4 = createNode2("htmlInline", this.sourcepos(startpos, this.pos));
                  node4.literal = m;
                  block3.appendChild(node4);
                  return true;
                };
                InlineParser3.prototype.scanDelims = function(cc) {
                  var numdelims = 0;
                  var startpos = this.pos;
                  if (cc === C_SINGLEQUOTE2 || cc === C_DOUBLEQUOTE2) {
                    numdelims++;
                    this.pos++;
                  } else {
                    while (this.peek() === cc) {
                      numdelims++;
                      this.pos++;
                    }
                  }
                  if (numdelims === 0 || numdelims < 2 && (cc === C_TILDE2 || cc === C_DOLLAR2)) {
                    this.pos = startpos;
                    return null;
                  }
                  var charBefore = startpos === 0 ? "\n" : this.subject.charAt(startpos - 1);
                  var ccAfter = this.peek();
                  var charAfter;
                  if (ccAfter === -1) {
                    charAfter = "\n";
                  } else {
                    charAfter = fromCodePoint$12(ccAfter);
                  }
                  var afterIsWhitespace = reUnicodeWhitespaceChar2.test(charAfter);
                  var afterIsPunctuation = rePunctuation2.test(charAfter);
                  var beforeIsWhitespace = reUnicodeWhitespaceChar2.test(charBefore);
                  var beforeIsPunctuation = rePunctuation2.test(charBefore);
                  var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);
                  var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);
                  var canOpen;
                  var canClose;
                  if (cc === C_UNDERSCORE2) {
                    canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);
                    canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);
                  } else if (cc === C_SINGLEQUOTE2 || cc === C_DOUBLEQUOTE2) {
                    canOpen = leftFlanking && !rightFlanking;
                    canClose = rightFlanking;
                  } else if (cc === C_DOLLAR2) {
                    canOpen = !afterIsWhitespace;
                    canClose = !beforeIsWhitespace;
                  } else {
                    canOpen = leftFlanking;
                    canClose = rightFlanking;
                  }
                  this.pos = startpos;
                  return { numdelims, canOpen, canClose };
                };
                InlineParser3.prototype.handleDelim = function(cc, block3) {
                  var res = this.scanDelims(cc);
                  if (!res) {
                    return false;
                  }
                  var numdelims = res.numdelims;
                  var startpos = this.pos + 1;
                  var contents;
                  this.pos += numdelims;
                  if (cc === C_SINGLEQUOTE2) {
                    contents = "’";
                  } else if (cc === C_DOUBLEQUOTE2) {
                    contents = "“";
                  } else {
                    contents = this.subject.slice(startpos - 1, this.pos);
                  }
                  var node4 = esm_text(contents, this.sourcepos(startpos, this.pos));
                  block3.appendChild(node4);
                  if ((res.canOpen || res.canClose) && (this.options.smart || cc !== C_SINGLEQUOTE2 && cc !== C_DOUBLEQUOTE2)) {
                    this.delimiters = {
                      cc,
                      numdelims,
                      origdelims: numdelims,
                      node: node4,
                      previous: this.delimiters,
                      next: null,
                      canOpen: res.canOpen,
                      canClose: res.canClose
                    };
                    if (this.delimiters.previous) {
                      this.delimiters.previous.next = this.delimiters;
                    }
                  }
                  return true;
                };
                InlineParser3.prototype.removeDelimiter = function(delim) {
                  if (delim.previous !== null) {
                    delim.previous.next = delim.next;
                  }
                  if (delim.next === null) {
                    this.delimiters = delim.previous;
                  } else {
                    delim.next.previous = delim.previous;
                  }
                };
                InlineParser3.prototype.removeDelimitersBetween = function(bottom3, top2) {
                  if (bottom3.next !== top2) {
                    bottom3.next = top2;
                    top2.previous = bottom3;
                  }
                };
                InlineParser3.prototype.processEmphasis = function(stackBottom) {
                  var _a;
                  var opener;
                  var closer;
                  var oldCloser;
                  var openerInl, closerInl;
                  var openerFound;
                  var oddMatch = false;
                  var openersBottom = (_a = {}, _a[C_UNDERSCORE2] = [stackBottom, stackBottom, stackBottom], _a[C_ASTERISK2] = [stackBottom, stackBottom, stackBottom], _a[C_SINGLEQUOTE2] = [stackBottom], _a[C_DOUBLEQUOTE2] = [stackBottom], _a[C_TILDE2] = [stackBottom], _a[C_DOLLAR2] = [stackBottom], _a);
                  closer = this.delimiters;
                  while (closer !== null && closer.previous !== stackBottom) {
                    closer = closer.previous;
                  }
                  while (closer !== null) {
                    var closercc = closer.cc;
                    var closerEmph = closercc === C_UNDERSCORE2 || closercc === C_ASTERISK2;
                    if (!closer.canClose) {
                      closer = closer.next;
                    } else {
                      opener = closer.previous;
                      openerFound = false;
                      while (opener !== null && opener !== stackBottom && opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {
                        oddMatch = closerEmph && (closer.canOpen || opener.canClose) && closer.origdelims % 3 !== 0 && (opener.origdelims + closer.origdelims) % 3 === 0;
                        if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {
                          openerFound = true;
                          break;
                        }
                        opener = opener.previous;
                      }
                      oldCloser = closer;
                      if (closerEmph || closercc === C_TILDE2 || closercc === C_DOLLAR2) {
                        if (!openerFound) {
                          closer = closer.next;
                        } else if (opener) {
                          var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;
                          var emptyDelims = closerEmph ? 0 : 1;
                          openerInl = opener.node;
                          closerInl = closer.node;
                          var nodeType2 = closerEmph ? useDelims === 1 ? "emph" : "strong" : "strike";
                          if (closercc === C_DOLLAR2) {
                            nodeType2 = "customInline";
                          }
                          var newNode = createNode2(nodeType2);
                          var openerEndPos = openerInl.sourcepos[1];
                          var closerStartPos = closerInl.sourcepos[0];
                          newNode.sourcepos = [
                            [openerEndPos[0], openerEndPos[1] - useDelims + 1],
                            [closerStartPos[0], closerStartPos[1] + useDelims - 1]
                          ];
                          openerInl.sourcepos[1][1] -= useDelims;
                          closerInl.sourcepos[0][1] += useDelims;
                          openerInl.literal = openerInl.literal.slice(useDelims);
                          closerInl.literal = closerInl.literal.slice(useDelims);
                          opener.numdelims -= useDelims;
                          closer.numdelims -= useDelims;
                          var tmp = openerInl.next;
                          var next = void 0;
                          while (tmp && tmp !== closerInl) {
                            next = tmp.next;
                            tmp.unlink();
                            newNode.appendChild(tmp);
                            tmp = next;
                          }
                          if (closercc === C_DOLLAR2) {
                            var textNode = newNode.firstChild;
                            var literal = textNode.literal || "";
                            var info = literal.split(/\s/)[0];
                            newNode.info = info;
                            if (literal.length <= info.length) {
                              textNode.unlink();
                            } else {
                              textNode.sourcepos[0][1] += info.length;
                              textNode.literal = literal.replace(info + " ", "");
                            }
                          }
                          openerInl.insertAfter(newNode);
                          this.removeDelimitersBetween(opener, closer);
                          if (opener.numdelims <= emptyDelims) {
                            if (opener.numdelims === 0) {
                              openerInl.unlink();
                            }
                            this.removeDelimiter(opener);
                          }
                          if (closer.numdelims <= emptyDelims) {
                            if (closer.numdelims === 0) {
                              closerInl.unlink();
                            }
                            var tempstack = closer.next;
                            this.removeDelimiter(closer);
                            closer = tempstack;
                          }
                        }
                      } else if (closercc === C_SINGLEQUOTE2) {
                        closer.node.literal = "’";
                        if (openerFound) {
                          opener.node.literal = "‘";
                        }
                        closer = closer.next;
                      } else if (closercc === C_DOUBLEQUOTE2) {
                        closer.node.literal = "”";
                        if (openerFound) {
                          opener.node.literal = "“";
                        }
                        closer = closer.next;
                      }
                      if (!openerFound) {
                        openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;
                        if (!oldCloser.canOpen) {
                          this.removeDelimiter(oldCloser);
                        }
                      }
                    }
                  }
                  while (this.delimiters !== null && this.delimiters !== stackBottom) {
                    this.removeDelimiter(this.delimiters);
                  }
                };
                InlineParser3.prototype.parseLinkTitle = function() {
                  var title = this.match(reLinkTitle2);
                  if (title === null) {
                    return null;
                  }
                  return unescapeString2(title.substr(1, title.length - 2));
                };
                InlineParser3.prototype.parseLinkDestination = function() {
                  var res = this.match(reLinkDestinationBraces2);
                  if (res === null) {
                    if (this.peek() === C_LESSTHAN$12) {
                      return null;
                    }
                    var savepos = this.pos;
                    var openparens = 0;
                    var c = void 0;
                    while ((c = this.peek()) !== -1) {
                      if (c === C_BACKSLASH2 && reEscapable2.test(this.subject.charAt(this.pos + 1))) {
                        this.pos += 1;
                        if (this.peek() !== -1) {
                          this.pos += 1;
                        }
                      } else if (c === C_OPEN_PAREN2) {
                        this.pos += 1;
                        openparens += 1;
                      } else if (c === C_CLOSE_PAREN2) {
                        if (openparens < 1) {
                          break;
                        } else {
                          this.pos += 1;
                          openparens -= 1;
                        }
                      } else if (reWhitespaceChar2.exec(fromCodePoint$12(c)) !== null) {
                        break;
                      } else {
                        this.pos += 1;
                      }
                    }
                    if (this.pos === savepos && c !== C_CLOSE_PAREN2) {
                      return null;
                    }
                    if (openparens !== 0) {
                      return null;
                    }
                    res = this.subject.substr(savepos, this.pos - savepos);
                    return normalizeURI2(unescapeString2(res));
                  }
                  return normalizeURI2(unescapeString2(res.substr(1, res.length - 2)));
                };
                InlineParser3.prototype.parseLinkLabel = function() {
                  var m = this.match(reLinkLabel2);
                  if (m === null || m.length > 1001) {
                    return 0;
                  }
                  return m.length;
                };
                InlineParser3.prototype.parseOpenBracket = function(block3) {
                  var startpos = this.pos;
                  this.pos += 1;
                  var node4 = esm_text("[", this.sourcepos(this.pos, this.pos));
                  block3.appendChild(node4);
                  this.addBracket(node4, startpos, false);
                  return true;
                };
                InlineParser3.prototype.parseBang = function(block3) {
                  var startpos = this.pos;
                  this.pos += 1;
                  if (this.peek() === C_OPEN_BRACKET$12) {
                    this.pos += 1;
                    var node4 = esm_text("![", this.sourcepos(this.pos - 1, this.pos));
                    block3.appendChild(node4);
                    this.addBracket(node4, startpos + 1, true);
                  } else {
                    var node4 = esm_text("!", this.sourcepos(this.pos, this.pos));
                    block3.appendChild(node4);
                  }
                  return true;
                };
                InlineParser3.prototype.parseCloseBracket = function(block3) {
                  var dest = null;
                  var title = null;
                  var matched = false;
                  this.pos += 1;
                  var startpos = this.pos;
                  var opener = this.brackets;
                  if (opener === null) {
                    block3.appendChild(esm_text("]", this.sourcepos(startpos, startpos)));
                    return true;
                  }
                  if (!opener.active) {
                    block3.appendChild(esm_text("]", this.sourcepos(startpos, startpos)));
                    this.removeBracket();
                    return true;
                  }
                  var isImage = opener.image;
                  var savepos = this.pos;
                  if (this.peek() === C_OPEN_PAREN2) {
                    this.pos++;
                    if (this.spnl() && (dest = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
                    (reWhitespaceChar2.test(this.subject.charAt(this.pos - 1)) && (title = this.parseLinkTitle()) || true) && this.spnl() && this.peek() === C_CLOSE_PAREN2) {
                      this.pos += 1;
                      matched = true;
                    } else {
                      this.pos = savepos;
                    }
                  }
                  var refLabel = "";
                  if (!matched) {
                    var beforelabel = this.pos;
                    var n = this.parseLinkLabel();
                    if (n > 2) {
                      refLabel = this.subject.slice(beforelabel, beforelabel + n);
                    } else if (!opener.bracketAfter) {
                      refLabel = this.subject.slice(opener.index, startpos);
                    }
                    if (n === 0) {
                      this.pos = savepos;
                    }
                    if (refLabel) {
                      refLabel = normalizeReference2(refLabel);
                      var link2 = this.refMap[refLabel];
                      if (link2) {
                        dest = link2.destination;
                        title = link2.title;
                        matched = true;
                      }
                    }
                  }
                  if (matched) {
                    var node4 = createNode2(isImage ? "image" : "link");
                    node4.destination = dest;
                    node4.title = title || "";
                    node4.sourcepos = [opener.startpos, this.sourcepos(this.pos)];
                    var tmp = opener.node.next;
                    var next = void 0;
                    while (tmp) {
                      next = tmp.next;
                      tmp.unlink();
                      node4.appendChild(tmp);
                      tmp = next;
                    }
                    block3.appendChild(node4);
                    this.processEmphasis(opener.previousDelimiter);
                    this.removeBracket();
                    opener.node.unlink();
                    if (!isImage) {
                      opener = this.brackets;
                      while (opener !== null) {
                        if (!opener.image) {
                          opener.active = false;
                        }
                        opener = opener.previous;
                      }
                    }
                    if (this.options.referenceDefinition) {
                      this.refLinkCandidateMap[block3.id] = { node: block3, refLabel };
                    }
                    return true;
                  }
                  this.removeBracket();
                  this.pos = startpos;
                  block3.appendChild(esm_text("]", this.sourcepos(startpos, startpos)));
                  if (this.options.referenceDefinition) {
                    this.refLinkCandidateMap[block3.id] = { node: block3, refLabel };
                  }
                  return true;
                };
                InlineParser3.prototype.addBracket = function(node4, index3, image2) {
                  if (this.brackets !== null) {
                    this.brackets.bracketAfter = true;
                  }
                  this.brackets = {
                    node: node4,
                    startpos: this.sourcepos(index3 + (image2 ? 0 : 1)),
                    previous: this.brackets,
                    previousDelimiter: this.delimiters,
                    index: index3,
                    image: image2,
                    active: true
                  };
                };
                InlineParser3.prototype.removeBracket = function() {
                  if (this.brackets) {
                    this.brackets = this.brackets.previous;
                  }
                };
                InlineParser3.prototype.parseEntity = function(block3) {
                  var m;
                  var startpos = this.pos + 1;
                  if (m = this.match(reEntityHere2)) {
                    block3.appendChild(esm_text(lib2.decodeHTML(m), this.sourcepos(startpos, this.pos)));
                    return true;
                  }
                  return false;
                };
                InlineParser3.prototype.parseString = function(block3) {
                  var m;
                  var startpos = this.pos + 1;
                  if (m = this.match(reMain2)) {
                    if (this.options.smart) {
                      var lit = m.replace(reEllipses2, "…").replace(reDash2, function(chars) {
                        var enCount = 0;
                        var emCount = 0;
                        if (chars.length % 3 === 0) {
                          emCount = chars.length / 3;
                        } else if (chars.length % 2 === 0) {
                          enCount = chars.length / 2;
                        } else if (chars.length % 3 === 2) {
                          enCount = 1;
                          emCount = (chars.length - 2) / 3;
                        } else {
                          enCount = 2;
                          emCount = (chars.length - 4) / 3;
                        }
                        return repeat2("—", emCount) + repeat2("–", enCount);
                      });
                      block3.appendChild(esm_text(lit, this.sourcepos(startpos, this.pos)));
                    } else {
                      var node4 = esm_text(m, this.sourcepos(startpos, this.pos));
                      block3.appendChild(node4);
                    }
                    return true;
                  }
                  return false;
                };
                InlineParser3.prototype.parseNewline = function(block3) {
                  this.pos += 1;
                  var lastc = block3.lastChild;
                  if (lastc && lastc.type === "text" && lastc.literal[lastc.literal.length - 1] === " ") {
                    var hardbreak = lastc.literal[lastc.literal.length - 2] === " ";
                    var litLen = lastc.literal.length;
                    lastc.literal = lastc.literal.replace(reFinalSpace2, "");
                    var finalSpaceLen = litLen - lastc.literal.length;
                    lastc.sourcepos[1][1] -= finalSpaceLen;
                    block3.appendChild(createNode2(hardbreak ? "linebreak" : "softbreak", this.sourcepos(this.pos - finalSpaceLen, this.pos)));
                  } else {
                    block3.appendChild(createNode2("softbreak", this.sourcepos(this.pos, this.pos)));
                  }
                  this.nextLine();
                  this.match(reInitialSpace2);
                  return true;
                };
                InlineParser3.prototype.parseReference = function(block3, refMap) {
                  if (!this.options.referenceDefinition) {
                    return 0;
                  }
                  this.subject = block3.stringContent;
                  this.pos = 0;
                  var title = null;
                  var startpos = this.pos;
                  var matchChars = this.parseLinkLabel();
                  if (matchChars === 0) {
                    return 0;
                  }
                  var rawlabel = this.subject.substr(0, matchChars);
                  if (this.peek() === C_COLON2) {
                    this.pos++;
                  } else {
                    this.pos = startpos;
                    return 0;
                  }
                  this.spnl();
                  var dest = this.parseLinkDestination();
                  if (dest === null) {
                    this.pos = startpos;
                    return 0;
                  }
                  var beforetitle = this.pos;
                  this.spnl();
                  if (this.pos !== beforetitle) {
                    title = this.parseLinkTitle();
                  }
                  if (title === null) {
                    title = "";
                    this.pos = beforetitle;
                  }
                  var atLineEnd = true;
                  if (this.match(reSpaceAtEndOfLine2) === null) {
                    if (title === "") {
                      atLineEnd = false;
                    } else {
                      title = "";
                      this.pos = beforetitle;
                      atLineEnd = this.match(reSpaceAtEndOfLine2) !== null;
                    }
                  }
                  if (!atLineEnd) {
                    this.pos = startpos;
                    return 0;
                  }
                  var normalLabel = normalizeReference2(rawlabel);
                  if (normalLabel === "") {
                    this.pos = startpos;
                    return 0;
                  }
                  var sourcepos = this.getReferenceDefSourcepos(block3);
                  block3.sourcepos[0][0] = sourcepos[1][0] + 1;
                  var node4 = createNode2("refDef", sourcepos);
                  node4.title = title;
                  node4.dest = dest;
                  node4.label = normalLabel;
                  block3.insertBefore(node4);
                  if (!refMap[normalLabel]) {
                    refMap[normalLabel] = createRefDefState2(node4);
                  } else {
                    this.refDefCandidateMap[node4.id] = node4;
                  }
                  return this.pos - startpos;
                };
                InlineParser3.prototype.mergeTextNodes = function(walker) {
                  var event;
                  var textNodes = [];
                  while (event = walker.next()) {
                    var entering = event.entering, node4 = event.node;
                    if (entering && node4.type === "text") {
                      textNodes.push(node4);
                    } else if (textNodes.length === 1) {
                      textNodes = [];
                    } else if (textNodes.length > 1) {
                      var firstNode = textNodes[0];
                      var lastNode = textNodes[textNodes.length - 1];
                      if (firstNode.sourcepos && lastNode.sourcepos) {
                        firstNode.sourcepos[1] = lastNode.sourcepos[1];
                      }
                      firstNode.next = lastNode.next;
                      if (firstNode.next) {
                        firstNode.next.prev = firstNode;
                      }
                      for (var i = 1; i < textNodes.length; i += 1) {
                        firstNode.literal += textNodes[i].literal;
                        textNodes[i].unlink();
                      }
                      textNodes = [];
                    }
                  }
                };
                InlineParser3.prototype.getReferenceDefSourcepos = function(block3) {
                  var lines = block3.stringContent.split(/\n|\r\n/);
                  var passedUrlLine = false;
                  var quotationCount = 0;
                  var lastLineOffset = { line: 0, ch: 0 };
                  for (var i = 0; i < lines.length; i += 1) {
                    var line = lines[i];
                    if (reWhitespaceChar2.test(line)) {
                      break;
                    }
                    if (/\:/.test(line) && quotationCount === 0) {
                      if (passedUrlLine) {
                        break;
                      }
                      var lineOffset = line.indexOf(":") === line.length - 1 ? i + 1 : i;
                      lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };
                      passedUrlLine = true;
                    }
                    var matched = line.match(/'|"/g);
                    if (matched) {
                      quotationCount += matched.length;
                    }
                    if (quotationCount === 2) {
                      lastLineOffset = { line: i, ch: line.length };
                      break;
                    }
                  }
                  return [
                    [block3.sourcepos[0][0], block3.sourcepos[0][1]],
                    [block3.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch]
                  ];
                };
                InlineParser3.prototype.parseInline = function(block3) {
                  var _a;
                  var res = false;
                  var c = this.peek();
                  if (c === -1) {
                    return false;
                  }
                  switch (c) {
                    case C_NEWLINE2:
                      res = this.parseNewline(block3);
                      break;
                    case C_BACKSLASH2:
                      res = this.parseBackslash(block3);
                      break;
                    case C_BACKTICK2:
                      res = this.parseBackticks(block3);
                      break;
                    case C_ASTERISK2:
                    case C_UNDERSCORE2:
                    case C_TILDE2:
                    case C_DOLLAR2:
                      res = this.handleDelim(c, block3);
                      break;
                    case C_SINGLEQUOTE2:
                    case C_DOUBLEQUOTE2:
                      res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block3);
                      break;
                    case C_OPEN_BRACKET$12:
                      res = this.parseOpenBracket(block3);
                      break;
                    case C_BANG2:
                      res = this.parseBang(block3);
                      break;
                    case C_CLOSE_BRACKET2:
                      res = this.parseCloseBracket(block3);
                      break;
                    case C_LESSTHAN$12:
                      res = this.parseAutolink(block3) || this.parseHtmlTag(block3);
                      break;
                    case C_AMPERSAND2:
                      if (!block3.disabledEntityParse) {
                        res = this.parseEntity(block3);
                      }
                      break;
                    default:
                      res = this.parseString(block3);
                      break;
                  }
                  if (!res) {
                    this.pos += 1;
                    block3.appendChild(esm_text(fromCodePoint$12(c), this.sourcepos(this.pos, this.pos + 1)));
                  }
                  return true;
                };
                InlineParser3.prototype.parse = function(block3) {
                  this.subject = block3.stringContent.trim();
                  this.pos = 0;
                  this.delimiters = null;
                  this.brackets = null;
                  this.lineOffsets = block3.lineOffsets || [0];
                  this.lineIdx = 0;
                  this.linePosOffset = 0;
                  this.lineStartNum = block3.sourcepos[0][0];
                  if (isHeading2(block3)) {
                    this.lineOffsets[0] += block3.level + 1;
                  }
                  while (this.parseInline(block3)) {
                  }
                  block3.stringContent = null;
                  this.processEmphasis(null);
                  this.mergeTextNodes(block3.walker());
                  var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;
                  if (extendedAutolinks) {
                    convertExtAutoLinks2(block3.walker(), extendedAutolinks);
                  }
                  if (customParser && block3.firstChild) {
                    var event_1;
                    var walker = block3.firstChild.walker();
                    while (event_1 = walker.next()) {
                      var node4 = event_1.node, entering = event_1.entering;
                      if (customParser[node4.type]) {
                        customParser[node4.type](node4, { entering, options: this.options });
                      }
                    }
                  }
                };
                return InlineParser3;
              })()
            );
            var reTaskListItemMarker2 = /^\[([ \txX])\][ \t]+/;
            function taskListItemFinalize2(_, block3) {
              if (block3.firstChild && block3.firstChild.type === "paragraph") {
                var p = block3.firstChild;
                var m = p.stringContent.match(reTaskListItemMarker2);
                if (m) {
                  var mLen = m[0].length;
                  p.stringContent = p.stringContent.substring(mLen - 1);
                  p.sourcepos[0][1] += mLen;
                  p.lineOffsets[0] += mLen;
                  block3.listData.task = true;
                  block3.listData.checked = /[xX]/.test(m[1]);
                }
              }
            }
            var table2 = {
              continue: function() {
                return 0;
              },
              finalize: function() {
              },
              canContain: function(t) {
                return t === "tableHead" || t === "tableBody";
              },
              acceptsLines: false
            };
            var tableBody$12 = {
              continue: function() {
                return 0;
              },
              finalize: function() {
              },
              canContain: function(t) {
                return t === "tableRow";
              },
              acceptsLines: false
            };
            var tableHead$12 = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function(t) {
                return t === "tableRow" || t === "tableDelimRow";
              },
              acceptsLines: false
            };
            var tableDelimRow2 = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function(t) {
                return t === "tableDelimCell";
              },
              acceptsLines: false
            };
            var tableDelimCell2 = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return false;
              },
              acceptsLines: false
            };
            var tableRow2 = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function(t) {
                return t === "tableCell";
              },
              acceptsLines: false
            };
            var tableCell2 = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return false;
              },
              acceptsLines: false
            };
            var CODE_INDENT2 = 4;
            var C_TAB2 = 9;
            var C_GREATERTHAN2 = 62;
            var C_LESSTHAN2 = 60;
            var C_SPACE2 = 32;
            var C_OPEN_BRACKET2 = 91;
            var reNonSpace2 = /[^ \t\f\v\r\n]/;
            var reClosingCodeFence2 = /^(?:`{3,}|~{3,})(?= *$)/;
            function endsWithBlankLine2(block3) {
              var curBlock = block3;
              while (curBlock) {
                if (curBlock.lastLineBlank) {
                  return true;
                }
                var t = curBlock.type;
                if (!curBlock.lastLineChecked && (t === "list" || t === "item")) {
                  curBlock.lastLineChecked = true;
                  curBlock = curBlock.lastChild;
                } else {
                  curBlock.lastLineChecked = true;
                  break;
                }
              }
              return false;
            }
            function peek2(ln, pos) {
              if (pos < ln.length) {
                return ln.charCodeAt(pos);
              }
              return -1;
            }
            function isBlank2(s) {
              return !reNonSpace2.test(s);
            }
            function isSpaceOrTab2(c) {
              return c === C_SPACE2 || c === C_TAB2;
            }
            var reClosingCustomBlock2 = /^\$\$$/;
            var customBlock$12 = {
              continue: function(parser, container) {
                var line = parser.currentLine;
                var match = line.match(reClosingCustomBlock2);
                if (match) {
                  parser.lastLineLength = match[0].length;
                  parser.finalize(container, parser.lineNumber);
                  return 2;
                }
                var i = container.offset;
                while (i > 0 && isSpaceOrTab2(peek2(line, parser.offset))) {
                  parser.advanceOffset(1, true);
                  i--;
                }
                return 0;
              },
              finalize: function(_, block3) {
                if (block3.stringContent === null) {
                  return;
                }
                var content2 = block3.stringContent;
                var newlinePos = content2.indexOf("\n");
                var firstLine = content2.slice(0, newlinePos);
                var rest = content2.slice(newlinePos + 1);
                var infoString = firstLine.match(/^(\s*)(.*)/);
                block3.info = unescapeString2(infoString[2].trim());
                block3.literal = rest;
                block3.stringContent = null;
              },
              canContain: function() {
                return false;
              },
              acceptsLines: true
            };
            var noop2 = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return false;
              },
              acceptsLines: true
            };
            var document$12 = {
              continue: function() {
                return 0;
              },
              finalize: function() {
              },
              canContain: function(t) {
                return t !== "item";
              },
              acceptsLines: false
            };
            var list2 = {
              continue: function() {
                return 0;
              },
              finalize: function(_, block3) {
                var item3 = block3.firstChild;
                while (item3) {
                  if (endsWithBlankLine2(item3) && item3.next) {
                    block3.listData.tight = false;
                    break;
                  }
                  var subitem = item3.firstChild;
                  while (subitem) {
                    if (endsWithBlankLine2(subitem) && (item3.next || subitem.next)) {
                      block3.listData.tight = false;
                      break;
                    }
                    subitem = subitem.next;
                  }
                  item3 = item3.next;
                }
              },
              canContain: function(t) {
                return t === "item";
              },
              acceptsLines: false
            };
            var blockQuote$12 = {
              continue: function(parser) {
                var ln = parser.currentLine;
                if (!parser.indented && peek2(ln, parser.nextNonspace) === C_GREATERTHAN2) {
                  parser.advanceNextNonspace();
                  parser.advanceOffset(1, false);
                  if (isSpaceOrTab2(peek2(ln, parser.offset))) {
                    parser.advanceOffset(1, true);
                  }
                } else {
                  return 1;
                }
                return 0;
              },
              finalize: function() {
              },
              canContain: function(t) {
                return t !== "item";
              },
              acceptsLines: false
            };
            var item2 = {
              continue: function(parser, container) {
                if (parser.blank) {
                  if (container.firstChild === null) {
                    return 1;
                  }
                  parser.advanceNextNonspace();
                } else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {
                  parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);
                } else {
                  return 1;
                }
                return 0;
              },
              finalize: taskListItemFinalize2,
              canContain: function(t) {
                return t !== "item";
              },
              acceptsLines: false
            };
            var heading2 = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return false;
              },
              acceptsLines: false
            };
            var thematicBreak$12 = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return false;
              },
              acceptsLines: false
            };
            var codeBlock2 = {
              continue: function(parser, container) {
                var ln = parser.currentLine;
                var indent2 = parser.indent;
                if (container.isFenced) {
                  var match = indent2 <= 3 && ln.charAt(parser.nextNonspace) === container.fenceChar && ln.slice(parser.nextNonspace).match(reClosingCodeFence2);
                  if (match && match[0].length >= container.fenceLength) {
                    parser.lastLineLength = parser.offset + indent2 + match[0].length;
                    parser.finalize(container, parser.lineNumber);
                    return 2;
                  }
                  var i = container.fenceOffset;
                  while (i > 0 && isSpaceOrTab2(peek2(ln, parser.offset))) {
                    parser.advanceOffset(1, true);
                    i--;
                  }
                } else {
                  if (indent2 >= CODE_INDENT2) {
                    parser.advanceOffset(CODE_INDENT2, true);
                  } else if (parser.blank) {
                    parser.advanceNextNonspace();
                  } else {
                    return 1;
                  }
                }
                return 0;
              },
              finalize: function(_, block3) {
                var _a;
                if (block3.stringContent === null) {
                  return;
                }
                if (block3.isFenced) {
                  var content2 = block3.stringContent;
                  var newlinePos = content2.indexOf("\n");
                  var firstLine = content2.slice(0, newlinePos);
                  var rest = content2.slice(newlinePos + 1);
                  var infoString = firstLine.match(/^(\s*)(.*)/);
                  block3.infoPadding = infoString[1].length;
                  block3.info = unescapeString2(infoString[2].trim());
                  block3.literal = rest;
                } else {
                  block3.literal = (_a = block3.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\n *)+$/, "\n");
                }
                block3.stringContent = null;
              },
              canContain: function() {
                return false;
              },
              acceptsLines: true
            };
            var htmlBlock$12 = {
              continue: function(parser, container) {
                return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7) ? 1 : 0;
              },
              finalize: function(_, block3) {
                var _a;
                block3.literal = ((_a = block3.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\n *)+$/, "")) || null;
                block3.stringContent = null;
              },
              canContain: function() {
                return false;
              },
              acceptsLines: true
            };
            var paragraph2 = {
              continue: function(parser) {
                return parser.blank ? 1 : 0;
              },
              finalize: function(parser, block3) {
                if (block3.stringContent === null) {
                  return;
                }
                var pos;
                var hasReferenceDefs = false;
                while (peek2(block3.stringContent, 0) === C_OPEN_BRACKET2 && (pos = parser.inlineParser.parseReference(block3, parser.refMap))) {
                  block3.stringContent = block3.stringContent.slice(pos);
                  hasReferenceDefs = true;
                }
                if (hasReferenceDefs && isBlank2(block3.stringContent)) {
                  block3.unlink();
                }
              },
              canContain: function() {
                return false;
              },
              acceptsLines: true
            };
            var refDef2 = noop2;
            var frontMatter$22 = noop2;
            var blockHandlers2 = {
              document: document$12,
              list: list2,
              blockQuote: blockQuote$12,
              item: item2,
              heading: heading2,
              thematicBreak: thematicBreak$12,
              codeBlock: codeBlock2,
              htmlBlock: htmlBlock$12,
              paragraph: paragraph2,
              table: table2,
              tableBody: tableBody$12,
              tableHead: tableHead$12,
              tableRow: tableRow2,
              tableCell: tableCell2,
              tableDelimRow: tableDelimRow2,
              tableDelimCell: tableDelimCell2,
              refDef: refDef2,
              customBlock: customBlock$12,
              frontMatter: frontMatter$22
            };
            function parseRowContent2(content2) {
              var startIdx = 0;
              var offset2 = 0;
              var cells = [];
              for (var i = 0; i < content2.length; i += 1) {
                if (content2[i] === "|" && content2[i - 1] !== "\\") {
                  var cell = content2.substring(startIdx, i);
                  if (startIdx === 0 && isEmpty2(cell)) {
                    offset2 = i + 1;
                  } else {
                    cells.push(cell);
                  }
                  startIdx = i + 1;
                }
              }
              if (startIdx < content2.length) {
                var cell = content2.substring(startIdx, content2.length);
                if (!isEmpty2(cell)) {
                  cells.push(cell);
                }
              }
              return [offset2, cells];
            }
            function generateTableCells2(cellType, contents, lineNum, chPos) {
              var cells = [];
              for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {
                var content2 = contents_1[_i];
                var preSpaces = content2.match(/^[ \t]+/);
                var paddingLeft = preSpaces ? preSpaces[0].length : 0;
                var paddingRight = void 0, trimmed = void 0;
                if (paddingLeft === content2.length) {
                  paddingLeft = 0;
                  paddingRight = 0;
                  trimmed = "";
                } else {
                  var postSpaces = content2.match(/[ \t]+$/);
                  paddingRight = postSpaces ? postSpaces[0].length : 0;
                  trimmed = content2.slice(paddingLeft, content2.length - paddingRight);
                }
                var chPosStart = chPos + paddingLeft;
                var tableCell3 = createNode2(cellType, [
                  [lineNum, chPos],
                  [lineNum, chPos + content2.length - 1]
                ]);
                tableCell3.stringContent = trimmed.replace(/\\\|/g, "|");
                tableCell3.startIdx = cells.length;
                tableCell3.endIdx = cells.length;
                tableCell3.lineOffsets = [chPosStart - 1];
                tableCell3.paddingLeft = paddingLeft;
                tableCell3.paddingRight = paddingRight;
                cells.push(tableCell3);
                chPos += content2.length + 1;
              }
              return cells;
            }
            function getColumnFromDelimCell2(cellNode) {
              var align = null;
              var content2 = cellNode.stringContent;
              var firstCh = content2[0];
              var lastCh = content2[content2.length - 1];
              if (lastCh === ":") {
                align = firstCh === ":" ? "center" : "right";
              } else if (firstCh === ":") {
                align = "left";
              }
              return { align };
            }
            var tableHead2 = function(parser, container) {
              var stringContent = container.stringContent;
              if (container.type === "paragraph" && !parser.indented && !parser.blank) {
                var lastNewLineIdx = stringContent.length - 1;
                var lastLineStartIdx = stringContent.lastIndexOf("\n", lastNewLineIdx - 1) + 1;
                var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);
                var delimContent = parser.currentLine.slice(parser.nextNonspace);
                var _a = parseRowContent2(headerContent), headerOffset = _a[0], headerCells = _a[1];
                var _b = parseRowContent2(delimContent), delimOffset = _b[0], delimCells = _b[1];
                var reValidDelimCell_1 = /^[ \t]*:?-+:?[ \t]*$/;
                if (
                  // not checking if the number of header cells and delimiter cells are the same
                  // to consider the case of merged-column (via plugin)
                  !headerCells.length || !delimCells.length || delimCells.some(function(cell) {
                    return !reValidDelimCell_1.test(cell);
                  }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
                  delimCells.length === 1 && delimContent.indexOf("|") !== 0
                ) {
                  return 0;
                }
                var lineOffsets = container.lineOffsets;
                var firstLineNum = parser.lineNumber - 1;
                var firstLineStart = last2(lineOffsets) + 1;
                var table3 = createNode2("table", [
                  [firstLineNum, firstLineStart],
                  [parser.lineNumber, parser.offset]
                ]);
                table3.columns = delimCells.map(function() {
                  return { align: null };
                });
                container.insertAfter(table3);
                if (lineOffsets.length === 1) {
                  container.unlink();
                } else {
                  container.stringContent = stringContent.slice(0, lastLineStartIdx);
                  var paraLastLineStartIdx = stringContent.lastIndexOf("\n", lastLineStartIdx - 2) + 1;
                  var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;
                  parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;
                  parser.finalize(container, firstLineNum - 1);
                }
                parser.advanceOffset(parser.currentLine.length - parser.offset, false);
                var tableHead_1 = createNode2("tableHead", [
                  [firstLineNum, firstLineStart],
                  [parser.lineNumber, parser.offset]
                ]);
                table3.appendChild(tableHead_1);
                var tableHeadRow_1 = createNode2("tableRow", [
                  [firstLineNum, firstLineStart],
                  [firstLineNum, firstLineStart + headerContent.length - 1]
                ]);
                var tableDelimRow_1 = createNode2("tableDelimRow", [
                  [parser.lineNumber, parser.nextNonspace + 1],
                  [parser.lineNumber, parser.offset]
                ]);
                tableHead_1.appendChild(tableHeadRow_1);
                tableHead_1.appendChild(tableDelimRow_1);
                generateTableCells2("tableCell", headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function(cellNode) {
                  tableHeadRow_1.appendChild(cellNode);
                });
                var delimCellNodes = generateTableCells2("tableDelimCell", delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);
                delimCellNodes.forEach(function(cellNode) {
                  tableDelimRow_1.appendChild(cellNode);
                });
                table3.columns = delimCellNodes.map(getColumnFromDelimCell2);
                parser.tip = table3;
                return 2;
              }
              return 0;
            };
            var tableBody2 = function(parser, container) {
              if (container.type !== "table" && container.type !== "tableBody" || !parser.blank && parser.currentLine.indexOf("|") === -1) {
                return 0;
              }
              parser.advanceOffset(parser.currentLine.length - parser.offset, false);
              if (parser.blank) {
                var table_1 = container;
                if (container.type === "tableBody") {
                  table_1 = container.parent;
                  parser.finalize(container, parser.lineNumber - 1);
                }
                parser.finalize(table_1, parser.lineNumber - 1);
                return 0;
              }
              var tableBody3 = container;
              if (container.type === "table") {
                tableBody3 = parser.addChild("tableBody", parser.nextNonspace);
                tableBody3.stringContent = null;
              }
              var tableRow3 = createNode2("tableRow", [
                [parser.lineNumber, parser.nextNonspace + 1],
                [parser.lineNumber, parser.currentLine.length]
              ]);
              tableBody3.appendChild(tableRow3);
              var table3 = tableBody3.parent;
              var content2 = parser.currentLine.slice(parser.nextNonspace);
              var _a = parseRowContent2(content2), offset2 = _a[0], cellContents = _a[1];
              generateTableCells2("tableCell", cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset2).forEach(function(cellNode, idx) {
                if (idx >= table3.columns.length) {
                  cellNode.ignored = true;
                }
                tableRow3.appendChild(cellNode);
              });
              return 2;
            };
            var reCustomBlock2 = /^(\$\$)(\s*[a-zA-Z])+/;
            var reCanBeCustomInline2 = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/;
            var customBlock2 = function(parser) {
              var match;
              if (!parser.indented && !reCanBeCustomInline2.test(parser.currentLine) && (match = parser.currentLine.match(reCustomBlock2))) {
                var syntaxLength = match[1].length;
                parser.closeUnmatchedBlocks();
                var container = parser.addChild("customBlock", parser.nextNonspace);
                container.syntaxLength = syntaxLength;
                container.offset = parser.indent;
                parser.advanceNextNonspace();
                parser.advanceOffset(syntaxLength, false);
                return 2;
              }
              return 0;
            };
            var reCodeFence2 = /^`{3,}(?!.*`)|^~{3,}/;
            var reHtmlBlockOpen2 = [
              /./,
              /^<(?:script|pre|style)(?:\s|>|$)/i,
              /^<!--/,
              /^<[?]/,
              /^<![A-Z]/,
              /^<!\[CDATA\[/,
              /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
              new RegExp("^(?:" + OPENTAG2 + "|" + CLOSETAG2 + ")\\s*$", "i")
            ];
            var reSetextHeadingLine2 = /^(?:=+|-+)[ \t]*$/;
            var reATXHeadingMarker2 = /^#{1,6}(?:[ \t]+|$)/;
            var reThematicBreak2 = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/;
            var reBulletListMarker2 = /^[*+-]/;
            var reOrderedListMarker2 = /^(\d{1,9})([.)])/;
            function parseListMarker2(parser, container) {
              var rest = parser.currentLine.slice(parser.nextNonspace);
              var match;
              var nextc;
              var data = {
                type: "bullet",
                tight: true,
                bulletChar: "",
                start: 0,
                delimiter: "",
                padding: 0,
                markerOffset: parser.indent,
                // GFM: Task List Item
                task: false,
                checked: false
              };
              if (parser.indent >= 4) {
                return null;
              }
              if (match = rest.match(reBulletListMarker2)) {
                data.type = "bullet";
                data.bulletChar = match[0][0];
              } else if ((match = rest.match(reOrderedListMarker2)) && (container.type !== "paragraph" || match[1] === "1")) {
                data.type = "ordered";
                data.start = parseInt(match[1], 10);
                data.delimiter = match[2];
              } else {
                return null;
              }
              nextc = peek2(parser.currentLine, parser.nextNonspace + match[0].length);
              if (!(nextc === -1 || nextc === C_TAB2 || nextc === C_SPACE2)) {
                return null;
              }
              if (container.type === "paragraph" && !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace2)) {
                return null;
              }
              parser.advanceNextNonspace();
              parser.advanceOffset(match[0].length, true);
              var spacesStartCol = parser.column;
              var spacesStartOffset = parser.offset;
              do {
                parser.advanceOffset(1, true);
                nextc = peek2(parser.currentLine, parser.offset);
              } while (parser.column - spacesStartCol < 5 && isSpaceOrTab2(nextc));
              var blankItem = peek2(parser.currentLine, parser.offset) === -1;
              var spacesAfterMarker = parser.column - spacesStartCol;
              if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {
                data.padding = match[0].length + 1;
                parser.column = spacesStartCol;
                parser.offset = spacesStartOffset;
                if (isSpaceOrTab2(peek2(parser.currentLine, parser.offset))) {
                  parser.advanceOffset(1, true);
                }
              } else {
                data.padding = match[0].length + spacesAfterMarker;
              }
              return data;
            }
            function listsMatch2(listData, itemData) {
              return listData.type === itemData.type && listData.delimiter === itemData.delimiter && listData.bulletChar === itemData.bulletChar;
            }
            function isDisallowedDeepHeading2(parser, node4) {
              return parser.options.disallowDeepHeading && (node4.type === "blockQuote" || node4.type === "item");
            }
            var blockQuote2 = function(parser) {
              if (!parser.indented && peek2(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN2) {
                parser.advanceNextNonspace();
                parser.advanceOffset(1, false);
                if (isSpaceOrTab2(peek2(parser.currentLine, parser.offset))) {
                  parser.advanceOffset(1, true);
                }
                parser.closeUnmatchedBlocks();
                parser.addChild("blockQuote", parser.nextNonspace);
                return 1;
              }
              return 0;
            };
            var atxHeading2 = function(parser, container) {
              var match;
              if (!parser.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
              !isDisallowedDeepHeading2(parser, container) && (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker2))) {
                parser.advanceNextNonspace();
                parser.advanceOffset(match[0].length, false);
                parser.closeUnmatchedBlocks();
                var heading3 = parser.addChild("heading", parser.nextNonspace);
                heading3.level = match[0].trim().length;
                heading3.headingType = "atx";
                heading3.stringContent = parser.currentLine.slice(parser.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, "");
                parser.advanceOffset(parser.currentLine.length - parser.offset);
                return 2;
              }
              return 0;
            };
            var fencedCodeBlock2 = function(parser) {
              var match;
              if (!parser.indented && (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence2))) {
                var fenceLength = match[0].length;
                parser.closeUnmatchedBlocks();
                var container = parser.addChild("codeBlock", parser.nextNonspace);
                container.isFenced = true;
                container.fenceLength = fenceLength;
                container.fenceChar = match[0][0];
                container.fenceOffset = parser.indent;
                parser.advanceNextNonspace();
                parser.advanceOffset(fenceLength, false);
                return 2;
              }
              return 0;
            };
            var htmlBlock2 = function(parser, container) {
              if (!parser.indented && peek2(parser.currentLine, parser.nextNonspace) === C_LESSTHAN2) {
                var s = parser.currentLine.slice(parser.nextNonspace);
                var disallowedTags3 = parser.options.disallowedHtmlBlockTags;
                var blockType = void 0;
                for (blockType = 1; blockType <= 7; blockType++) {
                  var matched = s.match(reHtmlBlockOpen2[blockType]);
                  if (matched) {
                    if (blockType === 7) {
                      if (container.type === "paragraph") {
                        return 0;
                      }
                      if (disallowedTags3.length > 0) {
                        var reDisallowedTags = new RegExp("</?(?:" + disallowedTags3.join("|") + ")", "i");
                        if (reDisallowedTags.test(matched[0])) {
                          return 0;
                        }
                      }
                    }
                    parser.closeUnmatchedBlocks();
                    var b = parser.addChild("htmlBlock", parser.offset);
                    b.htmlBlockType = blockType;
                    return 2;
                  }
                }
              }
              return 0;
            };
            var seTextHeading2 = function(parser, container) {
              var match;
              if (container.stringContent !== null && !parser.indented && container.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
              !isDisallowedDeepHeading2(parser, container.parent) && (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine2))) {
                parser.closeUnmatchedBlocks();
                var pos = void 0;
                while (peek2(container.stringContent, 0) === C_OPEN_BRACKET2 && (pos = parser.inlineParser.parseReference(container, parser.refMap))) {
                  container.stringContent = container.stringContent.slice(pos);
                }
                if (container.stringContent.length > 0) {
                  var heading3 = createNode2("heading", container.sourcepos);
                  heading3.level = match[0][0] === "=" ? 1 : 2;
                  heading3.headingType = "setext";
                  heading3.stringContent = container.stringContent;
                  container.insertAfter(heading3);
                  container.unlink();
                  parser.tip = heading3;
                  parser.advanceOffset(parser.currentLine.length - parser.offset, false);
                  return 2;
                }
                return 0;
              }
              return 0;
            };
            var thematicBreak2 = function(parser) {
              if (!parser.indented && reThematicBreak2.test(parser.currentLine.slice(parser.nextNonspace))) {
                parser.closeUnmatchedBlocks();
                parser.addChild("thematicBreak", parser.nextNonspace);
                parser.advanceOffset(parser.currentLine.length - parser.offset, false);
                return 2;
              }
              return 0;
            };
            var listItem2 = function(parser, container) {
              var data;
              var currNode = container;
              if ((!parser.indented || container.type === "list") && (data = parseListMarker2(parser, currNode))) {
                parser.closeUnmatchedBlocks();
                if (parser.tip.type !== "list" || !listsMatch2(currNode.listData, data)) {
                  currNode = parser.addChild("list", parser.nextNonspace);
                  currNode.listData = data;
                }
                currNode = parser.addChild("item", parser.nextNonspace);
                currNode.listData = data;
                return 1;
              }
              return 0;
            };
            var indentedCodeBlock2 = function(parser) {
              if (parser.indented && parser.tip.type !== "paragraph" && !parser.blank) {
                parser.advanceOffset(CODE_INDENT2, true);
                parser.closeUnmatchedBlocks();
                parser.addChild("codeBlock", parser.offset);
                return 2;
              }
              return 0;
            };
            var blockStarts2 = [
              blockQuote2,
              atxHeading2,
              fencedCodeBlock2,
              htmlBlock2,
              seTextHeading2,
              thematicBreak2,
              listItem2,
              indentedCodeBlock2,
              tableHead2,
              tableBody2,
              customBlock2
            ];
            var reFrontMatter2 = /^(-{3}|\+{3}|;{3})$/;
            var frontMatter$12 = function(parser, container) {
              var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;
              if (lineNumber === 1 && !indented && container.type === "document" && reFrontMatter2.test(currentLine)) {
                parser.closeUnmatchedBlocks();
                var frontMatter_1 = parser.addChild("frontMatter", parser.nextNonspace);
                frontMatter_1.stringContent = currentLine;
                parser.advanceNextNonspace();
                parser.advanceOffset(currentLine.length, false);
                return 2;
              }
              return 0;
            };
            var frontMatter2 = {
              continue: function(parser, container) {
                var line = parser.currentLine;
                var match = line.match(reFrontMatter2);
                if (container.type === "frontMatter" && match) {
                  container.stringContent += line;
                  parser.lastLineLength = match[0].length;
                  parser.finalize(container, parser.lineNumber);
                  return 2;
                }
                return 0;
              },
              finalize: function(_, block3) {
                if (block3.stringContent === null) {
                  return;
                }
                block3.literal = block3.stringContent;
                block3.stringContent = null;
              },
              canContain: function() {
                return false;
              },
              acceptsLines: true
            };
            var reHtmlBlockClose2 = [
              /./,
              /<\/(?:script|pre|style)>/i,
              /-->/,
              /\?>/,
              />/,
              /\]\]>/
            ];
            var reMaybeSpecial2 = /^[#`~*+_=<>0-9-;$]/;
            var reLineEnding$12 = /\r\n|\n|\r/;
            function esm_document() {
              return createNode2("document", [
                [1, 1],
                [0, 0]
              ]);
            }
            var defaultOptions$12 = {
              smart: false,
              tagFilter: false,
              extendedAutolinks: false,
              disallowedHtmlBlockTags: [],
              referenceDefinition: false,
              disallowDeepHeading: false,
              customParser: null,
              frontMatter: false
            };
            var Parser2 = (
              /** @class */
              (function() {
                function Parser3(options) {
                  this.options = esm_assign(esm_assign({}, defaultOptions$12), options);
                  this.doc = esm_document();
                  this.tip = this.doc;
                  this.oldtip = this.doc;
                  this.lineNumber = 0;
                  this.offset = 0;
                  this.column = 0;
                  this.nextNonspace = 0;
                  this.nextNonspaceColumn = 0;
                  this.indent = 0;
                  this.currentLine = "";
                  this.indented = false;
                  this.blank = false;
                  this.partiallyConsumedTab = false;
                  this.allClosed = true;
                  this.lastMatchedContainer = this.doc;
                  this.refMap = {};
                  this.refLinkCandidateMap = {};
                  this.refDefCandidateMap = {};
                  this.lastLineLength = 0;
                  this.lines = [];
                  if (this.options.frontMatter) {
                    blockHandlers2.frontMatter = frontMatter2;
                    blockStarts2.unshift(frontMatter$12);
                  }
                  this.inlineParser = new InlineParser2(this.options);
                }
                Parser3.prototype.advanceOffset = function(count, columns) {
                  if (columns === void 0) {
                    columns = false;
                  }
                  var currentLine = this.currentLine;
                  var charsToTab, charsToAdvance;
                  var c;
                  while (count > 0 && (c = currentLine[this.offset])) {
                    if (c === "	") {
                      charsToTab = 4 - this.column % 4;
                      if (columns) {
                        this.partiallyConsumedTab = charsToTab > count;
                        charsToAdvance = charsToTab > count ? count : charsToTab;
                        this.column += charsToAdvance;
                        this.offset += this.partiallyConsumedTab ? 0 : 1;
                        count -= charsToAdvance;
                      } else {
                        this.partiallyConsumedTab = false;
                        this.column += charsToTab;
                        this.offset += 1;
                        count -= 1;
                      }
                    } else {
                      this.partiallyConsumedTab = false;
                      this.offset += 1;
                      this.column += 1;
                      count -= 1;
                    }
                  }
                };
                Parser3.prototype.advanceNextNonspace = function() {
                  this.offset = this.nextNonspace;
                  this.column = this.nextNonspaceColumn;
                  this.partiallyConsumedTab = false;
                };
                Parser3.prototype.findNextNonspace = function() {
                  var currentLine = this.currentLine;
                  var i = this.offset;
                  var cols = this.column;
                  var c;
                  while ((c = currentLine.charAt(i)) !== "") {
                    if (c === " ") {
                      i++;
                      cols++;
                    } else if (c === "	") {
                      i++;
                      cols += 4 - cols % 4;
                    } else {
                      break;
                    }
                  }
                  this.blank = c === "\n" || c === "\r" || c === "";
                  this.nextNonspace = i;
                  this.nextNonspaceColumn = cols;
                  this.indent = this.nextNonspaceColumn - this.column;
                  this.indented = this.indent >= CODE_INDENT2;
                };
                Parser3.prototype.addLine = function() {
                  if (this.partiallyConsumedTab) {
                    this.offset += 1;
                    var charsToTab = 4 - this.column % 4;
                    this.tip.stringContent += repeat2(" ", charsToTab);
                  }
                  if (this.tip.lineOffsets) {
                    this.tip.lineOffsets.push(this.offset);
                  } else {
                    this.tip.lineOffsets = [this.offset];
                  }
                  this.tip.stringContent += this.currentLine.slice(this.offset) + "\n";
                };
                Parser3.prototype.addChild = function(tag, offset2) {
                  while (!blockHandlers2[this.tip.type].canContain(tag)) {
                    this.finalize(this.tip, this.lineNumber - 1);
                  }
                  var columnNumber = offset2 + 1;
                  var newBlock = createNode2(tag, [
                    [this.lineNumber, columnNumber],
                    [0, 0]
                  ]);
                  newBlock.stringContent = "";
                  this.tip.appendChild(newBlock);
                  this.tip = newBlock;
                  return newBlock;
                };
                Parser3.prototype.closeUnmatchedBlocks = function() {
                  if (!this.allClosed) {
                    while (this.oldtip !== this.lastMatchedContainer) {
                      var parent_1 = this.oldtip.parent;
                      this.finalize(this.oldtip, this.lineNumber - 1);
                      this.oldtip = parent_1;
                    }
                    this.allClosed = true;
                  }
                };
                Parser3.prototype.finalize = function(block3, lineNumber) {
                  var above = block3.parent;
                  block3.open = false;
                  block3.sourcepos[1] = [lineNumber, this.lastLineLength];
                  blockHandlers2[block3.type].finalize(this, block3);
                  this.tip = above;
                };
                Parser3.prototype.processInlines = function(block3) {
                  var event;
                  var customParser = this.options.customParser;
                  var walker = block3.walker();
                  this.inlineParser.refMap = this.refMap;
                  this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;
                  this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;
                  this.inlineParser.options = this.options;
                  while (event = walker.next()) {
                    var node4 = event.node, entering = event.entering;
                    var t = node4.type;
                    if (customParser && customParser[t]) {
                      customParser[t](node4, { entering, options: this.options });
                    }
                    if (!entering && (t === "paragraph" || t === "heading" || t === "tableCell" && !node4.ignored)) {
                      this.inlineParser.parse(node4);
                    }
                  }
                };
                Parser3.prototype.incorporateLine = function(ln) {
                  var container = this.doc;
                  this.oldtip = this.tip;
                  this.offset = 0;
                  this.column = 0;
                  this.blank = false;
                  this.partiallyConsumedTab = false;
                  this.lineNumber += 1;
                  if (ln.indexOf("\0") !== -1) {
                    ln = ln.replace(/\0/g, "�");
                  }
                  this.currentLine = ln;
                  var allMatched = true;
                  var lastChild;
                  while ((lastChild = container.lastChild) && lastChild.open) {
                    container = lastChild;
                    this.findNextNonspace();
                    switch (blockHandlers2[container.type]["continue"](this, container)) {
                      case 0:
                        break;
                      case 1:
                        allMatched = false;
                        break;
                      case 2:
                        this.lastLineLength = ln.length;
                        return;
                      default:
                        throw new Error("continue returned illegal value, must be 0, 1, or 2");
                    }
                    if (!allMatched) {
                      container = container.parent;
                      break;
                    }
                  }
                  this.allClosed = container === this.oldtip;
                  this.lastMatchedContainer = container;
                  var matchedLeaf = container.type !== "paragraph" && blockHandlers2[container.type].acceptsLines;
                  var blockStartsLen = blockStarts2.length;
                  while (!matchedLeaf) {
                    this.findNextNonspace();
                    if (container.type !== "table" && container.type !== "tableBody" && container.type !== "paragraph" && !this.indented && !reMaybeSpecial2.test(ln.slice(this.nextNonspace))) {
                      this.advanceNextNonspace();
                      break;
                    }
                    var i = 0;
                    while (i < blockStartsLen) {
                      var res = blockStarts2[i](this, container);
                      if (res === 1) {
                        container = this.tip;
                        break;
                      } else if (res === 2) {
                        container = this.tip;
                        matchedLeaf = true;
                        break;
                      } else {
                        i++;
                      }
                    }
                    if (i === blockStartsLen) {
                      this.advanceNextNonspace();
                      break;
                    }
                  }
                  if (!this.allClosed && !this.blank && this.tip.type === "paragraph") {
                    this.addLine();
                  } else {
                    this.closeUnmatchedBlocks();
                    if (this.blank && container.lastChild) {
                      container.lastChild.lastLineBlank = true;
                    }
                    var t = container.type;
                    var lastLineBlank = this.blank && !(t === "blockQuote" || isCodeBlock2(container) && container.isFenced || t === "item" && !container.firstChild && container.sourcepos[0][0] === this.lineNumber);
                    var cont = container;
                    while (cont) {
                      cont.lastLineBlank = lastLineBlank;
                      cont = cont.parent;
                    }
                    if (blockHandlers2[t].acceptsLines) {
                      this.addLine();
                      if (isHtmlBlock2(container) && container.htmlBlockType >= 1 && container.htmlBlockType <= 5 && reHtmlBlockClose2[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {
                        this.lastLineLength = ln.length;
                        this.finalize(container, this.lineNumber);
                      }
                    } else if (this.offset < ln.length && !this.blank) {
                      container = this.addChild("paragraph", this.offset);
                      this.advanceNextNonspace();
                      this.addLine();
                    }
                  }
                  this.lastLineLength = ln.length;
                };
                Parser3.prototype.parse = function(input, lineTexts) {
                  this.doc = esm_document();
                  this.tip = this.doc;
                  this.lineNumber = 0;
                  this.lastLineLength = 0;
                  this.offset = 0;
                  this.column = 0;
                  this.lastMatchedContainer = this.doc;
                  this.currentLine = "";
                  var lines = input.split(reLineEnding$12);
                  var len = lines.length;
                  this.lines = lineTexts ? lineTexts : lines;
                  if (this.options.referenceDefinition) {
                    this.clearRefMaps();
                  }
                  if (input.charCodeAt(input.length - 1) === C_NEWLINE2) {
                    len -= 1;
                  }
                  for (var i = 0; i < len; i++) {
                    this.incorporateLine(lines[i]);
                  }
                  while (this.tip) {
                    this.finalize(this.tip, len);
                  }
                  this.processInlines(this.doc);
                  return this.doc;
                };
                Parser3.prototype.partialParseStart = function(lineNumber, lines) {
                  this.doc = esm_document();
                  this.tip = this.doc;
                  this.lineNumber = lineNumber - 1;
                  this.lastLineLength = 0;
                  this.offset = 0;
                  this.column = 0;
                  this.lastMatchedContainer = this.doc;
                  this.currentLine = "";
                  var len = lines.length;
                  for (var i = 0; i < len; i++) {
                    this.incorporateLine(lines[i]);
                  }
                  return this.doc;
                };
                Parser3.prototype.partialParseExtends = function(lines) {
                  for (var i = 0; i < lines.length; i++) {
                    this.incorporateLine(lines[i]);
                  }
                };
                Parser3.prototype.partialParseFinish = function() {
                  while (this.tip) {
                    this.finalize(this.tip, this.lineNumber);
                  }
                  this.processInlines(this.doc);
                };
                Parser3.prototype.setRefMaps = function(refMap, refLinkCandidateMap, refDefCandidateMap) {
                  this.refMap = refMap;
                  this.refLinkCandidateMap = refLinkCandidateMap;
                  this.refDefCandidateMap = refDefCandidateMap;
                };
                Parser3.prototype.clearRefMaps = function() {
                  [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(map15) {
                    clearObj2(map15);
                  });
                };
                return Parser3;
              })()
            );
            function comparePos2(p1, p2) {
              if (p1[0] < p2[0]) {
                return 1;
              }
              if (p1[0] > p2[0]) {
                return -1;
              }
              if (p1[1] < p2[1]) {
                return 1;
              }
              if (p1[1] > p2[1]) {
                return -1;
              }
              return 0;
            }
            function compareRangeAndPos2(_a, pos) {
              var startPos = _a[0], endPos = _a[1];
              if (comparePos2(endPos, pos) === 1) {
                return 1;
              }
              if (comparePos2(startPos, pos) === -1) {
                return -1;
              }
              return 0;
            }
            function removeNextUntil2(node4, last3) {
              if (node4.parent !== last3.parent || node4 === last3) {
                return;
              }
              var next = node4.next;
              while (next && next !== last3) {
                var temp = next.next;
                for (var _i = 0, _a = ["parent", "prev", "next"]; _i < _a.length; _i++) {
                  var type = _a[_i];
                  if (next[type]) {
                    removeNodeById2(next[type].id);
                    next[type] = null;
                  }
                }
                next = temp;
              }
              node4.next = last3.next;
              if (last3.next) {
                last3.next.prev = node4;
              } else {
                node4.parent.lastChild = node4;
              }
            }
            function getChildNodes2(parent) {
              var nodes = [];
              var curr = parent.firstChild;
              while (curr) {
                nodes.push(curr);
                curr = curr.next;
              }
              return nodes;
            }
            function insertNodesBefore2(target3, nodes) {
              for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node4 = nodes_1[_i];
                target3.insertBefore(node4);
              }
            }
            function prependChildNodes2(parent, nodes) {
              for (var i = nodes.length - 1; i >= 0; i -= 1) {
                parent.prependChild(nodes[i]);
              }
            }
            function updateNextLineNumbers2(base2, diff2) {
              if (!base2 || !base2.parent || diff2 === 0) {
                return;
              }
              var walker = base2.parent.walker();
              walker.resumeAt(base2, true);
              var event;
              while (event = walker.next()) {
                var node4 = event.node, entering = event.entering;
                if (entering) {
                  node4.sourcepos[0][0] += diff2;
                  node4.sourcepos[1][0] += diff2;
                }
              }
            }
            function compareRangeAndLine2(_a, line) {
              var startPos = _a[0], endPos = _a[1];
              if (endPos[0] < line) {
                return 1;
              }
              if (startPos[0] > line) {
                return -1;
              }
              return 0;
            }
            function findChildNodeAtLine2(parent, line) {
              var node4 = parent.firstChild;
              while (node4) {
                var comp3 = compareRangeAndLine2(node4.sourcepos, line);
                if (comp3 === 0) {
                  return node4;
                }
                if (comp3 === -1) {
                  return node4.prev || node4;
                }
                node4 = node4.next;
              }
              return parent.lastChild;
            }
            function lastLeafNode2(node4) {
              while (node4.lastChild) {
                node4 = node4.lastChild;
              }
              return node4;
            }
            function sameLineTopAncestor2(node4) {
              while (node4.parent && node4.parent.type !== "document" && node4.parent.sourcepos[0][0] === node4.sourcepos[0][0]) {
                node4 = node4.parent;
              }
              return node4;
            }
            function findFirstNodeAtLine2(parent, line) {
              var node4 = parent.firstChild;
              var prev = null;
              while (node4) {
                var comp3 = compareRangeAndLine2(node4.sourcepos, line);
                if (comp3 === 0) {
                  if (node4.sourcepos[0][0] === line || !node4.firstChild) {
                    return node4;
                  }
                  prev = node4;
                  node4 = node4.firstChild;
                } else if (comp3 === -1) {
                  break;
                } else {
                  prev = node4;
                  node4 = node4.next;
                }
              }
              if (prev) {
                return sameLineTopAncestor2(lastLeafNode2(prev));
              }
              return null;
            }
            function findNodeAtPosition2(parent, pos) {
              var node4 = parent;
              var prev = null;
              while (node4) {
                var comp3 = compareRangeAndPos2(node4.sourcepos, pos);
                if (comp3 === 0) {
                  if (node4.firstChild) {
                    prev = node4;
                    node4 = node4.firstChild;
                  } else {
                    return node4;
                  }
                } else if (comp3 === -1) {
                  return prev;
                } else if (node4.next) {
                  node4 = node4.next;
                } else {
                  return prev;
                }
              }
              return node4;
            }
            function findNodeById2(id) {
              return getNodeById2(id) || null;
            }
            function invokeNextUntil2(callback, start3, end2) {
              if (end2 === void 0) {
                end2 = null;
              }
              if (start3) {
                var walker = start3.walker();
                while (start3 && start3 !== end2) {
                  callback(start3);
                  var next = walker.next();
                  if (next) {
                    start3 = next.node;
                  } else {
                    break;
                  }
                }
              }
            }
            function isUnlinked2(id) {
              var node4 = findNodeById2(id);
              if (!node4) {
                return true;
              }
              while (node4 && node4.type !== "document") {
                if (!node4.parent && !node4.prev && !node4.next) {
                  return true;
                }
                node4 = node4.parent;
              }
              return false;
            }
            var reLineEnding2 = /\r\n|\n|\r/;
            function canBeContinuedListItem2(lineText) {
              var spaceMatch = lineText.match(/^[ \t]+/);
              if (spaceMatch && (spaceMatch[0].length >= 2 || /\t/.test(spaceMatch[0]))) {
                return true;
              }
              var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;
              return reBulletListMarker2.test(leftTrimmed) || reOrderedListMarker2.test(leftTrimmed);
            }
            function canBeContinuedTableBody2(lineText) {
              return !isBlank2(lineText) && lineText.indexOf("|") !== -1;
            }
            function createRefDefState2(node4) {
              var id = node4.id, title = node4.title, sourcepos = node4.sourcepos, dest = node4.dest;
              return {
                id,
                title,
                sourcepos,
                unlinked: false,
                destination: dest
              };
            }
            var ToastMark2 = (
              /** @class */
              (function() {
                function ToastMark3(contents, options) {
                  this.refMap = {};
                  this.refLinkCandidateMap = {};
                  this.refDefCandidateMap = {};
                  this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);
                  this.parser = new Parser2(options);
                  this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);
                  this.eventHandlerMap = { change: [] };
                  contents = contents || "";
                  this.lineTexts = contents.split(reLineEnding2);
                  this.root = this.parser.parse(contents, this.lineTexts);
                }
                ToastMark3.prototype.updateLineTexts = function(startPos, endPos, newText) {
                  var _a;
                  var startLine = startPos[0], startCol = startPos[1];
                  var endLine = endPos[0], endCol = endPos[1];
                  var newLines = newText.split(reLineEnding2);
                  var newLineLen = newLines.length;
                  var startLineText = this.lineTexts[startLine - 1];
                  var endLineText = this.lineTexts[endLine - 1];
                  newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];
                  newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);
                  var removedLineLen = endLine - startLine + 1;
                  (_a = this.lineTexts).splice.apply(_a, esm_spreadArray([startLine - 1, removedLineLen], newLines));
                  return newLineLen - removedLineLen;
                };
                ToastMark3.prototype.updateRootNodeState = function() {
                  if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
                    this.root.lastLineBlank = true;
                    this.root.sourcepos = [
                      [1, 1],
                      [1, 0]
                    ];
                    return;
                  }
                  if (this.root.lastChild) {
                    this.root.lastLineBlank = this.root.lastChild.lastLineBlank;
                  }
                  var lineTexts = this.lineTexts;
                  var idx = lineTexts.length - 1;
                  while (lineTexts[idx] === "") {
                    idx -= 1;
                  }
                  if (lineTexts.length - 2 > idx) {
                    idx += 1;
                  }
                  this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];
                };
                ToastMark3.prototype.replaceRangeNodes = function(startNode, endNode, newNodes) {
                  if (!startNode) {
                    if (endNode) {
                      insertNodesBefore2(endNode, newNodes);
                      removeNodeById2(endNode.id);
                      endNode.unlink();
                    } else {
                      prependChildNodes2(this.root, newNodes);
                    }
                  } else {
                    insertNodesBefore2(startNode, newNodes);
                    removeNextUntil2(startNode, endNode);
                    [startNode.id, endNode.id].forEach(function(id) {
                      return removeNodeById2(id);
                    });
                    startNode.unlink();
                  }
                };
                ToastMark3.prototype.getNodeRange = function(startPos, endPos) {
                  var startNode = findChildNodeAtLine2(this.root, startPos[0]);
                  var endNode = findChildNodeAtLine2(this.root, endPos[0]);
                  if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {
                    endNode = endNode.next;
                  }
                  return [startNode, endNode];
                };
                ToastMark3.prototype.trigger = function(eventName, param) {
                  this.eventHandlerMap[eventName].forEach(function(handler) {
                    handler(param);
                  });
                };
                ToastMark3.prototype.extendEndLine = function(line) {
                  while (this.lineTexts[line] === "") {
                    line += 1;
                  }
                  return line;
                };
                ToastMark3.prototype.parseRange = function(startNode, endNode, startLine, endLine) {
                  if (startNode && startNode.prev && (isList2(startNode.prev) && canBeContinuedListItem2(this.lineTexts[startLine - 1]) || isTable2(startNode.prev) && canBeContinuedTableBody2(this.lineTexts[startLine - 1]))) {
                    startNode = startNode.prev;
                    startLine = startNode.sourcepos[0][0];
                  }
                  var editedLines = this.lineTexts.slice(startLine - 1, endLine);
                  var root = this.parser.partialParseStart(startLine, editedLines);
                  var nextNode = endNode ? endNode.next : this.root.firstChild;
                  var lastChild = root.lastChild;
                  var isOpenedLastChildCodeBlock = lastChild && isCodeBlock2(lastChild) && lastChild.open;
                  var isOpenedLastChildCustomBlock = lastChild && isCustomBlock2(lastChild) && lastChild.open;
                  var isLastChildList = lastChild && isList2(lastChild);
                  while ((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode || isLastChildList && nextNode && (nextNode.type === "list" || nextNode.sourcepos[0][1] >= 2)) {
                    var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);
                    this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));
                    if (!startNode) {
                      startNode = endNode;
                    }
                    endNode = nextNode;
                    endLine = newEndLine;
                    nextNode = nextNode.next;
                  }
                  this.parser.partialParseFinish();
                  var newNodes = getChildNodes2(root);
                  return { newNodes, extStartNode: startNode, extEndNode: endNode };
                };
                ToastMark3.prototype.getRemovedNodeRange = function(extStartNode, extEndNode) {
                  if (!extStartNode || extStartNode && isRefDef2(extStartNode) || extEndNode && isRefDef2(extEndNode)) {
                    return null;
                  }
                  return {
                    id: [extStartNode.id, extEndNode.id],
                    line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1]
                  };
                };
                ToastMark3.prototype.markDeletedRefMap = function(extStartNode, extEndNode) {
                  var _this = this;
                  if (!isEmptyObj2(this.refMap)) {
                    var markDeleted = function(node4) {
                      if (isRefDef2(node4)) {
                        var refDefState = _this.refMap[node4.label];
                        if (refDefState && node4.id === refDefState.id) {
                          refDefState.unlinked = true;
                        }
                      }
                    };
                    if (extStartNode) {
                      invokeNextUntil2(markDeleted, extStartNode.parent, extEndNode);
                    }
                    if (extEndNode) {
                      invokeNextUntil2(markDeleted, extEndNode);
                    }
                  }
                };
                ToastMark3.prototype.replaceWithNewRefDefState = function(nodes) {
                  var _this = this;
                  if (!isEmptyObj2(this.refMap)) {
                    var replaceWith_1 = function(node4) {
                      if (isRefDef2(node4)) {
                        var label = node4.label;
                        var refDefState = _this.refMap[label];
                        if (!refDefState || refDefState.unlinked) {
                          _this.refMap[label] = createRefDefState2(node4);
                        }
                      }
                    };
                    nodes.forEach(function(node4) {
                      invokeNextUntil2(replaceWith_1, node4);
                    });
                  }
                };
                ToastMark3.prototype.replaceWithRefDefCandidate = function() {
                  var _this = this;
                  if (!isEmptyObj2(this.refDefCandidateMap)) {
                    iterateObject2(this.refDefCandidateMap, function(_, candidate) {
                      var label = candidate.label, sourcepos = candidate.sourcepos;
                      var refDefState = _this.refMap[label];
                      if (!refDefState || refDefState.unlinked || refDefState.sourcepos[0][0] > sourcepos[0][0]) {
                        _this.refMap[label] = createRefDefState2(candidate);
                      }
                    });
                  }
                };
                ToastMark3.prototype.getRangeWithRefDef = function(startLine, endLine, startNode, endNode, lineDiff) {
                  if (this.referenceDefinition && !isEmptyObj2(this.refMap)) {
                    var prevNode = findChildNodeAtLine2(this.root, startLine - 1);
                    var nextNode = findChildNodeAtLine2(this.root, endLine + 1);
                    if (prevNode && isRefDef2(prevNode) && prevNode !== startNode && prevNode !== endNode) {
                      startNode = prevNode;
                      startLine = startNode.sourcepos[0][0];
                    }
                    if (nextNode && isRefDef2(nextNode) && nextNode !== startNode && nextNode !== endNode) {
                      endNode = nextNode;
                      endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);
                    }
                  }
                  return [startNode, endNode, startLine, endLine];
                };
                ToastMark3.prototype.parse = function(startPos, endPos, lineDiff) {
                  if (lineDiff === void 0) {
                    lineDiff = 0;
                  }
                  var range3 = this.getNodeRange(startPos, endPos);
                  var startNode = range3[0], endNode = range3[1];
                  var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];
                  var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);
                  var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));
                  var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;
                  var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);
                  var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;
                  if (this.referenceDefinition) {
                    this.markDeletedRefMap(extStartNode, extEndNode);
                    this.replaceRangeNodes(extStartNode, extEndNode, newNodes);
                    this.replaceWithNewRefDefState(newNodes);
                  } else {
                    this.replaceRangeNodes(extStartNode, extEndNode, newNodes);
                  }
                  return { nodes: newNodes, removedNodeRange, nextNode };
                };
                ToastMark3.prototype.parseRefLink = function() {
                  var _this = this;
                  var result2 = [];
                  if (!isEmptyObj2(this.refMap)) {
                    iterateObject2(this.refMap, function(label, value) {
                      if (value.unlinked) {
                        delete _this.refMap[label];
                      }
                      iterateObject2(_this.refLinkCandidateMap, function(_, candidate) {
                        var node4 = candidate.node, refLabel = candidate.refLabel;
                        if (refLabel === label) {
                          result2.push(_this.parse(node4.sourcepos[0], node4.sourcepos[1]));
                        }
                      });
                    });
                  }
                  return result2;
                };
                ToastMark3.prototype.removeUnlinkedCandidate = function() {
                  if (!isEmptyObj2(this.refDefCandidateMap)) {
                    [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(candidateMap) {
                      iterateObject2(candidateMap, function(id) {
                        if (isUnlinked2(id)) {
                          delete candidateMap[id];
                        }
                      });
                    });
                  }
                };
                ToastMark3.prototype.editMarkdown = function(startPos, endPos, newText) {
                  var lineDiff = this.updateLineTexts(startPos, endPos, newText);
                  var parseResult = this.parse(startPos, endPos, lineDiff);
                  var editResult = omit2(parseResult, "nextNode");
                  updateNextLineNumbers2(parseResult.nextNode, lineDiff);
                  this.updateRootNodeState();
                  var result2 = [editResult];
                  if (this.referenceDefinition) {
                    this.removeUnlinkedCandidate();
                    this.replaceWithRefDefCandidate();
                    result2 = result2.concat(this.parseRefLink());
                  }
                  this.trigger("change", result2);
                  return result2;
                };
                ToastMark3.prototype.getLineTexts = function() {
                  return this.lineTexts;
                };
                ToastMark3.prototype.getRootNode = function() {
                  return this.root;
                };
                ToastMark3.prototype.findNodeAtPosition = function(pos) {
                  var node4 = findNodeAtPosition2(this.root, pos);
                  if (!node4 || node4 === this.root) {
                    return null;
                  }
                  return node4;
                };
                ToastMark3.prototype.findFirstNodeAtLine = function(line) {
                  return findFirstNodeAtLine2(this.root, line);
                };
                ToastMark3.prototype.on = function(eventName, callback) {
                  this.eventHandlerMap[eventName].push(callback);
                };
                ToastMark3.prototype.off = function(eventName, callback) {
                  var handlers2 = this.eventHandlerMap[eventName];
                  var idx = handlers2.indexOf(callback);
                  handlers2.splice(idx, 1);
                };
                ToastMark3.prototype.findNodeById = function(id) {
                  return findNodeById2(id);
                };
                ToastMark3.prototype.removeAllNode = function() {
                  removeAllNode2();
                };
                return ToastMark3;
              })()
            );
            var disallowedTags2 = [
              "title",
              "textarea",
              "style",
              "xmp",
              "iframe",
              "noembed",
              "noframes",
              "script",
              "plaintext"
            ];
            var reDisallowedTag2 = new RegExp("<(/?(?:" + disallowedTags2.join("|") + ")[^>]*>)", "ig");
            function filterDisallowedTags2(str) {
              if (reDisallowedTag2.test(str)) {
                return str.replace(reDisallowedTag2, function(_, group) {
                  return "&lt;" + group;
                });
              }
              return str;
            }
            var baseConvertors2 = {
              heading: function(node4, _a) {
                var entering = _a.entering;
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "h" + node4.level,
                  outerNewLine: true
                };
              },
              text: function(node4) {
                return {
                  type: "text",
                  content: node4.literal
                };
              },
              softbreak: function(_, _a) {
                var options = _a.options;
                return {
                  type: "html",
                  content: options.softbreak
                };
              },
              linebreak: function() {
                return {
                  type: "html",
                  content: "<br />\n"
                };
              },
              emph: function(_, _a) {
                var entering = _a.entering;
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "em"
                };
              },
              strong: function(_, _a) {
                var entering = _a.entering;
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "strong"
                };
              },
              paragraph: function(node4, _a) {
                var _b;
                var entering = _a.entering;
                var grandparent = (_b = node4.parent) === null || _b === void 0 ? void 0 : _b.parent;
                if (grandparent && grandparent.type === "list") {
                  if (grandparent.listData.tight) {
                    return null;
                  }
                }
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "p",
                  outerNewLine: true
                };
              },
              thematicBreak: function() {
                return {
                  type: "openTag",
                  tagName: "hr",
                  outerNewLine: true,
                  selfClose: true
                };
              },
              blockQuote: function(_, _a) {
                var entering = _a.entering;
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "blockquote",
                  outerNewLine: true,
                  innerNewLine: true
                };
              },
              list: function(node4, _a) {
                var entering = _a.entering;
                var _b = node4.listData, type = _b.type, start3 = _b.start;
                var tagName = type === "bullet" ? "ul" : "ol";
                var attributes = {};
                if (tagName === "ol" && start3 !== null && start3 !== 1) {
                  attributes.start = start3.toString();
                }
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName,
                  attributes,
                  outerNewLine: true
                };
              },
              item: function(_, _a) {
                var entering = _a.entering;
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "li",
                  outerNewLine: true
                };
              },
              htmlInline: function(node4, _a) {
                var options = _a.options;
                var content2 = options.tagFilter ? filterDisallowedTags2(node4.literal) : node4.literal;
                return { type: "html", content: content2 };
              },
              htmlBlock: function(node4, _a) {
                var options = _a.options;
                var content2 = options.tagFilter ? filterDisallowedTags2(node4.literal) : node4.literal;
                if (options.nodeId) {
                  return [
                    { type: "openTag", tagName: "div", outerNewLine: true },
                    { type: "html", content: content2 },
                    { type: "closeTag", tagName: "div", outerNewLine: true }
                  ];
                }
                return { type: "html", content: content2, outerNewLine: true };
              },
              code: function(node4) {
                return [
                  { type: "openTag", tagName: "code" },
                  { type: "text", content: node4.literal },
                  { type: "closeTag", tagName: "code" }
                ];
              },
              codeBlock: function(node4) {
                var infoStr = node4.info;
                var infoWords = infoStr ? infoStr.split(/\s+/) : [];
                var codeClassNames = [];
                if (infoWords.length > 0 && infoWords[0].length > 0) {
                  codeClassNames.push("language-" + escapeXml2(infoWords[0]));
                }
                return [
                  { type: "openTag", tagName: "pre", outerNewLine: true },
                  { type: "openTag", tagName: "code", classNames: codeClassNames },
                  { type: "text", content: node4.literal },
                  { type: "closeTag", tagName: "code" },
                  { type: "closeTag", tagName: "pre", outerNewLine: true }
                ];
              },
              link: function(node4, _a) {
                var entering = _a.entering;
                if (entering) {
                  var _b = node4, title = _b.title, destination = _b.destination;
                  return {
                    type: "openTag",
                    tagName: "a",
                    attributes: esm_assign({ href: escapeXml2(destination) }, title && { title: escapeXml2(title) })
                  };
                }
                return { type: "closeTag", tagName: "a" };
              },
              image: function(node4, _a) {
                var getChildrenText3 = _a.getChildrenText, skipChildren = _a.skipChildren;
                var _b = node4, title = _b.title, destination = _b.destination;
                skipChildren();
                return {
                  type: "openTag",
                  tagName: "img",
                  selfClose: true,
                  attributes: esm_assign({ src: escapeXml2(destination), alt: getChildrenText3(node4) }, title && { title: escapeXml2(title) })
                };
              },
              customBlock: function(node4, context, convertors2) {
                var info = node4.info.trim().toLowerCase();
                var customConvertor = convertors2[info];
                if (customConvertor) {
                  try {
                    return customConvertor(node4, context);
                  } catch (e) {
                    console.warn("[@toast-ui/editor] - The error occurred when " + info + " block node was parsed in markdown renderer: " + e);
                  }
                }
                return [
                  { type: "openTag", tagName: "div", outerNewLine: true },
                  { type: "text", content: node4.literal },
                  { type: "closeTag", tagName: "div", outerNewLine: true }
                ];
              },
              frontMatter: function(node4) {
                return [
                  {
                    type: "openTag",
                    tagName: "div",
                    outerNewLine: true,
                    // Because front matter is metadata, it should not be render.
                    attributes: { style: "white-space: pre; display: none;" }
                  },
                  { type: "text", content: node4.literal },
                  { type: "closeTag", tagName: "div", outerNewLine: true }
                ];
              },
              customInline: function(node4, context, convertors2) {
                var _a = node4, info = _a.info, firstChild = _a.firstChild;
                var nomalizedInfo = info.trim().toLowerCase();
                var customConvertor = convertors2[nomalizedInfo];
                var entering = context.entering;
                if (customConvertor) {
                  try {
                    return customConvertor(node4, context);
                  } catch (e) {
                    console.warn("[@toast-ui/editor] - The error occurred when " + nomalizedInfo + " inline node was parsed in markdown renderer: " + e);
                  }
                }
                return entering ? [
                  { type: "openTag", tagName: "span" },
                  { type: "text", content: "$$" + info + (firstChild ? " " : "") }
                ] : [
                  { type: "text", content: "$$" },
                  { type: "closeTag", tagName: "span" }
                ];
              }
            };
            var gfmConvertors2 = {
              strike: function(_, _a) {
                var entering = _a.entering;
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "del"
                };
              },
              item: function(node4, _a) {
                var entering = _a.entering;
                var _b = node4.listData, checked = _b.checked, task2 = _b.task;
                if (entering) {
                  var itemTag = {
                    type: "openTag",
                    tagName: "li",
                    outerNewLine: true
                  };
                  if (task2) {
                    return [
                      itemTag,
                      {
                        type: "openTag",
                        tagName: "input",
                        selfClose: true,
                        attributes: esm_assign(esm_assign({}, checked && { checked: "" }), { disabled: "", type: "checkbox" })
                      },
                      {
                        type: "text",
                        content: " "
                      }
                    ];
                  }
                  return itemTag;
                }
                return {
                  type: "closeTag",
                  tagName: "li",
                  outerNewLine: true
                };
              },
              table: function(_, _a) {
                var entering = _a.entering;
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "table",
                  outerNewLine: true
                };
              },
              tableHead: function(_, _a) {
                var entering = _a.entering;
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "thead",
                  outerNewLine: true
                };
              },
              tableBody: function(_, _a) {
                var entering = _a.entering;
                return {
                  type: entering ? "openTag" : "closeTag",
                  tagName: "tbody",
                  outerNewLine: true
                };
              },
              tableRow: function(node4, _a) {
                var entering = _a.entering;
                if (entering) {
                  return {
                    type: "openTag",
                    tagName: "tr",
                    outerNewLine: true
                  };
                }
                var result2 = [];
                if (node4.lastChild) {
                  var columnLen = node4.parent.parent.columns.length;
                  var lastColIdx = node4.lastChild.endIdx;
                  for (var i = lastColIdx + 1; i < columnLen; i += 1) {
                    result2.push({
                      type: "openTag",
                      tagName: "td",
                      outerNewLine: true
                    }, {
                      type: "closeTag",
                      tagName: "td",
                      outerNewLine: true
                    });
                  }
                }
                result2.push({
                  type: "closeTag",
                  tagName: "tr",
                  outerNewLine: true
                });
                return result2;
              },
              tableCell: function(node4, _a) {
                var entering = _a.entering;
                if (node4.ignored) {
                  return {
                    type: "text",
                    content: ""
                  };
                }
                var tablePart = node4.parent.parent;
                var tagName = tablePart.type === "tableHead" ? "th" : "td";
                var table3 = tablePart.parent;
                var columnInfo = table3.columns[node4.startIdx];
                var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;
                if (entering) {
                  return esm_assign({ type: "openTag", tagName, outerNewLine: true }, attributes && { attributes });
                }
                return {
                  type: "closeTag",
                  tagName,
                  outerNewLine: true
                };
              }
            };
            var defaultOptions2 = {
              softbreak: "\n",
              gfm: false,
              tagFilter: false,
              nodeId: false
            };
            function getChildrenText2(node4) {
              var buffer = [];
              var walker = node4.walker();
              var event = null;
              while (event = walker.next()) {
                var node_1 = event.node;
                if (node_1.type === "text") {
                  buffer.push(node_1.literal);
                }
              }
              return buffer.join("");
            }
            var Renderer2 = (
              /** @class */
              (function() {
                function Renderer3(customOptions) {
                  this.buffer = [];
                  this.options = esm_assign(esm_assign({}, defaultOptions2), customOptions);
                  this.convertors = this.createConvertors();
                  delete this.options.convertors;
                }
                Renderer3.prototype.createConvertors = function() {
                  var convertors2 = esm_assign({}, baseConvertors2);
                  if (this.options.gfm) {
                    convertors2 = esm_assign(esm_assign({}, convertors2), gfmConvertors2);
                  }
                  if (this.options.convertors) {
                    var customConvertors_1 = this.options.convertors;
                    var nodeTypes = Object.keys(customConvertors_1);
                    var defaultConvertors_1 = esm_assign(esm_assign({}, baseConvertors2), gfmConvertors2);
                    nodeTypes.forEach(function(nodeType2) {
                      var orgConvertor = convertors2[nodeType2];
                      var convertor = customConvertors_1[nodeType2];
                      var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType2) === -1 ? nodeType2.toLowerCase() : nodeType2;
                      if (orgConvertor) {
                        convertors2[convertorType] = function(node4, context, convertors3) {
                          context.origin = function() {
                            return orgConvertor(node4, context, convertors3);
                          };
                          return convertor(node4, context);
                        };
                      } else {
                        convertors2[convertorType] = convertor;
                      }
                    });
                  }
                  return convertors2;
                };
                Renderer3.prototype.getConvertors = function() {
                  return this.convertors;
                };
                Renderer3.prototype.getOptions = function() {
                  return this.options;
                };
                Renderer3.prototype.render = function(rootNode) {
                  var _this = this;
                  this.buffer = [];
                  var walker = rootNode.walker();
                  var event = null;
                  var _loop_1 = function() {
                    var node4 = event.node, entering = event.entering;
                    var convertor = this_1.convertors[node4.type];
                    if (!convertor) {
                      return "continue";
                    }
                    var skipped = false;
                    var context = {
                      entering,
                      leaf: !isContainer2(node4),
                      options: this_1.options,
                      getChildrenText: getChildrenText2,
                      skipChildren: function() {
                        skipped = true;
                      }
                    };
                    var converted = isCustomBlock2(node4) || isCustomInline2(node4) ? convertor(node4, context, this_1.convertors) : convertor(node4, context);
                    if (converted) {
                      var htmlNodes = Array.isArray(converted) ? converted : [converted];
                      htmlNodes.forEach(function(htmlNode, index3) {
                        if (htmlNode.type === "openTag" && _this.options.nodeId && index3 === 0) {
                          if (!htmlNode.attributes) {
                            htmlNode.attributes = {};
                          }
                          htmlNode.attributes["data-nodeid"] = String(node4.id);
                        }
                        _this.renderHTMLNode(htmlNode);
                      });
                      if (skipped) {
                        walker.resumeAt(node4, false);
                        walker.next();
                      }
                    }
                  };
                  var this_1 = this;
                  while (event = walker.next()) {
                    _loop_1();
                  }
                  this.addNewLine();
                  return this.buffer.join("");
                };
                Renderer3.prototype.renderHTMLNode = function(node4) {
                  switch (node4.type) {
                    case "openTag":
                    case "closeTag":
                      this.renderElementNode(node4);
                      break;
                    case "text":
                      this.renderTextNode(node4);
                      break;
                    case "html":
                      this.renderRawHtmlNode(node4);
                      break;
                  }
                };
                Renderer3.prototype.generateOpenTagString = function(node4) {
                  var _this = this;
                  var tagName = node4.tagName, classNames = node4.classNames, attributes = node4.attributes;
                  this.buffer.push("<" + tagName);
                  if (classNames && classNames.length > 0) {
                    this.buffer.push(' class="' + classNames.join(" ") + '"');
                  }
                  if (attributes) {
                    Object.keys(attributes).forEach(function(attrName) {
                      var attrValue = attributes[attrName];
                      _this.buffer.push(" " + attrName + '="' + attrValue + '"');
                    });
                  }
                  if (node4.selfClose) {
                    this.buffer.push(" /");
                  }
                  this.buffer.push(">");
                };
                Renderer3.prototype.generateCloseTagString = function(_a) {
                  var tagName = _a.tagName;
                  this.buffer.push("</" + tagName + ">");
                };
                Renderer3.prototype.addNewLine = function() {
                  if (this.buffer.length && last2(last2(this.buffer)) !== "\n") {
                    this.buffer.push("\n");
                  }
                };
                Renderer3.prototype.addOuterNewLine = function(node4) {
                  if (node4.outerNewLine) {
                    this.addNewLine();
                  }
                };
                Renderer3.prototype.addInnerNewLine = function(node4) {
                  if (node4.innerNewLine) {
                    this.addNewLine();
                  }
                };
                Renderer3.prototype.renderTextNode = function(node4) {
                  this.buffer.push(escapeXml2(node4.content));
                };
                Renderer3.prototype.renderRawHtmlNode = function(node4) {
                  this.addOuterNewLine(node4);
                  this.buffer.push(node4.content);
                  this.addOuterNewLine(node4);
                };
                Renderer3.prototype.renderElementNode = function(node4) {
                  if (node4.type === "openTag") {
                    this.addOuterNewLine(node4);
                    this.generateOpenTagString(node4);
                    if (node4.selfClose) {
                      this.addOuterNewLine(node4);
                    } else {
                      this.addInnerNewLine(node4);
                    }
                  } else {
                    this.addInnerNewLine(node4);
                    this.generateCloseTagString(node4);
                    this.addOuterNewLine(node4);
                  }
                };
                return Renderer3;
              })()
            );
            var collection_forEachOwnProperties = __webpack_require__(956);
            var forEachOwnProperties_default = __webpack_require__.n(collection_forEachOwnProperties);
            var extend2 = __webpack_require__(969);
            var extend_default = __webpack_require__.n(extend2);
            var on2 = __webpack_require__(348);
            var on_default = __webpack_require__.n(on2);
            var off2 = __webpack_require__(349);
            var off_default = __webpack_require__.n(off2);
            var addClass2 = __webpack_require__(204);
            var addClass_default = __webpack_require__.n(addClass2);
            var removeClass2 = __webpack_require__(462);
            var removeClass_default = __webpack_require__.n(removeClass2);
            var css2 = __webpack_require__(522);
            var css_default = __webpack_require__.n(css2);
            var collection_toArray = __webpack_require__(990);
            var toArray_default = __webpack_require__.n(collection_toArray);
            var type_isArray = __webpack_require__(322);
            var isArray_default = __webpack_require__.n(type_isArray);
            var type_isString = __webpack_require__(758);
            var isString_default = __webpack_require__.n(type_isString);
            var type_isUndefined = __webpack_require__(929);
            var isUndefined_default = __webpack_require__.n(type_isUndefined);
            var hasClass2 = __webpack_require__(714);
            var hasClass_default = __webpack_require__.n(hasClass2);
            var domUtil_matches = __webpack_require__(471);
            ;
            var TAG_NAME2 = "[A-Za-z][A-Za-z0-9-]*";
            var ATTRIBUTE_NAME2 = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
            var UNQUOTED_VALUE2 = "[^\"'=<>`\\x00-\\x20]+";
            var SINGLE_QUOTED_VALUE2 = "'[^']*'";
            var DOUBLE_QUOTED_VALUE2 = '"[^"]*"';
            var ATTRIBUTE_VALUE2 = "(?:" + UNQUOTED_VALUE2 + "|" + SINGLE_QUOTED_VALUE2 + "|" + DOUBLE_QUOTED_VALUE2 + ")";
            var ATTRIBUTE_VALUE_SPEC2 = "(?:\\s*=\\s*" + ATTRIBUTE_VALUE2 + ")";
            var constants_ATTRIBUTE = "(?:\\s+" + ATTRIBUTE_NAME2 + ATTRIBUTE_VALUE_SPEC2 + "?)";
            var constants_OPEN_TAG = "<(" + TAG_NAME2 + ")(" + constants_ATTRIBUTE + ")*\\s*/?>";
            var CLOSE_TAG2 = "</(" + TAG_NAME2 + ")\\s*[>]";
            var constants_HTML_TAG = "(?:" + constants_OPEN_TAG + "|" + CLOSE_TAG2 + ")";
            var reHTMLTag2 = new RegExp("^" + constants_HTML_TAG, "i");
            var constants_reBR = /<br\s*\/*>/i;
            var reHTMLComment2 = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;
            var constants_ALTERNATIVE_TAG_FOR_BR = "</p><p>";
            var DEFAULT_TEXT_NOT_START_OR_END_WITH_SPACE2 = "a";
            var type_isNull = __webpack_require__(934);
            var request_sendHostname = __webpack_require__(391);
            ;
            var isMac = /Mac/.test(navigator.platform);
            var reSpaceMoreThanOne2 = /[\u0020]+/g;
            var common_reEscapeChars = /[>(){}[\]+-.!#|]/g;
            var reEscapeHTML2 = /<([a-zA-Z_][a-zA-Z0-9\-._]*)(\s|[^\\>])*\/?>|<(\/)([a-zA-Z_][a-zA-Z0-9\-._]*)\s*\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\-.:/]*)>/g;
            var reEscapeBackSlash2 = /\\[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~\\]/g;
            var reEscapePairedChars2 = /[*_~`]/g;
            var reMdImageSyntax2 = /!\[.*\]\(.*\)/g;
            var reEscapedCharInLinkSyntax2 = /[[\]]/g;
            var reEscapeBackSlashInSentence2 = /(?:^|[^\\])\\(?!\\)/g;
            var common_XMLSPECIAL = '[&<>"]';
            var common_reXmlSpecial = new RegExp(common_XMLSPECIAL, "g");
            function common_replaceUnsafeChar(char) {
              switch (char) {
                case "&":
                  return "&amp;";
                case "<":
                  return "&lt;";
                case ">":
                  return "&gt;";
                case '"':
                  return "&quot;";
                default:
                  return char;
              }
            }
            function common_escapeXml(text3) {
              if (common_reXmlSpecial.test(text3)) {
                return text3.replace(common_reXmlSpecial, common_replaceUnsafeChar);
              }
              return text3;
            }
            function sendHostName2() {
              sendHostname("editor", "UA-129966929-1");
            }
            function common_includes(arr, targetItem) {
              return arr.indexOf(targetItem) !== -1;
            }
            var availableLinkAttributes2 = ["rel", "target", "hreflang", "type"];
            var reMarkdownTextToEscapeMap2 = {
              codeblock: /(^ {4}[^\n]+\n*)+/,
              thematicBreak: /^ *((\* *){3,}|(- *){3,} *|(_ *){3,}) */,
              atxHeading: /^(#{1,6}) +[\s\S]+/,
              seTextheading: /^([^\n]+)\n *(=|-){2,} */,
              blockquote: /^( *>[^\n]+.*)+/,
              list: /^ *(\*+|-+|\d+\.) [\s\S]+/,
              def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? */,
              link: /!?\[.*\]\(.*\)/,
              reflink: /!?\[.*\]\s*\[([^\]]*)\]/,
              verticalBar: /\u007C/,
              fencedCodeblock: /^((`|~){3,})/
            };
            function sanitizeLinkAttribute2(attribute) {
              if (!attribute) {
                return null;
              }
              var linkAttributes = {};
              availableLinkAttributes2.forEach(function(key) {
                if (!isUndefined_default()(attribute[key])) {
                  linkAttributes[key] = attribute[key];
                }
              });
              return linkAttributes;
            }
            function common_repeat(text3, count) {
              var result2 = "";
              for (var i = 0; i < count; i += 1) {
                result2 += text3;
              }
              return result2;
            }
            function isNeedEscapeText2(text3) {
              var needEscape = false;
              forEachOwnProperties(reMarkdownTextToEscapeMap2, function(reMarkdownTextToEscape) {
                if (reMarkdownTextToEscape.test(text3)) {
                  needEscape = true;
                }
                return !needEscape;
              });
              return needEscape;
            }
            function escapeTextForLink2(text3) {
              var imageSyntaxRanges = [];
              var result2 = reMdImageSyntax2.exec(text3);
              while (result2) {
                imageSyntaxRanges.push([result2.index, result2.index + result2[0].length]);
                result2 = reMdImageSyntax2.exec(text3);
              }
              return text3.replace(reEscapedCharInLinkSyntax2, function(matched, offset2) {
                var isDelimiter = imageSyntaxRanges.some(function(range3) {
                  return offset2 > range3[0] && offset2 < range3[1];
                });
                return isDelimiter ? matched : "\\" + matched;
              });
            }
            function common_escape(text3) {
              var aheadReplacer = function(matched) {
                return "\\" + matched;
              };
              var behindReplacer = function(matched) {
                return matched + "\\";
              };
              var escapedText = text3.replace(reSpaceMoreThanOne2, " ");
              if (reEscapeBackSlash2.test(escapedText)) {
                escapedText = escapedText.replace(reEscapeBackSlash2, aheadReplacer);
              }
              if (reEscapeBackSlashInSentence2.test(escapedText)) {
                escapedText = escapedText.replace(reEscapeBackSlashInSentence2, behindReplacer);
              }
              escapedText = escapedText.replace(reEscapePairedChars2, aheadReplacer);
              if (reEscapeHTML2.test(escapedText)) {
                escapedText = escapedText.replace(reEscapeHTML2, aheadReplacer);
              }
              if (isNeedEscapeText2(escapedText)) {
                escapedText = escapedText.replace(common_reEscapeChars, aheadReplacer);
              }
              return escapedText;
            }
            function quote2(text3) {
              var result2;
              if (text3.indexOf('"') === -1) {
                result2 = '""';
              } else {
                result2 = text3.indexOf("'") === -1 ? "''" : "()";
              }
              return result2[0] + text3 + result2[1];
            }
            function common_isNil(value) {
              return isNull(value) || isUndefined(value);
            }
            function shallowEqual2(o1, o2) {
              if (o1 === null && o1 === o2) {
                return true;
              }
              if (typeof o1 !== "object" || typeof o2 !== "object" || common_isNil(o1) || common_isNil(o2)) {
                return o1 === o2;
              }
              for (var key in o1) {
                if (o1[key] !== o2[key]) {
                  return false;
                }
              }
              for (var key in o2) {
                if (!(key in o1)) {
                  return false;
                }
              }
              return true;
            }
            function common_last(arr) {
              return arr[arr.length - 1];
            }
            function common_between(value, min2, max2) {
              return value >= min2 && value <= max2;
            }
            function isObject2(obj) {
              return typeof obj === "object" && obj !== null;
            }
            function deepMergedCopy2(targetObj, obj) {
              var resultObj = tslib_es6_assign({}, targetObj);
              if (targetObj && obj) {
                Object.keys(obj).forEach(function(prop3) {
                  if (isObject2(resultObj[prop3])) {
                    if (Array.isArray(obj[prop3])) {
                      resultObj[prop3] = deepCopyArray2(obj[prop3]);
                    } else if (resultObj.hasOwnProperty(prop3)) {
                      resultObj[prop3] = deepMergedCopy2(resultObj[prop3], obj[prop3]);
                    } else {
                      resultObj[prop3] = deepCopy2(obj[prop3]);
                    }
                  } else {
                    resultObj[prop3] = obj[prop3];
                  }
                });
              }
              return resultObj;
            }
            function deepCopyArray2(items) {
              return items.map(function(item3) {
                if (isObject2(item3)) {
                  return Array.isArray(item3) ? deepCopyArray2(item3) : deepCopy2(item3);
                }
                return item3;
              });
            }
            function deepCopy2(obj) {
              var keys2 = Object.keys(obj);
              if (!keys2.length) {
                return obj;
              }
              return keys2.reduce(function(acc, prop3) {
                if (isObject2(obj[prop3])) {
                  acc[prop3] = Array.isArray(obj[prop3]) ? deepCopyArray2(obj[prop3]) : deepCopy2(obj[prop3]);
                } else {
                  acc[prop3] = obj[prop3];
                }
                return acc;
              }, {});
            }
            function common_assign(targetObj, obj) {
              if (obj === void 0) {
                obj = {};
              }
              Object.keys(obj).forEach(function(prop3) {
                if (targetObj.hasOwnProperty(prop3) && typeof targetObj[prop3] === "object") {
                  if (Array.isArray(obj[prop3])) {
                    targetObj[prop3] = obj[prop3];
                  } else {
                    common_assign(targetObj[prop3], obj[prop3]);
                  }
                } else {
                  targetObj[prop3] = obj[prop3];
                }
              });
              return targetObj;
            }
            function getSortedNumPair2(valueA, valueB) {
              return valueA > valueB ? [valueB, valueA] : [valueA, valueB];
            }
            function isStartWithSpace2(text3) {
              var reStartWithSpace = /^\s(\S*)/g;
              return reStartWithSpace.test(text3);
            }
            function isEndWithSpace2(text3) {
              var reEndWithSpace = /(\S*)\s$/g;
              return reEndWithSpace.test(text3);
            }
            ;
            function isPositionInBox2(style, offsetX, offsetY) {
              var left = parseInt(style.left, 10);
              var top2 = parseInt(style.top, 10);
              var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);
              var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);
              return offsetX >= left && offsetX <= left + width && offsetY >= top2 && offsetY <= top2 + height;
            }
            var CLS_PREFIX2 = "toastui-editor-";
            function cls2() {
              var names = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                names[_i] = arguments[_i];
              }
              var result2 = [];
              for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {
                var name = names_1[_a];
                var className = void 0;
                if (Array.isArray(name)) {
                  className = name[0] ? name[1] : null;
                } else {
                  className = name;
                }
                if (className) {
                  result2.push("" + CLS_PREFIX2 + className);
                }
              }
              return result2.join(" ");
            }
            function clsWithMdPrefix2() {
              var names = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                names[_i] = arguments[_i];
              }
              return names.map(function(className) {
                return CLS_PREFIX2 + "md-" + className;
              }).join(" ");
            }
            function isTextNode2(node4) {
              return (node4 === null || node4 === void 0 ? void 0 : node4.nodeType) === Node.TEXT_NODE;
            }
            function isElemNode2(node4) {
              return node4 && node4.nodeType === Node.ELEMENT_NODE;
            }
            function findNodes2(element, selector) {
              var nodeList = toArray(element.querySelectorAll(selector));
              if (nodeList.length) {
                return nodeList;
              }
              return [];
            }
            function appendNodes2(node4, nodesToAppend) {
              nodesToAppend = isArray(nodesToAppend) ? toArray(nodesToAppend) : [nodesToAppend];
              nodesToAppend.forEach(function(nodeToAppend) {
                node4.appendChild(nodeToAppend);
              });
            }
            function insertBeforeNode2(insertedNode, node4) {
              if (node4.parentNode) {
                node4.parentNode.insertBefore(insertedNode, node4);
              }
            }
            function removeNode2(node4) {
              if (node4.parentNode) {
                node4.parentNode.removeChild(node4);
              }
            }
            function unwrapNode2(node4) {
              var result2 = [];
              while (node4.firstChild) {
                result2.push(node4.firstChild);
                if (node4.parentNode) {
                  node4.parentNode.insertBefore(node4.firstChild, node4);
                }
              }
              removeNode2(node4);
              return result2;
            }
            function toggleClass2(element, className, state) {
              if (isUndefined_default()(state)) {
                state = !hasClass_default()(element, className);
              }
              var toggleFn = state ? addClass_default() : removeClass_default();
              toggleFn(element, className);
            }
            function createElementWith2(contents, target3) {
              var container = document.createElement("div");
              if (isString_default()(contents)) {
                container.innerHTML = contents;
              } else {
                container.appendChild(contents);
              }
              var firstChild = container.firstChild;
              if (target3) {
                target3.appendChild(firstChild);
              }
              return firstChild;
            }
            function getOuterWidth2(el3) {
              var computed = window.getComputedStyle(el3);
              return ["margin-left", "margin-right"].reduce(function(acc, type) {
                return acc + parseInt(computed.getPropertyValue(type), 10);
              }, 0) + el3.offsetWidth;
            }
            function closest2(node4, found2) {
              var condition;
              if (isString(found2)) {
                condition = function(target3) {
                  return matches(target3, found2);
                };
              } else {
                condition = function(target3) {
                  return target3 === found2;
                };
              }
              while (node4 && node4 !== document) {
                if (isElemNode2(node4) && condition(node4)) {
                  return node4;
                }
                node4 = node4.parentNode;
              }
              return null;
            }
            function getTotalOffset2(el3, root) {
              var offsetTop = 0;
              var offsetLeft = 0;
              while (el3 && el3 !== root) {
                var top2 = el3.offsetTop, left = el3.offsetLeft, offsetParent = el3.offsetParent;
                offsetTop += top2;
                offsetLeft += left;
                if (offsetParent === root.offsetParent) {
                  break;
                }
                el3 = el3.offsetParent;
              }
              return { offsetTop, offsetLeft };
            }
            function finalizeHtml(html2, needHtmlText) {
              var result2;
              if (needHtmlText) {
                result2 = html2.innerHTML;
              } else {
                var frag = document.createDocumentFragment();
                var childNodes = toArray(html2.childNodes);
                var length = childNodes.length;
                for (var i = 0; i < length; i += 1) {
                  frag.appendChild(childNodes[i]);
                }
                result2 = frag;
              }
              return result2;
            }
            function dom_empty(node4) {
              while (node4.firstChild) {
                node4.removeChild(node4.firstChild);
              }
            }
            function appendNode(node4, appended) {
              if (isString(appended)) {
                node4.insertAdjacentHTML("beforeend", appended);
              } else {
                var nodes = appended.length ? toArray(appended) : [appended];
                for (var i = 0, len = nodes.length; i < len; i += 1) {
                  node4.appendChild(nodes[i]);
                }
              }
            }
            function prependNode(node4, appended) {
              if (isString(appended)) {
                node4.insertAdjacentHTML("afterbegin", appended);
              } else {
                var nodes = appended.length ? toArray(appended) : [appended];
                for (var i = nodes.length - 1, len = 0; i >= len; i -= 1) {
                  node4.insertBefore(nodes[i], node4.firstChild);
                }
              }
            }
            function setAttributes2(attributes, element) {
              Object.keys(attributes).forEach(function(attrName) {
                if (isNil(attributes[attrName])) {
                  element.removeAttribute(attrName);
                } else {
                  element.setAttribute(attrName, attributes[attrName]);
                }
              });
            }
            function replaceBRWithEmptyBlock2(html2) {
              var replacedHTML = html2.replace(/<p><br\s*\/*><\/p>/gi, "<p></p>");
              var reHTMLTag3 = new RegExp(HTML_TAG, "ig");
              var htmlTagMatched = replacedHTML.match(reHTMLTag3);
              htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function(htmlTag, index3) {
                if (reBR.test(htmlTag)) {
                  var alternativeTag = ALTERNATIVE_TAG_FOR_BR;
                  if (index3) {
                    var prevTag = htmlTagMatched[index3 - 1];
                    var openTagMatched = prevTag.match(OPEN_TAG);
                    if (openTagMatched && !/br/i.test(openTagMatched[1])) {
                      var tagName = openTagMatched[1];
                      alternativeTag = "</" + tagName + "><" + tagName + ">";
                    }
                  }
                  replacedHTML = replacedHTML.replace(reBR, alternativeTag);
                }
              });
              return replacedHTML;
            }
            var isFunction2 = __webpack_require__(294);
            var isFunction_default = __webpack_require__.n(isFunction2);
            ;
            function hasSpecificTypeAncestor(mdNode) {
              var types = [];
              for (var _i = 1; _i < arguments.length; _i++) {
                types[_i - 1] = arguments[_i];
              }
              while (mdNode && mdNode.parent && mdNode.parent.type !== "document") {
                if (includes(types, mdNode.parent.type)) {
                  return true;
                }
                mdNode = mdNode.parent;
              }
              return false;
            }
            function markdown_getMdStartLine(mdNode) {
              return mdNode.sourcepos[0][0];
            }
            function markdown_getMdEndLine(mdNode) {
              return mdNode.sourcepos[1][0];
            }
            function getMdStartCh2(mdNode) {
              return mdNode.sourcepos[0][1];
            }
            function getMdEndCh2(mdNode) {
              return mdNode.sourcepos[1][1];
            }
            function isMultiLineNode(mdNode) {
              var type = mdNode.type;
              return type === "codeBlock" || type === "paragraph";
            }
            function isHTMLNode2(mdNode) {
              var type = mdNode.type;
              return type === "htmlBlock" || type === "htmlInline";
            }
            function markdown_isStyledInlineNode(mdNode) {
              var type = mdNode.type;
              return type === "strike" || type === "strong" || type === "emph" || type === "code" || type === "link" || type === "image";
            }
            function isCodeBlockNode2(mdNode) {
              return mdNode && mdNode.type === "codeBlock";
            }
            function isCustomBlockNode(mdNode) {
              return mdNode && mdNode.type === "customBlock";
            }
            function isListNode2(mdNode) {
              return mdNode && (mdNode.type === "item" || mdNode.type === "list");
            }
            function isOrderedListNode2(mdNode) {
              return isListNode2(mdNode) && mdNode.listData.type === "ordered";
            }
            function isBulletListNode2(mdNode) {
              return isListNode2(mdNode) && mdNode.listData.type !== "ordered";
            }
            function isTableCellNode2(mdNode) {
              return mdNode && (mdNode.type === "tableCell" || mdNode.type === "tableDelimCell");
            }
            function isInlineNode2(mdNode) {
              switch (mdNode.type) {
                case "code":
                case "text":
                case "emph":
                case "strong":
                case "strike":
                case "link":
                case "image":
                case "htmlInline":
                case "linebreak":
                case "softbreak":
                case "customInline":
                  return true;
                default:
                  return false;
              }
            }
            function findClosestNode2(mdNode, condition, includeSelf) {
              if (includeSelf === void 0) {
                includeSelf = true;
              }
              mdNode = includeSelf ? mdNode : mdNode.parent;
              while (mdNode && mdNode.type !== "document") {
                if (condition(mdNode)) {
                  return mdNode;
                }
                mdNode = mdNode.parent;
              }
              return null;
            }
            function traverseParentNodes2(mdNode, iteratee, includeSelf) {
              if (includeSelf === void 0) {
                includeSelf = true;
              }
              mdNode = includeSelf ? mdNode : mdNode.parent;
              while (mdNode && mdNode.type !== "document") {
                iteratee(mdNode);
                mdNode = mdNode.parent;
              }
            }
            function addOffsetPos2(originPos, offset2) {
              return [originPos[0], originPos[1] + offset2];
            }
            function setOffsetPos2(originPos, newOffset) {
              return [originPos[0], newOffset];
            }
            function getInlineMarkdownText2(mdNode) {
              var text3 = mdNode.firstChild.literal;
              switch (mdNode.type) {
                case "emph":
                  return "*" + text3 + "*";
                case "strong":
                  return "**" + text3 + "**";
                case "strike":
                  return "~~" + text3 + "~~";
                case "code":
                  return "`" + text3 + "`";
                case "link":
                case "image":
                  var _a = mdNode, destination = _a.destination, title = _a.title;
                  var delim = mdNode.type === "link" ? "" : "!";
                  return delim + "[" + text3 + "](" + destination + (title ? ' "' + title + '"' : "") + ")";
                default:
                  return null;
              }
            }
            function markdown_isContainer(node4) {
              switch (node4.type) {
                case "document":
                case "blockQuote":
                case "list":
                case "item":
                case "paragraph":
                case "heading":
                case "emph":
                case "strong":
                case "strike":
                case "link":
                case "image":
                case "table":
                case "tableHead":
                case "tableBody":
                case "tableRow":
                case "tableCell":
                case "tableDelimRow":
                case "customInline":
                  return true;
                default:
                  return false;
              }
            }
            function markdown_getChildrenText(node4) {
              var buffer = [];
              var walker = node4.walker();
              var event = null;
              while (event = walker.next()) {
                var childNode = event.node;
                if (childNode.type === "text") {
                  buffer.push(childNode.literal);
                }
              }
              return buffer.join("");
            }
            ;
            var widgetRules2 = (
              /* unused pure expression or super */
              null
            );
            var widgetRuleMap2 = {};
            var reWidgetPrefix2 = /\$\$widget\d+\s/;
            function unwrapWidgetSyntax2(text3) {
              var index3 = text3.search(reWidgetPrefix2);
              if (index3 !== -1) {
                var rest = text3.substring(index3);
                var replaced = rest.replace(reWidgetPrefix2, "").replace("$$", "");
                text3 = text3.substring(0, index3);
                text3 += unwrapWidgetSyntax2(replaced);
              }
              return text3;
            }
            function createWidgetContent2(info, text3) {
              return "$$" + info + " " + text3 + "$$";
            }
            function widgetToDOM2(info, text3) {
              var _a = widgetRuleMap2[info], rule = _a.rule, toDOM = _a.toDOM;
              var matches4 = unwrapWidgetSyntax2(text3).match(rule);
              if (matches4) {
                text3 = matches4[0];
              }
              return toDOM(text3);
            }
            function getWidgetRules2() {
              return widgetRules2;
            }
            function setWidgetRules2(rules) {
              widgetRules2 = rules;
              widgetRules2.forEach(function(rule, index3) {
                widgetRuleMap2["widget" + index3] = rule;
              });
            }
            function mergeNodes2(nodes, text3, schema, ruleIndex) {
              return nodes.concat(createNodesWithWidget2(text3, schema, ruleIndex));
            }
            function createNodesWithWidget2(text3, schema, ruleIndex) {
              if (ruleIndex === void 0) {
                ruleIndex = 0;
              }
              var nodes = [];
              var rule = (widgetRules2[ruleIndex] || {}).rule;
              var nextRuleIndex = ruleIndex + 1;
              text3 = unwrapWidgetSyntax2(text3);
              if (rule && rule.test(text3)) {
                var index3 = void 0;
                while ((index3 = text3.search(rule)) !== -1) {
                  var prev = text3.substring(0, index3);
                  if (prev) {
                    nodes = mergeNodes2(nodes, prev, schema, nextRuleIndex);
                  }
                  text3 = text3.substring(index3);
                  var literal = text3.match(rule)[0];
                  var info = "widget" + ruleIndex;
                  nodes.push(schema.nodes.widget.create({ info }, schema.text(createWidgetContent2(info, literal))));
                  text3 = text3.substring(literal.length);
                }
                if (text3) {
                  nodes = mergeNodes2(nodes, text3, schema, nextRuleIndex);
                }
              } else if (text3) {
                nodes = ruleIndex < widgetRules2.length - 1 ? mergeNodes2(nodes, text3, schema, nextRuleIndex) : [schema.text(text3)];
              }
              return nodes;
            }
            function getWidgetContent2(widgetNode) {
              var event;
              var text3 = "";
              var walker = widgetNode.walker();
              while (event = walker.next()) {
                var node4 = event.node, entering = event.entering;
                if (entering) {
                  if (node4 !== widgetNode && node4.type !== "text") {
                    text3 += getInlineMarkdownText2(node4);
                    walker.resumeAt(widgetNode, false);
                    walker.next();
                  } else if (node4.type === "text") {
                    text3 += node4.literal;
                  }
                }
              }
              return text3;
            }
            var purify2 = __webpack_require__(368);
            var purify_default = __webpack_require__.n(purify2);
            ;
            var CAN_BE_WHITE_TAG_LIST2 = ["iframe", "embed"];
            var whiteTagList2 = [];
            function htmlSanitizer_registerTagWhitelistIfPossible(tagName) {
              if (common_includes(CAN_BE_WHITE_TAG_LIST2, tagName)) {
                whiteTagList2.push(tagName.toLowerCase());
              }
            }
            function sanitizeHTML2(html2, options) {
              return purify_default().sanitize(html2, tslib_es6_assign({ ADD_TAGS: whiteTagList2, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
                "input",
                "script",
                "textarea",
                "form",
                "button",
                "select",
                "meta",
                "style",
                "link",
                "title",
                "object",
                "base"
              ] }, options));
            }
            ;
            function getChildrenHTML2(node4, typeName) {
              return node4.literal.replace(new RegExp("(<\\s*" + typeName + "[^>]*>)|(</" + typeName + "\\s*[>])", "ig"), "").trim();
            }
            function getHTMLAttrsByHTMLString2(html2) {
              html2 = html2.match(reHTMLTag2)[0];
              var attrs = html2.match(new RegExp(constants_ATTRIBUTE, "g"));
              return attrs ? attrs.reduce(function(acc, attr) {
                var _a = attr.trim().split("="), name = _a[0], values = _a.slice(1);
                if (values.length) {
                  acc[name] = values.join("=").replace(/'|"/g, "").trim();
                }
                return acc;
              }, {}) : {};
            }
            function getHTMLAttrs2(dom) {
              return toArray_default()(dom.attributes).reduce(function(acc, attr) {
                acc[attr.nodeName] = attr.nodeValue;
                return acc;
              }, {});
            }
            function sanitizeDOM2(node4, typeName, sanitizer, wwToDOMAdaptor) {
              var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node4);
              var html2 = sanitizer(dom.outerHTML);
              var container = document.createElement("div");
              container.innerHTML = html2;
              dom = container.firstChild;
              var htmlAttrs = getHTMLAttrs2(dom);
              return { dom, htmlAttrs };
            }
            var schemaFactory2 = {
              htmlBlock: function(typeName, sanitizeHTML3, wwToDOMAdaptor) {
                return {
                  atom: true,
                  content: "block+",
                  group: "block",
                  attrs: {
                    htmlAttrs: { default: {} },
                    childrenHTML: { default: "" },
                    htmlBlock: { default: true }
                  },
                  parseDOM: [
                    {
                      tag: typeName,
                      getAttrs: function(dom) {
                        return {
                          htmlAttrs: getHTMLAttrs2(dom),
                          childrenHTML: dom.innerHTML
                        };
                      }
                    }
                  ],
                  toDOM: function(node4) {
                    var _a = sanitizeDOM2(node4, typeName, sanitizeHTML3, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;
                    htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + " html-block" : "html-block";
                    return __spreadArray2([typeName, htmlAttrs], toArray_default()(dom.childNodes));
                  }
                };
              },
              htmlInline: function(typeName, sanitizeHTML3, wwToDOMAdaptor) {
                return {
                  attrs: {
                    htmlAttrs: { default: {} },
                    htmlInline: { default: true }
                  },
                  parseDOM: [
                    {
                      tag: typeName,
                      getAttrs: function(dom) {
                        return {
                          htmlAttrs: getHTMLAttrs2(dom)
                        };
                      }
                    }
                  ],
                  toDOM: function(node4) {
                    var htmlAttrs = sanitizeDOM2(node4, typeName, sanitizeHTML3, wwToDOMAdaptor).htmlAttrs;
                    return [typeName, htmlAttrs, 0];
                  }
                };
              }
            };
            function createHTMLSchemaMap2(convertorMap, sanitizeHTML3, wwToDOMAdaptor) {
              var htmlSchemaMap = { nodes: {}, marks: {} };
              ["htmlBlock", "htmlInline"].forEach(function(htmlType) {
                if (convertorMap[htmlType]) {
                  Object.keys(convertorMap[htmlType]).forEach(function(type) {
                    var targetType = htmlType === "htmlBlock" ? "nodes" : "marks";
                    registerTagWhitelistIfPossible(type);
                    htmlSchemaMap[targetType][type] = schemaFactory2[htmlType](type, sanitizeHTML3, wwToDOMAdaptor);
                  });
                }
              });
              return htmlSchemaMap;
            }
            ;
            var reCloseTag2 = /^\s*<\s*\//;
            var htmlRenderConvertors_baseConvertors = {
              paragraph: function(_, _a) {
                var entering = _a.entering, origin = _a.origin, options = _a.options;
                if (options.nodeId) {
                  return {
                    type: entering ? "openTag" : "closeTag",
                    outerNewLine: true,
                    tagName: "p"
                  };
                }
                return origin();
              },
              softbreak: function(node4) {
                var isPrevNodeHTML = node4.prev && node4.prev.type === "htmlInline";
                var isPrevBR = isPrevNodeHTML && /<br ?\/?>/.test(node4.prev.literal);
                var content2 = isPrevBR ? "\n" : "<br>\n";
                return { type: "html", content: content2 };
              },
              item: function(node4, _a) {
                var entering = _a.entering;
                if (entering) {
                  var attributes = {};
                  var classNames = [];
                  if (node4.listData.task) {
                    attributes["data-task"] = "";
                    classNames.push("task-list-item");
                    if (node4.listData.checked) {
                      classNames.push("checked");
                      attributes["data-task-checked"] = "";
                    }
                  }
                  return {
                    type: "openTag",
                    tagName: "li",
                    classNames,
                    attributes,
                    outerNewLine: true
                  };
                }
                return {
                  type: "closeTag",
                  tagName: "li",
                  outerNewLine: true
                };
              },
              code: function(node4) {
                var attributes = { "data-backticks": String(node4.tickCount) };
                return [
                  { type: "openTag", tagName: "code", attributes },
                  { type: "text", content: node4.literal },
                  { type: "closeTag", tagName: "code" }
                ];
              },
              codeBlock: function(node4) {
                var _a = node4, fenceLength = _a.fenceLength, info = _a.info;
                var infoWords = info ? info.split(/\s+/) : [];
                var preClasses = [];
                var codeAttrs = {};
                if (fenceLength > 3) {
                  codeAttrs["data-backticks"] = fenceLength;
                }
                if (infoWords.length > 0 && infoWords[0].length > 0) {
                  var lang3 = infoWords[0];
                  preClasses.push("lang-" + lang3);
                  codeAttrs["data-language"] = lang3;
                }
                return [
                  { type: "openTag", tagName: "pre", classNames: preClasses },
                  { type: "openTag", tagName: "code", attributes: codeAttrs },
                  { type: "text", content: node4.literal },
                  { type: "closeTag", tagName: "code" },
                  { type: "closeTag", tagName: "pre" }
                ];
              },
              customInline: function(node4, _a) {
                var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;
                var info = node4.info;
                if (info.indexOf("widget") !== -1 && entering) {
                  skipChildren();
                  var content2 = getWidgetContent2(node4);
                  var htmlInline = widgetToDOM2(info, content2).outerHTML;
                  return [
                    { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
                    { type: "html", content: htmlInline },
                    { type: "closeTag", tagName: "span" }
                  ];
                }
                return origin();
              }
            };
            function getHTMLRenderConvertors2(linkAttributes, customConvertors) {
              var convertors2 = tslib_es6_assign({}, htmlRenderConvertors_baseConvertors);
              if (linkAttributes) {
                convertors2.link = function(_, _a) {
                  var entering = _a.entering, origin = _a.origin;
                  var result2 = origin();
                  if (entering) {
                    result2.attributes = tslib_es6_assign(tslib_es6_assign({}, result2.attributes), linkAttributes);
                  }
                  return result2;
                };
              }
              if (customConvertors) {
                Object.keys(customConvertors).forEach(function(nodeType2) {
                  var orgConvertor = convertors2[nodeType2];
                  var customConvertor = customConvertors[nodeType2];
                  if (orgConvertor && isFunction_default()(customConvertor)) {
                    convertors2[nodeType2] = function(node4, context) {
                      var newContext = tslib_es6_assign({}, context);
                      newContext.origin = function() {
                        return orgConvertor(node4, context);
                      };
                      return customConvertor(node4, newContext);
                    };
                  } else if (common_includes(["htmlBlock", "htmlInline"], nodeType2) && !isFunction_default()(customConvertor)) {
                    convertors2[nodeType2] = function(node4, context) {
                      var matched = node4.literal.match(reHTMLTag2);
                      if (matched) {
                        var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];
                        var typeName = (openTagName || closeTagName).toLowerCase();
                        var htmlConvertor = customConvertor[typeName];
                        var childrenHTML = getChildrenHTML2(node4, typeName);
                        if (htmlConvertor) {
                          var newNode = tslib_es6_assign({}, node4);
                          newNode.attrs = getHTMLAttrsByHTMLString2(rootHTML);
                          newNode.childrenHTML = childrenHTML;
                          newNode.type = typeName;
                          context.entering = !reCloseTag2.test(node4.literal);
                          return htmlConvertor(newNode, context);
                        }
                      }
                      return context.origin();
                    };
                  } else {
                    convertors2[nodeType2] = customConvertor;
                  }
                });
              }
              return convertors2;
            }
            ;
            var nestableTypes2 = (
              /* unused pure expression or super */
              null
            );
            var nestableTagNames2 = ["UL", "OL", "BLOCKQUOTE"];
            function isBlankLine2(doc2, index3) {
              var _a;
              var pmNode = doc2.child(index3);
              return !pmNode.childCount || pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim());
            }
            function getEditorRangeHeightInfo2(doc2, mdNode, children) {
              var start3 = getMdStartLine(mdNode) - 1;
              var end2 = getMdEndLine(mdNode) - 1;
              var rect3 = children[start3].getBoundingClientRect();
              var height = children[end2].offsetTop - children[start3].offsetTop + children[end2].clientHeight;
              return {
                height: height <= 0 ? children[start3].clientHeight : height + getBlankLinesHeight2(doc2, children, Math.min(end2 + 1, doc2.childCount - 1)),
                rect: rect3
              };
            }
            function getBlankLinesHeight2(doc2, children, start3) {
              var end2 = doc2.childCount - 1;
              var height = 0;
              while (start3 <= end2 && isBlankLine2(doc2, start3)) {
                height += children[start3].clientHeight;
                start3 += 1;
              }
              return height;
            }
            function findAncestorHavingId2(el3, root) {
              while (!el3.getAttribute("data-nodeid") && el3.parentElement !== root) {
                el3 = el3.parentElement;
              }
              return el3;
            }
            function dom_getTotalOffsetTop(el3, root) {
              var offsetTop = 0;
              while (el3 && el3 !== root) {
                if (!common_includes(nestableTagNames2, el3.tagName)) {
                  offsetTop += el3.offsetTop;
                }
                if (el3.offsetParent === root.offsetParent) {
                  break;
                }
                el3 = el3.parentElement;
              }
              return offsetTop;
            }
            function findAdjacentElementToScrollTop2(scrollTop, root) {
              var el3 = root;
              var prev = null;
              while (el3) {
                var firstElementChild = el3.firstElementChild;
                if (!firstElementChild) {
                  break;
                }
                var lastSibling = findLastSiblingElementToScrollTop2(firstElementChild, scrollTop, dom_getTotalOffsetTop(el3, root));
                prev = el3;
                el3 = lastSibling;
              }
              var adjacentEl = el3 || prev;
              return adjacentEl === root ? null : adjacentEl;
            }
            function findLastSiblingElementToScrollTop2(el3, scrollTop, offsetTop) {
              if (el3 && scrollTop > offsetTop + el3.offsetTop) {
                return findLastSiblingElementToScrollTop2(el3.nextElementSibling, scrollTop, offsetTop) || el3;
              }
              return null;
            }
            function getAdditionalPos2(scrollTop, offsetTop, height, targetNodeHeight) {
              var ratio3 = Math.min((scrollTop - offsetTop) / height, 1);
              return ratio3 * targetNodeHeight;
            }
            function getParentNodeObj2(previewContent, mdNode) {
              var el3 = previewContent.querySelector('[data-nodeid="' + mdNode.id + '"]');
              while (!el3 || isStyledInlineNode(mdNode)) {
                mdNode = mdNode.parent;
                el3 = previewContent.querySelector('[data-nodeid="' + mdNode.id + '"]');
              }
              return getNonNestableNodeObj2({ mdNode, el: el3 });
            }
            function getNonNestableNodeObj2(_a) {
              var mdNode = _a.mdNode, el3 = _a.el;
              while ((includes(nestableTypes2, mdNode.type) || mdNode.type === "table") && mdNode.firstChild) {
                mdNode = mdNode.firstChild;
                el3 = el3.firstElementChild;
              }
              return { mdNode, el: el3 };
            }
            ;
            var offsetInfoMap2 = {};
            function setHeight2(id, height) {
              offsetInfoMap2[id] = offsetInfoMap2[id] || {};
              offsetInfoMap2[id].height = height;
            }
            function setOffsetTop2(id, offsetTop) {
              offsetInfoMap2[id] = offsetInfoMap2[id] || {};
              offsetInfoMap2[id].offsetTop = offsetTop;
            }
            function getHeight2(id) {
              return offsetInfoMap2[id] && offsetInfoMap2[id].height;
            }
            function getOffsetTop2(id) {
              return offsetInfoMap2[id] && offsetInfoMap2[id].offsetTop;
            }
            function removeOffsetInfoByNode2(node4) {
              if (node4) {
                delete offsetInfoMap2[Number(node4.getAttribute("data-nodeid"))];
                toArray_default()(node4.children).forEach(function(child3) {
                  removeOffsetInfoByNode2(child3);
                });
              }
            }
            function getAndSaveOffsetInfo2(node4, root, mdNodeId) {
              var cachedHeight = getHeight2(mdNodeId);
              var cachedTop = getOffsetTop2(mdNodeId);
              var nodeHeight = cachedHeight || node4.clientHeight;
              var offsetTop = cachedTop || getTotalOffsetTop(node4, root) || node4.offsetTop;
              if (!cachedHeight) {
                setHeight2(mdNodeId, nodeHeight);
              }
              if (!cachedTop) {
                setOffsetTop2(mdNodeId, offsetTop);
              }
              return { nodeHeight, offsetTop };
            }
            ;
            var CLASS_HIGHLIGHT2 = cls2("md-preview-highlight");
            function findTableCell2(tableRow3, chOffset) {
              var cell = tableRow3.firstChild;
              while (cell && cell.next) {
                if (getMdStartCh2(cell.next) > chOffset + 1) {
                  break;
                }
                cell = cell.next;
              }
              return cell;
            }
            var MarkdownPreview2 = (
              /** @class */
              (function() {
                function MarkdownPreview3(eventEmitter2, options) {
                  var el3 = document.createElement("div");
                  this.el = el3;
                  this.eventEmitter = eventEmitter2;
                  this.isViewer = !!options.isViewer;
                  this.el.className = cls2("md-preview");
                  var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;
                  this.renderer = new Renderer2({
                    gfm: true,
                    nodeId: true,
                    convertors: getHTMLRenderConvertors2(linkAttributes, customHTMLRenderer)
                  });
                  this.cursorNodeId = null;
                  this.sanitizer = sanitizer;
                  this.initEvent(highlight);
                  this.initContentSection();
                  if (this.isViewer) {
                    this.previewContent.style.overflowWrap = "break-word";
                  }
                }
                MarkdownPreview3.prototype.initContentSection = function() {
                  this.previewContent = createElementWith2('<div class="' + cls2("contents") + '"></div>');
                  if (!this.isViewer) {
                    this.el.appendChild(this.previewContent);
                  }
                };
                MarkdownPreview3.prototype.toggleActive = function(active) {
                  toggleClass2(this.el, "active", active);
                };
                MarkdownPreview3.prototype.initEvent = function(highlight) {
                  var _this = this;
                  this.eventEmitter.listen("updatePreview", this.update.bind(this));
                  if (this.isViewer) {
                    return;
                  }
                  if (highlight) {
                    this.eventEmitter.listen("changeToolbarState", function(_a) {
                      var mdNode = _a.mdNode, cursorPos = _a.cursorPos;
                      _this.updateCursorNode(mdNode, cursorPos);
                    });
                    this.eventEmitter.listen("blur", function() {
                      _this.removeHighlight();
                    });
                  }
                  on_default()(this.el, "scroll", function(event) {
                    _this.eventEmitter.emit("scroll", "preview", findAdjacentElementToScrollTop2(event.target.scrollTop, _this.previewContent));
                  });
                  this.eventEmitter.listen("changePreviewTabPreview", function() {
                    return _this.toggleActive(true);
                  });
                  this.eventEmitter.listen("changePreviewTabWrite", function() {
                    return _this.toggleActive(false);
                  });
                };
                MarkdownPreview3.prototype.removeHighlight = function() {
                  if (this.cursorNodeId) {
                    var currentEl = this.getElementByNodeId(this.cursorNodeId);
                    if (currentEl) {
                      removeClass_default()(currentEl, CLASS_HIGHLIGHT2);
                    }
                  }
                };
                MarkdownPreview3.prototype.updateCursorNode = function(cursorNode, cursorPos) {
                  if (cursorNode) {
                    cursorNode = findClosestNode2(cursorNode, function(mdNode) {
                      return !isInlineNode2(mdNode);
                    });
                    if (cursorNode.type === "tableRow") {
                      cursorNode = findTableCell2(cursorNode, cursorPos[1]);
                    } else if (cursorNode.type === "tableBody") {
                      cursorNode = null;
                    }
                  }
                  var cursorNodeId = cursorNode ? cursorNode.id : null;
                  if (this.cursorNodeId === cursorNodeId) {
                    return;
                  }
                  var oldEL = this.getElementByNodeId(this.cursorNodeId);
                  var newEL = this.getElementByNodeId(cursorNodeId);
                  if (oldEL) {
                    removeClass_default()(oldEL, CLASS_HIGHLIGHT2);
                  }
                  if (newEL) {
                    addClass_default()(newEL, CLASS_HIGHLIGHT2);
                  }
                  this.cursorNodeId = cursorNodeId;
                };
                MarkdownPreview3.prototype.getElementByNodeId = function(nodeId) {
                  return nodeId ? this.previewContent.querySelector('[data-nodeid="' + nodeId + '"]') : null;
                };
                MarkdownPreview3.prototype.update = function(changed) {
                  var _this = this;
                  changed.forEach(function(editResult) {
                    return _this.replaceRangeNodes(editResult);
                  });
                  this.eventEmitter.emit("afterPreviewRender", this);
                };
                MarkdownPreview3.prototype.replaceRangeNodes = function(editResult) {
                  var _this = this;
                  var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;
                  var contentEl = this.previewContent;
                  var newHtml = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(nodes.map(function(node4) {
                    return _this.renderer.render(node4);
                  }).join("")));
                  if (!removedNodeRange) {
                    contentEl.insertAdjacentHTML("afterbegin", newHtml);
                  } else {
                    var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];
                    var startEl = this.getElementByNodeId(startNodeId);
                    var endEl = this.getElementByNodeId(endNodeId);
                    if (startEl) {
                      startEl.insertAdjacentHTML("beforebegin", newHtml);
                      var el3 = startEl;
                      while (el3 && el3 !== endEl) {
                        var nextEl = el3.nextElementSibling;
                        removeNode2(el3);
                        removeOffsetInfoByNode2(el3);
                        el3 = nextEl;
                      }
                      if (el3 === null || el3 === void 0 ? void 0 : el3.parentNode) {
                        removeNode2(el3);
                        removeOffsetInfoByNode2(el3);
                      }
                    }
                  }
                };
                MarkdownPreview3.prototype.getRenderer = function() {
                  return this.renderer;
                };
                MarkdownPreview3.prototype.destroy = function() {
                  off_default()(this.el, "scroll");
                  this.el = null;
                };
                MarkdownPreview3.prototype.getElement = function() {
                  return this.el;
                };
                MarkdownPreview3.prototype.getHTML = function() {
                  return this.previewContent.innerHTML;
                };
                MarkdownPreview3.prototype.setHTML = function(html2) {
                  this.previewContent.innerHTML = html2;
                };
                MarkdownPreview3.prototype.setHeight = function(height) {
                  css_default()(this.el, { height: height + "px" });
                };
                MarkdownPreview3.prototype.setMinHeight = function(minHeight) {
                  css_default()(this.el, { minHeight: minHeight + "px" });
                };
                return MarkdownPreview3;
              })()
            );
            var mdPreview = MarkdownPreview2;
            var external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_ = __webpack_require__(814);
            var external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_ = __webpack_require__(479);
            var external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_ = __webpack_require__(311);
            var external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_ = __webpack_require__(43);
            var inArray2 = __webpack_require__(928);
            var inArray_default = __webpack_require__.n(inArray2);
            ;
            var map_Map = (
              /** @class */
              (function() {
                function Map2() {
                  this.keys = [];
                  this.values = [];
                }
                Map2.prototype.getKeyIndex = function(key) {
                  return inArray_default()(key, this.keys);
                };
                Map2.prototype.get = function(key) {
                  return this.values[this.getKeyIndex(key)];
                };
                Map2.prototype.set = function(key, value) {
                  var keyIndex = this.getKeyIndex(key);
                  if (keyIndex > -1) {
                    this.values[keyIndex] = value;
                  } else {
                    this.keys.push(key);
                    this.values.push(value);
                  }
                  return this;
                };
                Map2.prototype.has = function(key) {
                  return this.getKeyIndex(key) > -1;
                };
                Map2.prototype.delete = function(key) {
                  var keyIndex = this.getKeyIndex(key);
                  if (keyIndex > -1) {
                    this.keys.splice(keyIndex, 1);
                    this.values.splice(keyIndex, 1);
                    return true;
                  }
                  return false;
                };
                Map2.prototype.forEach = function(callback, thisArg) {
                  var _this = this;
                  if (thisArg === void 0) {
                    thisArg = this;
                  }
                  this.values.forEach(function(value, index3) {
                    if (value && _this.keys[index3]) {
                      callback.call(thisArg, value, _this.keys[index3], _this);
                    }
                  });
                };
                Map2.prototype.clear = function() {
                  this.keys = [];
                  this.values = [];
                };
                return Map2;
              })()
            );
            var utils_map = map_Map;
            ;
            var DEFAULT_CODE2 = "en-US";
            var I18n2 = (
              /** @class */
              (function() {
                function I18n3() {
                  this.code = DEFAULT_CODE2;
                  this.langs = new utils_map();
                }
                I18n3.prototype.setCode = function(code2) {
                  this.code = code2 || DEFAULT_CODE2;
                };
                I18n3.prototype.setLanguage = function(codes, data) {
                  var _this = this;
                  codes = [].concat(codes);
                  codes.forEach(function(code2) {
                    if (!_this.langs.has(code2)) {
                      _this.langs.set(code2, data);
                    } else {
                      var langData = _this.langs.get(code2);
                      _this.langs.set(code2, extend_default()(langData, data));
                    }
                  });
                };
                I18n3.prototype.get = function(key, code2) {
                  if (!code2) {
                    code2 = this.code;
                  }
                  var langSet = this.langs.get(code2);
                  if (!langSet) {
                    langSet = this.langs.get(DEFAULT_CODE2);
                  }
                  var text3 = langSet[key];
                  if (!text3) {
                    throw new Error('There is no text key "' + key + '" in ' + code2);
                  }
                  return text3;
                };
                return I18n3;
              })()
            );
            var i18n2 = new I18n2();
            ;
            function findNodeBy2(pos, condition) {
              var depth = pos.depth;
              while (depth) {
                var node4 = pos.node(depth);
                if (condition(node4, depth)) {
                  return {
                    node: node4,
                    depth,
                    offset: depth > 0 ? pos.before(depth) : 0
                  };
                }
                depth -= 1;
              }
              return null;
            }
            function node_isListNode(_a) {
              var type = _a.type;
              return type.name === "bulletList" || type.name === "orderedList";
            }
            function isInListNode2(pos) {
              return !!findNodeBy2(pos, function(_a) {
                var type = _a.type;
                return type.name === "listItem" || type.name === "bulletList" || type.name === "orderedList";
              });
            }
            function isInTableNode2(pos) {
              return !!findNodeBy2(pos, function(_a) {
                var type = _a.type;
                return type.name === "tableHeadCell" || type.name === "tableBodyCell";
              });
            }
            function findListItem2(pos) {
              return findNodeBy2(pos, function(_a) {
                var type = _a.type;
                return type.name === "listItem";
              });
            }
            function createDOMInfoParsedRawHTML2(tag) {
              return {
                tag,
                getAttrs: function(dom) {
                  var rawHTML = dom.getAttribute("data-raw-html");
                  return __assign({}, rawHTML && { rawHTML });
                }
              };
            }
            function createCellAttrs2(attrs) {
              return Object.keys(attrs).reduce(function(acc, attrName) {
                if (attrName !== "rawHTML" && attrs[attrName]) {
                  attrName = attrName === "className" ? "class" : attrName;
                  acc[attrName] = attrs[attrName];
                }
                return acc;
              }, {});
            }
            function createParsedCellDOM2(tag) {
              return {
                tag,
                getAttrs: function(dom) {
                  return ["rawHTML", "colspan", "rowspan", "extended"].reduce(function(acc, attrName) {
                    var attrNameInDOM = attrName === "rawHTML" ? "data-raw-html" : attrName;
                    var attrValue = dom.getAttribute(attrNameInDOM);
                    if (attrValue) {
                      acc[attrName] = includes(["rawHTML", "extended"], attrName) ? attrValue : Number(attrValue);
                    }
                    return acc;
                  }, {});
                }
              };
            }
            function getDefaultCustomAttrs2() {
              return {
                htmlAttrs: { default: null },
                classNames: { default: null }
              };
            }
            function getCustomAttrs2(attrs) {
              var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;
              return __assign(__assign({}, htmlAttrs), { class: classNames ? classNames.join(" ") : null });
            }
            ;
            var cache2 = /* @__PURE__ */ new Map();
            var TableOffsetMap2 = (
              /** @class */
              (function() {
                function TableOffsetMap3(table3, tableRows, tableStartPos, rowInfo) {
                  this.table = table3;
                  this.tableRows = tableRows;
                  this.tableStartPos = tableStartPos;
                  this.rowInfo = rowInfo;
                }
                TableOffsetMap3.create = function(cellPos) {
                  var table3 = findNodeBy2(cellPos, function(_a) {
                    var type = _a.type;
                    return type.name === "table";
                  });
                  if (table3) {
                    var node4 = table3.node, depth = table3.depth, offset2 = table3.offset;
                    var cached = cache2.get(node4);
                    if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset2 + 1) {
                      return cached;
                    }
                    var rows_1 = [];
                    var tablePos = cellPos.start(depth);
                    var thead = node4.child(0);
                    var tbody = node4.child(1);
                    var theadCellInfo = createOffsetMap2(thead, tablePos);
                    var tbodyCellInfo = createOffsetMap2(tbody, tablePos + thead.nodeSize);
                    thead.forEach(function(row) {
                      return rows_1.push(row);
                    });
                    tbody.forEach(function(row) {
                      return rows_1.push(row);
                    });
                    var map15 = new TableOffsetMap3(node4, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));
                    cache2.set(node4, map15);
                    return map15;
                  }
                  return null;
                };
                Object.defineProperty(TableOffsetMap3.prototype, "totalRowCount", {
                  get: function() {
                    return this.rowInfo.length;
                  },
                  enumerable: false,
                  configurable: true
                });
                Object.defineProperty(TableOffsetMap3.prototype, "totalColumnCount", {
                  get: function() {
                    return this.rowInfo[0].length;
                  },
                  enumerable: false,
                  configurable: true
                });
                Object.defineProperty(TableOffsetMap3.prototype, "tableStartOffset", {
                  get: function() {
                    return this.tableStartPos;
                  },
                  enumerable: false,
                  configurable: true
                });
                Object.defineProperty(TableOffsetMap3.prototype, "tableEndOffset", {
                  get: function() {
                    return this.tableStartPos + this.table.nodeSize - 1;
                  },
                  enumerable: false,
                  configurable: true
                });
                TableOffsetMap3.prototype.getCellInfo = function(rowIdx, colIdx) {
                  return this.rowInfo[rowIdx][colIdx];
                };
                TableOffsetMap3.prototype.posAt = function(rowIdx, colIdx) {
                  for (var i = 0, rowStart = this.tableStartPos; ; i += 1) {
                    var rowEnd = rowStart + this.tableRows[i].nodeSize;
                    if (i === rowIdx) {
                      var index3 = colIdx;
                      while (index3 < this.totalColumnCount && this.rowInfo[i][index3].offset < rowStart) {
                        index3 += 1;
                      }
                      return index3 === this.totalColumnCount ? rowEnd : this.rowInfo[i][index3].offset;
                    }
                    rowStart = rowEnd;
                  }
                };
                TableOffsetMap3.prototype.getNodeAndPos = function(rowIdx, colIdx) {
                  var cellInfo = this.rowInfo[rowIdx][colIdx];
                  return {
                    node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),
                    pos: cellInfo.offset
                  };
                };
                TableOffsetMap3.prototype.extendedRowspan = function(rowIdx, colIdx) {
                  return false;
                };
                TableOffsetMap3.prototype.extendedColspan = function(rowIdx, colIdx) {
                  return false;
                };
                TableOffsetMap3.prototype.getRowspanCount = function(rowIdx, colIdx) {
                  return 0;
                };
                TableOffsetMap3.prototype.getColspanCount = function(rowIdx, colIdx) {
                  return 0;
                };
                TableOffsetMap3.prototype.decreaseColspanCount = function(rowIdx, colIdx) {
                  return 0;
                };
                TableOffsetMap3.prototype.decreaseRowspanCount = function(rowIdx, colIdx) {
                  return 0;
                };
                TableOffsetMap3.prototype.getColspanStartInfo = function(rowIdx, colIdx) {
                  return null;
                };
                TableOffsetMap3.prototype.getRowspanStartInfo = function(rowIdx, colIdx) {
                  return null;
                };
                TableOffsetMap3.prototype.getCellStartOffset = function(rowIdx, colIdx) {
                  var offset2 = this.rowInfo[rowIdx][colIdx].offset;
                  return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset2;
                };
                TableOffsetMap3.prototype.getCellEndOffset = function(rowIdx, colIdx) {
                  var _a = this.rowInfo[rowIdx][colIdx], offset2 = _a.offset, nodeSize2 = _a.nodeSize;
                  return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset2 + nodeSize2;
                };
                TableOffsetMap3.prototype.getCellIndex = function(cellPos) {
                  for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {
                    var rowInfo = this.rowInfo[rowIdx];
                    for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {
                      if (rowInfo[colIdx].offset + 1 > cellPos.pos) {
                        return [rowIdx, colIdx];
                      }
                    }
                  }
                  return [0, 0];
                };
                TableOffsetMap3.prototype.getRectOffsets = function(startCellPos, endCellPos) {
                  var _a, _b, _c;
                  if (endCellPos === void 0) {
                    endCellPos = startCellPos;
                  }
                  if (startCellPos.pos > endCellPos.pos) {
                    _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];
                  }
                  var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];
                  var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];
                  _b = getSortedNumPair2(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];
                  _c = getSortedNumPair2(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];
                  return this.getSpannedOffsets({ startRowIdx, startColIdx, endRowIdx, endColIdx });
                };
                TableOffsetMap3.prototype.getSpannedOffsets = function(selectionInfo) {
                  return selectionInfo;
                };
                return TableOffsetMap3;
              })()
            );
            var createOffsetMap2 = function(headOrBody, startOffset) {
              var cellInfoMatrix = [];
              headOrBody.forEach(function(row, rowOffset) {
                var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };
                row.forEach(function(_a, cellOffset) {
                  var nodeSize2 = _a.nodeSize;
                  var colIdx = 0;
                  while (rowInfo[colIdx]) {
                    colIdx += 1;
                  }
                  rowInfo[colIdx] = {
                    // 2 is the sum of the front and back positions of the tag
                    offset: startOffset + rowOffset + cellOffset + 2,
                    nodeSize: nodeSize2
                  };
                  rowInfo.length += 1;
                });
                cellInfoMatrix.push(rowInfo);
              });
              return cellInfoMatrix;
            };
            function mixinTableOffsetMapPrototype2(offsetMapMixin, createOffsetMapMixin) {
              common_assign(TableOffsetMap2.prototype, offsetMapMixin);
              createOffsetMap2 = createOffsetMapMixin;
              return TableOffsetMap2;
            }
            ;
            function execPlugin2(plugin, eventEmitter2, usageStatistics) {
              var pmState = { Plugin: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin, PluginKey: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.PluginKey, Selection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection, TextSelection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection };
              var pmView = { Decoration: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.Decoration, DecorationSet: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.DecorationSet };
              var pmModel = { Fragment: external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment };
              var pmRules = { InputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.InputRule, inputRules: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.inputRules, undoInputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.undoInputRule };
              var context = { eventEmitter: eventEmitter2, usageStatistics, pmState, pmView, pmModel, pmRules, i18n: i18n2 };
              if (isArray_default()(plugin)) {
                var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;
                return pluginFn(context, options);
              }
              return plugin(context);
            }
            function getPluginInfo2(plugins, eventEmitter2, usageStatistics) {
              eventEmitter2.listen("mixinTableOffsetMapPrototype", mixinTableOffsetMapPrototype2);
              return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function(acc, plugin) {
                var pluginInfoResult = execPlugin2(plugin, eventEmitter2, usageStatistics);
                if (!pluginInfoResult) {
                  throw new Error("The return value of the executed plugin is empty.");
                }
                var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;
                if (toHTMLRenderers) {
                  acc.toHTMLRenderers = deepMergedCopy2(acc.toHTMLRenderers, toHTMLRenderers);
                }
                if (toMarkdownRenderers) {
                  acc.toMarkdownRenderers = deepMergedCopy2(acc.toMarkdownRenderers, toMarkdownRenderers);
                }
                if (markdownPlugins) {
                  acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);
                }
                if (wysiwygPlugins) {
                  acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);
                }
                if (wysiwygNodeViews) {
                  acc.wwNodeViews = tslib_es6_assign(tslib_es6_assign({}, acc.wwNodeViews), wysiwygNodeViews);
                }
                if (markdownCommands) {
                  acc.mdCommands = tslib_es6_assign(tslib_es6_assign({}, acc.mdCommands), markdownCommands);
                }
                if (wysiwygCommands) {
                  acc.wwCommands = tslib_es6_assign(tslib_es6_assign({}, acc.wwCommands), wysiwygCommands);
                }
                if (toolbarItems) {
                  acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);
                }
                if (markdownParsers) {
                  acc.markdownParsers = tslib_es6_assign(tslib_es6_assign({}, acc.markdownParsers), markdownParsers);
                }
                return acc;
              }, {
                toHTMLRenderers: {},
                toMarkdownRenderers: {},
                mdPlugins: [],
                wwPlugins: [],
                wwNodeViews: {},
                mdCommands: {},
                wwCommands: {},
                toolbarItems: [],
                markdownParsers: {}
              });
            }
            var isFalsy2 = __webpack_require__(404);
            var isFalsy_default = __webpack_require__.n(isFalsy2);
            ;
            var eventTypeList2 = [
              "afterPreviewRender",
              "updatePreview",
              "changeMode",
              "needChangeMode",
              "command",
              "changePreviewStyle",
              "changePreviewTabPreview",
              "changePreviewTabWrite",
              "scroll",
              "contextmenu",
              "show",
              "hide",
              "changeLanguage",
              "changeToolbarState",
              "toggleScrollSync",
              "mixinTableOffsetMapPrototype",
              "setFocusedNode",
              "removePopupWidget",
              "query",
              // provide event for user
              "openPopup",
              "closePopup",
              "addImageBlobHook",
              "beforePreviewRender",
              "beforeConvertWysiwygToMarkdown",
              "load",
              "loadUI",
              "change",
              "caretChange",
              "destroy",
              "focus",
              "blur",
              "keydown",
              "keyup"
            ];
            var EventEmitter2 = (
              /** @class */
              (function() {
                function EventEmitter3() {
                  var _this = this;
                  this.events = new utils_map();
                  this.eventTypes = eventTypeList2.reduce(function(types, type) {
                    return tslib_es6_assign(tslib_es6_assign({}, types), { type });
                  }, {});
                  this.hold = false;
                  eventTypeList2.forEach(function(eventType) {
                    _this.addEventType(eventType);
                  });
                }
                EventEmitter3.prototype.listen = function(type, handler) {
                  var typeInfo = this.getTypeInfo(type);
                  var eventHandlers = this.events.get(typeInfo.type) || [];
                  if (!this.hasEventType(typeInfo.type)) {
                    throw new Error("There is no event type " + typeInfo.type);
                  }
                  if (typeInfo.namespace) {
                    handler.namespace = typeInfo.namespace;
                  }
                  eventHandlers.push(handler);
                  this.events.set(typeInfo.type, eventHandlers);
                };
                EventEmitter3.prototype.emit = function(type) {
                  var args = [];
                  for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                  }
                  var typeInfo = this.getTypeInfo(type);
                  var eventHandlers = this.events.get(typeInfo.type);
                  var results = [];
                  if (!this.hold && eventHandlers) {
                    eventHandlers.forEach(function(handler) {
                      var result2 = handler.apply(void 0, args);
                      if (!isUndefined_default()(result2)) {
                        results.push(result2);
                      }
                    });
                  }
                  return results;
                };
                EventEmitter3.prototype.emitReduce = function(type, source) {
                  var args = [];
                  for (var _i = 2; _i < arguments.length; _i++) {
                    args[_i - 2] = arguments[_i];
                  }
                  var eventHandlers = this.events.get(type);
                  if (!this.hold && eventHandlers) {
                    eventHandlers.forEach(function(handler) {
                      var result2 = handler.apply(void 0, __spreadArray2([source], args));
                      if (!isFalsy_default()(result2)) {
                        source = result2;
                      }
                    });
                  }
                  return source;
                };
                EventEmitter3.prototype.getTypeInfo = function(type) {
                  var splited = type.split(".");
                  return {
                    type: splited[0],
                    namespace: splited[1]
                  };
                };
                EventEmitter3.prototype.hasEventType = function(type) {
                  return !isUndefined_default()(this.eventTypes[this.getTypeInfo(type).type]);
                };
                EventEmitter3.prototype.addEventType = function(type) {
                  if (this.hasEventType(type)) {
                    throw new Error("There is already have event type " + type);
                  }
                  this.eventTypes[type] = type;
                };
                EventEmitter3.prototype.removeEventHandler = function(eventType, handler) {
                  var _this = this;
                  var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;
                  if (type && handler) {
                    this.removeEventHandlerWithHandler(type, handler);
                  } else if (type && !namespace) {
                    this.events.delete(type);
                  } else if (!type && namespace) {
                    this.events.forEach(function(_, evtType) {
                      _this.removeEventHandlerWithTypeInfo(evtType, namespace);
                    });
                  } else if (type && namespace) {
                    this.removeEventHandlerWithTypeInfo(type, namespace);
                  }
                };
                EventEmitter3.prototype.removeEventHandlerWithHandler = function(type, handler) {
                  var eventHandlers = this.events.get(type);
                  if (eventHandlers) {
                    var handlerIndex = eventHandlers.indexOf(handler);
                    if (eventHandlers.indexOf(handler) >= 0) {
                      eventHandlers.splice(handlerIndex, 1);
                    }
                  }
                };
                EventEmitter3.prototype.removeEventHandlerWithTypeInfo = function(type, namespace) {
                  var handlersToSurvive = [];
                  var eventHandlers = this.events.get(type);
                  if (!eventHandlers) {
                    return;
                  }
                  eventHandlers.map(function(handler) {
                    if (handler.namespace !== namespace) {
                      handlersToSurvive.push(handler);
                    }
                    return null;
                  });
                  this.events.set(type, handlersToSurvive);
                };
                EventEmitter3.prototype.getEvents = function() {
                  return this.events;
                };
                EventEmitter3.prototype.holdEventInvoke = function(fn) {
                  this.hold = true;
                  fn();
                  this.hold = false;
                };
                return EventEmitter3;
              })()
            );
            var eventEmitter = EventEmitter2;
            ;
            var TASK_ATTR_NAME2 = "data-task";
            var DISABLED_TASK_ATTR_NAME2 = "data-task-disabled";
            var TASK_CHECKED_CLASS_NAME2 = "checked";
            function registerHTMLTagToWhitelist2(convertorMap) {
              ["htmlBlock", "htmlInline"].forEach(function(htmlType) {
                if (convertorMap[htmlType]) {
                  Object.keys(convertorMap[htmlType]).forEach(function(type) {
                    return htmlSanitizer_registerTagWhitelistIfPossible(type);
                  });
                }
              });
            }
            var ToastUIEditorViewer2 = (
              /** @class */
              (function() {
                function ToastUIEditorViewer3(options) {
                  var _this = this;
                  this.options = extend_default()({
                    linkAttributes: null,
                    extendedAutolinks: false,
                    customHTMLRenderer: null,
                    referenceDefinition: false,
                    customHTMLSanitizer: null,
                    frontMatter: false,
                    usageStatistics: true,
                    theme: "light"
                  }, options);
                  this.eventEmitter = new eventEmitter();
                  var linkAttributes = sanitizeLinkAttribute2(this.options.linkAttributes);
                  var _a = getPluginInfo2(this.options.plugins, this.eventEmitter, this.options.usageStatistics) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;
                  var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter3 = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;
                  var rendererOptions = {
                    linkAttributes,
                    customHTMLRenderer: tslib_es6_assign(tslib_es6_assign({}, toHTMLRenderers), customHTMLRenderer),
                    extendedAutolinks,
                    referenceDefinition,
                    frontMatter: frontMatter3,
                    sanitizer: customHTMLSanitizer || sanitizeHTML2
                  };
                  registerHTMLTagToWhitelist2(rendererOptions.customHTMLRenderer);
                  if (this.options.events) {
                    forEachOwnProperties_default()(this.options.events, function(fn, key) {
                      _this.on(key, fn);
                    });
                  }
                  var _c = this.options, el3 = _c.el, initialValue = _c.initialValue, theme = _c.theme;
                  var existingHTML = el3.innerHTML;
                  if (theme !== "light") {
                    el3.classList.add(cls2(theme));
                  }
                  el3.innerHTML = "";
                  this.toastMark = new ToastMark2("", {
                    disallowedHtmlBlockTags: ["br", "img"],
                    extendedAutolinks,
                    referenceDefinition,
                    disallowDeepHeading: true,
                    frontMatter: frontMatter3,
                    customParser: markdownParsers
                  });
                  this.preview = new mdPreview(this.eventEmitter, tslib_es6_assign(tslib_es6_assign({}, rendererOptions), { isViewer: true }));
                  on_default()(this.preview.previewContent, "mousedown", this.toggleTask.bind(this));
                  if (initialValue) {
                    this.setMarkdown(initialValue);
                  } else if (existingHTML) {
                    this.preview.setHTML(existingHTML);
                  }
                  el3.appendChild(this.preview.previewContent);
                  this.eventEmitter.emit("load", this);
                }
                ToastUIEditorViewer3.prototype.toggleTask = function(ev) {
                  var element = ev.target;
                  var style = getComputedStyle(element, ":before");
                  if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME2) && element.hasAttribute(TASK_ATTR_NAME2) && isPositionInBox2(style, ev.offsetX, ev.offsetY)) {
                    toggleClass2(element, TASK_CHECKED_CLASS_NAME2);
                    this.eventEmitter.emit("change", {
                      source: "viewer",
                      date: ev
                    });
                  }
                };
                ToastUIEditorViewer3.prototype.setMarkdown = function(markdown) {
                  var lineTexts = this.toastMark.getLineTexts();
                  var length = lineTexts.length;
                  var lastLine = common_last(lineTexts);
                  var endSourcepos = [length, lastLine.length + 1];
                  var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || "");
                  this.eventEmitter.emit("updatePreview", editResult);
                };
                ToastUIEditorViewer3.prototype.on = function(type, handler) {
                  this.eventEmitter.listen(type, handler);
                };
                ToastUIEditorViewer3.prototype.off = function(type) {
                  this.eventEmitter.removeEventHandler(type);
                };
                ToastUIEditorViewer3.prototype.addHook = function(type, handler) {
                  this.eventEmitter.removeEventHandler(type);
                  this.eventEmitter.listen(type, handler);
                };
                ToastUIEditorViewer3.prototype.destroy = function() {
                  off_default()(this.preview.el, "mousedown", this.toggleTask.bind(this));
                  this.preview.destroy();
                  this.eventEmitter.emit("destroy");
                };
                ToastUIEditorViewer3.prototype.isViewer = function() {
                  return true;
                };
                ToastUIEditorViewer3.prototype.isMarkdownMode = function() {
                  return false;
                };
                ToastUIEditorViewer3.prototype.isWysiwygMode = function() {
                  return false;
                };
                return ToastUIEditorViewer3;
              })()
            );
            var viewer = ToastUIEditorViewer2;
            ;
            var indexViewer = viewer;
          })();
          __webpack_exports__ = __webpack_exports__["default"];
          return __webpack_exports__;
        })()
      );
    });
  }
});

// ../../node_modules/.pnpm/@glideapps+glide-data-grid-cells@6.0.3_@types+react@18.2.45_lodash@4.17.21_marked@14.0._89412ac46c393934239288dc902f8fd2/node_modules/@glideapps/glide-data-grid-cells/dist/esm/cells/article-cell-editor.js
var React2 = __toESM(require_react(), 1);

// ../../node_modules/.pnpm/@toast-ui+react-editor@3.1.10_react@18.2.0/node_modules/@toast-ui/react-editor/dist/esm/index.js
var import_react = __toESM(require_react());

// ../../node_modules/.pnpm/@toast-ui+editor@3.1.10/node_modules/@toast-ui/editor/dist/esm/index.js
init_index_es2();
init_index_es5();
init_index_es3();
init_index_es4();

// ../../node_modules/.pnpm/w3c-keyname@2.2.8/node_modules/w3c-keyname/index.js
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
var i;
for (i = 1; i <= 24; i++) base[i + 111] = "F" + i;
var i;
for (i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
var i;
for (code2 in base) if (!shift.hasOwnProperty(code2)) shift[code2] = base[code2];
var code2;
function keyName(event) {
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}

// ../../node_modules/.pnpm/prosemirror-keymap@1.1.5/node_modules/prosemirror-keymap/dist/index.es.js
init_index_es4();
var mac2 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/), result2 = parts[parts.length - 1];
  if (result2 == "Space") {
    result2 = " ";
  }
  var alt, ctrl, shift2, meta;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift2 = true;
    } else if (/^mod$/i.test(mod)) {
      if (mac2) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error("Unrecognized modifier name: " + mod);
    }
  }
  if (alt) {
    result2 = "Alt-" + result2;
  }
  if (ctrl) {
    result2 = "Ctrl-" + result2;
  }
  if (meta) {
    result2 = "Meta-" + result2;
  }
  if (shift2) {
    result2 = "Shift-" + result2;
  }
  return result2;
}
function normalize(map14) {
  var copy6 = /* @__PURE__ */ Object.create(null);
  for (var prop2 in map14) {
    copy6[normalizeKeyName(prop2)] = map14[prop2];
  }
  return copy6;
}
function modifiers(name, event, shift2) {
  if (event.altKey) {
    name = "Alt-" + name;
  }
  if (event.ctrlKey) {
    name = "Ctrl-" + name;
  }
  if (event.metaKey) {
    name = "Meta-" + name;
  }
  if (shift2 !== false && event.shiftKey) {
    name = "Shift-" + name;
  }
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  var map14 = normalize(bindings);
  return function(view, event) {
    var name = keyName(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map14[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) {
      return true;
    }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = base[event.keyCode]) && baseName != name) {
      var fromCode = map14[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) {
        return true;
      }
    } else if (isChar && event.shiftKey) {
      var withShift = map14[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) {
        return true;
      }
    }
    return false;
  };
}

// ../../node_modules/.pnpm/prosemirror-commands@1.1.12/node_modules/prosemirror-commands/dist/index.es.js
init_index_es3();
init_index_es2();
init_index_es4();
function deleteSelection(state, dispatch2) {
  if (state.selection.empty) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.deleteSelection().scrollIntoView());
  }
  return true;
}
function joinBackward(state, dispatch2, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) {
    return false;
  }
  var $cut = findCutBefore($cursor);
  if (!$cut) {
    var range2 = $cursor.blockRange(), target2 = range2 && liftTarget(range2);
    if (target2 == null) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.lift(range2, target2).scrollIntoView());
    }
    return true;
  }
  var before2 = $cut.nodeBefore;
  if (!before2.type.spec.isolating && deleteBarrier(state, $cut, dispatch2)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(before2, "end") || NodeSelection.isSelectable(before2))) {
    if (dispatch2) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(before2, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before2.nodeSize));
      dispatch2(tr.scrollIntoView());
    }
    return true;
  }
  if (before2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2) {
      dispatch2(state.tr.delete($cut.pos - before2.nodeSize, $cut.pos).scrollIntoView());
    }
    return true;
  }
  return false;
}
function textblockAt(node4, side, only) {
  for (; node4; node4 = side == "start" ? node4.firstChild : node4.lastChild) {
    if (node4.isTextblock) {
      return true;
    }
    if (only && node4.childCount != 1) {
      return false;
    }
  }
  return false;
}
function selectNodeBackward(state, dispatch2, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty3 = ref.empty;
  var $cut = $head;
  if (!empty3) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) {
      return false;
    }
    $cut = findCutBefore($head);
  }
  var node4 = $cut && $cut.nodeBefore;
  if (!node4 || !NodeSelection.isSelectable(node4)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node4.nodeSize)).scrollIntoView());
  }
  return true;
}
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0) {
        return $pos.doc.resolve($pos.before(i + 1));
      }
      if ($pos.node(i).type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function joinForward(state, dispatch2, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) {
    return false;
  }
  var $cut = findCutAfter($cursor);
  if (!$cut) {
    return false;
  }
  var after2 = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch2)) {
    return true;
  }
  if ($cursor.parent.content.size == 0 && (textblockAt(after2, "start") || NodeSelection.isSelectable(after2))) {
    if (dispatch2) {
      var tr = state.tr.deleteRange($cursor.before(), $cursor.after());
      tr.setSelection(textblockAt(after2, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
      dispatch2(tr.scrollIntoView());
    }
    return true;
  }
  if (after2.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch2) {
      dispatch2(state.tr.delete($cut.pos, $cut.pos + after2.nodeSize).scrollIntoView());
    }
    return true;
  }
  return false;
}
function selectNodeForward(state, dispatch2, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty3 = ref.empty;
  var $cut = $head;
  if (!empty3) {
    return false;
  }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) {
      return false;
    }
    $cut = findCutAfter($head);
  }
  var node4 = $cut && $cut.nodeAfter;
  if (!node4 || !NodeSelection.isSelectable(node4)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  }
  return true;
}
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) {
    for (var i = $pos.depth - 1; i >= 0; i--) {
      var parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount) {
        return $pos.doc.resolve($pos.after(i + 1));
      }
      if (parent.type.spec.isolating) {
        break;
      }
    }
  }
  return null;
}
function newlineInCode(state, dispatch2) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.insertText("\n").scrollIntoView());
  }
  return true;
}
function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i++) {
    var ref = match.edge(i);
    var type = ref.type;
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function exitCode(state, dispatch2) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) {
    return false;
  }
  var above = $head.node(-1), after2 = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after2));
  if (!above.canReplaceWith(after2, after2, type)) {
    return false;
  }
  if (dispatch2) {
    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function createParagraphNear(state, dispatch2) {
  var sel = state.selection;
  var $from = sel.$from;
  var $to = sel.$to;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) {
    return false;
  }
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) {
    return false;
  }
  if (dispatch2) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function liftEmptyBlock(state, dispatch2) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || $cursor.parent.content.size) {
    return false;
  }
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before2 = $cursor.before();
    if (canSplit(state.doc, before2)) {
      if (dispatch2) {
        dispatch2(state.tr.split(before2).scrollIntoView());
      }
      return true;
    }
  }
  var range2 = $cursor.blockRange(), target2 = range2 && liftTarget(range2);
  if (target2 == null) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.lift(range2, target2).scrollIntoView());
  }
  return true;
}
function splitBlock(state, dispatch2) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(state.doc, $from.pos)) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.split($from.pos).scrollIntoView());
    }
    return true;
  }
  if (!$from.parent.isBlock) {
    return false;
  }
  if (dispatch2) {
    var atEnd2 = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection) {
      tr.deleteSelection();
    }
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types = atEnd2 && deflt ? [{ type: deflt }] : null;
    var can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{ type: deflt }])) {
      types = [{ type: deflt }];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd2 && !$from.parentOffset && $from.parent.type != deflt) {
        var first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    dispatch2(tr.scrollIntoView());
  }
  return true;
}
function selectAll(state, dispatch2) {
  if (dispatch2) {
    dispatch2(state.tr.setSelection(new AllSelection(state.doc)));
  }
  return true;
}
function joinMaybeClear(state, $pos, dispatch2) {
  var before2 = $pos.nodeBefore, after2 = $pos.nodeAfter, index3 = $pos.index();
  if (!before2 || !after2 || !before2.type.compatibleContent(after2.type)) {
    return false;
  }
  if (!before2.content.size && $pos.parent.canReplace(index3 - 1, index3)) {
    if (dispatch2) {
      dispatch2(state.tr.delete($pos.pos - before2.nodeSize, $pos.pos).scrollIntoView());
    }
    return true;
  }
  if (!$pos.parent.canReplace(index3, index3 + 1) || !(after2.isTextblock || canJoin(state.doc, $pos.pos))) {
    return false;
  }
  if (dispatch2) {
    dispatch2(state.tr.clearIncompatible($pos.pos, before2.type, before2.contentMatchAt(before2.childCount)).join($pos.pos).scrollIntoView());
  }
  return true;
}
function deleteBarrier(state, $cut, dispatch2) {
  var before2 = $cut.nodeBefore, after2 = $cut.nodeAfter, conn, match;
  if (before2.type.spec.isolating || after2.type.spec.isolating) {
    return false;
  }
  if (joinMaybeClear(state, $cut, dispatch2)) {
    return true;
  }
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before2.contentMatchAt(before2.childCount)).findWrapping(after2.type)) && match.matchType(conn[0] || after2.type).validEnd) {
    if (dispatch2) {
      var end2 = $cut.pos + after2.nodeSize, wrap = Fragment.empty;
      for (var i = conn.length - 1; i >= 0; i--) {
        wrap = Fragment.from(conn[i].create(null, wrap));
      }
      wrap = Fragment.from(before2.copy(wrap));
      var tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end2 + 2 * conn.length;
      if (canJoin(tr.doc, joinAt)) {
        tr.join(joinAt);
      }
      dispatch2(tr.scrollIntoView());
    }
    return true;
  }
  var selAfter = Selection.findFrom($cut, 1);
  var range2 = selAfter && selAfter.$from.blockRange(selAfter.$to), target2 = range2 && liftTarget(range2);
  if (target2 != null && target2 >= $cut.depth) {
    if (dispatch2) {
      dispatch2(state.tr.lift(range2, target2).scrollIntoView());
    }
    return true;
  }
  if (canDelAfter && textblockAt(after2, "start", true) && textblockAt(before2, "end")) {
    var at = before2, wrap$1 = [];
    for (; ; ) {
      wrap$1.push(at);
      if (at.isTextblock) {
        break;
      }
      at = at.lastChild;
    }
    var afterText = after2, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild) {
      afterDepth++;
    }
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch2) {
        var end$1 = Fragment.empty;
        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) {
          end$1 = Fragment.from(wrap$1[i$1].copy(end$1));
        }
        var tr$1 = state.tr.step(new ReplaceAroundStep(
          $cut.pos - wrap$1.length,
          $cut.pos + after2.nodeSize,
          $cut.pos + afterDepth,
          $cut.pos + after2.nodeSize - afterDepth,
          new Slice(end$1, wrap$1.length, 0),
          0,
          true
        ));
        dispatch2(tr$1.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function wrapIn(nodeType2, attrs) {
  return function(state, dispatch2) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range2 = $from.blockRange($to), wrapping = range2 && findWrapping3(range2, nodeType2, attrs);
    if (!wrapping) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.wrap(range2, wrapping).scrollIntoView());
    }
    return true;
  };
}
function setBlockType(nodeType2, attrs) {
  return function(state, dispatch2) {
    var ref = state.selection;
    var from4 = ref.from;
    var to = ref.to;
    var applicable = false;
    state.doc.nodesBetween(from4, to, function(node4, pos) {
      if (applicable) {
        return false;
      }
      if (!node4.isTextblock || node4.hasMarkup(nodeType2, attrs)) {
        return;
      }
      if (node4.type == nodeType2) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos), index3 = $pos.index();
        applicable = $pos.parent.canReplaceWith(index3, index3 + 1, nodeType2);
      }
    });
    if (!applicable) {
      return false;
    }
    if (dispatch2) {
      dispatch2(state.tr.setBlockType(from4, to, nodeType2, attrs).scrollIntoView());
    }
    return true;
  };
}
function markApplies(doc2, ranges, type) {
  var loop = function(i2) {
    var ref = ranges[i2];
    var $from = ref.$from;
    var $to = ref.$to;
    var can = $from.depth == 0 ? doc2.type.allowsMarkType(type) : false;
    doc2.nodesBetween($from.pos, $to.pos, function(node4) {
      if (can) {
        return false;
      }
      can = node4.inlineContent && node4.type.allowsMarkType(type);
    });
    if (can) {
      return { v: true };
    }
  };
  for (var i = 0; i < ranges.length; i++) {
    var returned = loop(i);
    if (returned) return returned.v;
  }
  return false;
}
function toggleMark(markType, attrs) {
  return function(state, dispatch2) {
    var ref = state.selection;
    var empty3 = ref.empty;
    var $cursor = ref.$cursor;
    var ranges = ref.ranges;
    if (empty3 && !$cursor || !markApplies(state.doc, ranges, markType)) {
      return false;
    }
    if (dispatch2) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks())) {
          dispatch2(state.tr.removeStoredMark(markType));
        } else {
          dispatch2(state.tr.addStoredMark(markType.create(attrs)));
        }
      } else {
        var has = false, tr = state.tr;
        for (var i = 0; !has && i < ranges.length; i++) {
          var ref$1 = ranges[i];
          var $from = ref$1.$from;
          var $to = ref$1.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }
        for (var i$1 = 0; i$1 < ranges.length; i$1++) {
          var ref$2 = ranges[i$1];
          var $from$1 = ref$2.$from;
          var $to$1 = ref$2.$to;
          if (has) {
            tr.removeMark($from$1.pos, $to$1.pos, markType);
          } else {
            var from4 = $from$1.pos, to = $to$1.pos, start3 = $from$1.nodeAfter, end2 = $to$1.nodeBefore;
            var spaceStart = start3 && start3.isText ? /^\s*/.exec(start3.text)[0].length : 0;
            var spaceEnd = end2 && end2.isText ? /\s*$/.exec(end2.text)[0].length : 0;
            if (from4 + spaceStart < to) {
              from4 += spaceStart;
              to -= spaceEnd;
            }
            tr.addMark(from4, to, markType.create(attrs));
          }
        }
        dispatch2(tr.scrollIntoView());
      }
    }
    return true;
  };
}
function chainCommands() {
  var commands = [], len = arguments.length;
  while (len--) commands[len] = arguments[len];
  return function(state, dispatch2, view) {
    for (var i = 0; i < commands.length; i++) {
      if (commands[i](state, dispatch2, view)) {
        return true;
      }
    }
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"]
};
for (key in pcBaseKeymap) {
  macBaseKeymap[key] = pcBaseKeymap[key];
}
var key;
var mac3 = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" ? os.platform() == "darwin" : false;
var baseKeymap = mac3 ? macBaseKeymap : pcBaseKeymap;

// ../../node_modules/.pnpm/@toast-ui+editor@3.1.10/node_modules/@toast-ui/editor/dist/esm/index.js
init_index_es6();

// ../../node_modules/.pnpm/rope-sequence@1.3.4/node_modules/rope-sequence/dist/index.js
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append2(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice3(from4, to) {
  if (from4 === void 0) from4 = 0;
  if (to === void 0) to = this.length;
  if (from4 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from4), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get2(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach4(f, from4, to) {
  if (from4 === void 0) from4 = 0;
  if (to === void 0) to = this.length;
  if (from4 <= to) {
    this.forEachInner(f, from4, to, 0);
  } else {
    this.forEachInvertedInner(f, from4, to, 0);
  }
};
RopeSequence.prototype.map = function map12(f, from4, to) {
  if (from4 === void 0) from4 = 0;
  if (to === void 0) to = this.length;
  var result2 = [];
  this.forEach(function(elt, i) {
    return result2.push(f(elt, i));
  }, from4, to);
  return result2;
};
RopeSequence.from = function from3(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = (function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors5 = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from4, to) {
    if (from4 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from4, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from4, to, start3) {
    for (var i = from4; i < to; i++) {
      if (f(this.values[i], start3 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from4, to, start3) {
    for (var i = from4 - 1; i >= to; i--) {
      if (f(this.values[i], start3 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors5.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors5.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors5);
  return Leaf2;
})(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = (function(RopeSequence3) {
  function Append2(left, right) {
    RopeSequence3.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from4, to, start3) {
    var leftLen = this.left.length;
    if (from4 < leftLen && this.left.forEachInner(f, from4, Math.min(to, leftLen), start3) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from4 - leftLen, 0), Math.min(this.length, to) - leftLen, start3 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from4, to, start3) {
    var leftLen = this.left.length;
    if (from4 > leftLen && this.right.forEachInvertedInner(f, from4 - leftLen, Math.max(to, leftLen) - leftLen, start3 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from4, leftLen), to, start3) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from4, to) {
    if (from4 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from4, to);
    }
    if (from4 >= leftLen) {
      return this.right.slice(from4 - leftLen, to - leftLen);
    }
    return this.left.slice(from4, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
})(RopeSequence);
var dist_default = RopeSequence;

// ../../node_modules/.pnpm/prosemirror-history@1.1.3/node_modules/prosemirror-history/dist/index.es.js
init_index_es3();
init_index_es4();
var max_empty_items = 500;
var Branch = function Branch2(items, eventCount) {
  this.items = items;
  this.eventCount = eventCount;
};
Branch.prototype.popEvent = function popEvent(state, preserveItems) {
  var this$1 = this;
  if (this.eventCount == 0) {
    return null;
  }
  var end2 = this.items.length;
  for (; ; end2--) {
    var next = this.items.get(end2 - 1);
    if (next.selection) {
      --end2;
      break;
    }
  }
  var remap, mapFrom;
  if (preserveItems) {
    remap = this.remapping(end2, this.items.length);
    mapFrom = remap.maps.length;
  }
  var transform = state.tr;
  var selection, remaining;
  var addAfter = [], addBefore = [];
  this.items.forEach(function(item2, i) {
    if (!item2.step) {
      if (!remap) {
        remap = this$1.remapping(end2, i + 1);
        mapFrom = remap.maps.length;
      }
      mapFrom--;
      addBefore.push(item2);
      return;
    }
    if (remap) {
      addBefore.push(new Item(item2.map));
      var step2 = item2.step.map(remap.slice(mapFrom)), map14;
      if (step2 && transform.maybeStep(step2).doc) {
        map14 = transform.mapping.maps[transform.mapping.maps.length - 1];
        addAfter.push(new Item(map14, null, null, addAfter.length + addBefore.length));
      }
      mapFrom--;
      if (map14) {
        remap.appendMap(map14, mapFrom);
      }
    } else {
      transform.maybeStep(item2.step);
    }
    if (item2.selection) {
      selection = remap ? item2.selection.map(remap.slice(mapFrom)) : item2.selection;
      remaining = new Branch(this$1.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1);
      return false;
    }
  }, this.items.length, 0);
  return { remaining, transform, selection };
};
Branch.prototype.addTransform = function addTransform(transform, selection, histOptions, preserveItems) {
  var newItems = [], eventCount = this.eventCount;
  var oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
  for (var i = 0; i < transform.steps.length; i++) {
    var step2 = transform.steps[i].invert(transform.docs[i]);
    var item2 = new Item(transform.mapping.maps[i], step2, selection), merged = void 0;
    if (merged = lastItem && lastItem.merge(item2)) {
      item2 = merged;
      if (i) {
        newItems.pop();
      } else {
        oldItems = oldItems.slice(0, oldItems.length - 1);
      }
    }
    newItems.push(item2);
    if (selection) {
      eventCount++;
      selection = null;
    }
    if (!preserveItems) {
      lastItem = item2;
    }
  }
  var overflow = eventCount - histOptions.depth;
  if (overflow > DEPTH_OVERFLOW) {
    oldItems = cutOffEvents(oldItems, overflow);
    eventCount -= overflow;
  }
  return new Branch(oldItems.append(newItems), eventCount);
};
Branch.prototype.remapping = function remapping(from4, to) {
  var maps = new Mapping();
  this.items.forEach(function(item2, i) {
    var mirrorPos = item2.mirrorOffset != null && i - item2.mirrorOffset >= from4 ? maps.maps.length - item2.mirrorOffset : null;
    maps.appendMap(item2.map, mirrorPos);
  }, from4, to);
  return maps;
};
Branch.prototype.addMaps = function addMaps(array) {
  if (this.eventCount == 0) {
    return this;
  }
  return new Branch(this.items.append(array.map(function(map14) {
    return new Item(map14);
  })), this.eventCount);
};
Branch.prototype.rebased = function rebased(rebasedTransform, rebasedCount) {
  if (!this.eventCount) {
    return this;
  }
  var rebasedItems = [], start3 = Math.max(0, this.items.length - rebasedCount);
  var mapping = rebasedTransform.mapping;
  var newUntil = rebasedTransform.steps.length;
  var eventCount = this.eventCount;
  this.items.forEach(function(item2) {
    if (item2.selection) {
      eventCount--;
    }
  }, start3);
  var iRebased = rebasedCount;
  this.items.forEach(function(item2) {
    var pos = mapping.getMirror(--iRebased);
    if (pos == null) {
      return;
    }
    newUntil = Math.min(newUntil, pos);
    var map14 = mapping.maps[pos];
    if (item2.step) {
      var step2 = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
      var selection = item2.selection && item2.selection.map(mapping.slice(iRebased + 1, pos));
      if (selection) {
        eventCount++;
      }
      rebasedItems.push(new Item(map14, step2, selection));
    } else {
      rebasedItems.push(new Item(map14));
    }
  }, start3);
  var newMaps = [];
  for (var i = rebasedCount; i < newUntil; i++) {
    newMaps.push(new Item(mapping.maps[i]));
  }
  var items = this.items.slice(0, start3).append(newMaps).append(rebasedItems);
  var branch = new Branch(items, eventCount);
  if (branch.emptyItemCount() > max_empty_items) {
    branch = branch.compress(this.items.length - rebasedItems.length);
  }
  return branch;
};
Branch.prototype.emptyItemCount = function emptyItemCount() {
  var count = 0;
  this.items.forEach(function(item2) {
    if (!item2.step) {
      count++;
    }
  });
  return count;
};
Branch.prototype.compress = function compress(upto) {
  if (upto === void 0) upto = this.items.length;
  var remap = this.remapping(0, upto), mapFrom = remap.maps.length;
  var items = [], events = 0;
  this.items.forEach(function(item2, i) {
    if (i >= upto) {
      items.push(item2);
      if (item2.selection) {
        events++;
      }
    } else if (item2.step) {
      var step2 = item2.step.map(remap.slice(mapFrom)), map14 = step2 && step2.getMap();
      mapFrom--;
      if (map14) {
        remap.appendMap(map14, mapFrom);
      }
      if (step2) {
        var selection = item2.selection && item2.selection.map(remap.slice(mapFrom));
        if (selection) {
          events++;
        }
        var newItem = new Item(map14.invert(), step2, selection), merged, last2 = items.length - 1;
        if (merged = items.length && items[last2].merge(newItem)) {
          items[last2] = merged;
        } else {
          items.push(newItem);
        }
      }
    } else if (item2.map) {
      mapFrom--;
    }
  }, this.items.length, 0);
  return new Branch(dist_default.from(items.reverse()), events);
};
Branch.empty = new Branch(dist_default.empty, 0);
function cutOffEvents(items, n) {
  var cutPoint;
  items.forEach(function(item2, i) {
    if (item2.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = function Item2(map14, step2, selection, mirrorOffset) {
  this.map = map14;
  this.step = step2;
  this.selection = selection;
  this.mirrorOffset = mirrorOffset;
};
Item.prototype.merge = function merge2(other) {
  if (this.step && other.step && !other.selection) {
    var step2 = other.step.merge(this.step);
    if (step2) {
      return new Item(step2.getMap().invert(), step2, this.selection);
    }
  }
};
var HistoryState = function HistoryState2(done2, undone, prevRanges, prevTime) {
  this.done = done2;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
};
var DEPTH_OVERFLOW = 20;
function applyTransaction2(history2, state, tr, options) {
  var historyTr = tr.getMeta(historyKey), rebased2;
  if (historyTr) {
    return historyTr.historyState;
  }
  if (tr.getMeta(closeHistoryKey)) {
    history2 = new HistoryState(history2.done, history2.undone, null, 0);
  }
  var appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo) {
      return new HistoryState(
        history2.done.addTransform(tr, null, options, mustPreserveItems(state)),
        history2.undone,
        rangesFor(tr.mapping.maps[tr.steps.length - 1]),
        history2.prevTime
      );
    } else {
      return new HistoryState(
        history2.done,
        history2.undone.addTransform(tr, null, options, mustPreserveItems(state)),
        null,
        history2.prevTime
      );
    }
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    var newGroup = history2.prevTime == 0 || !appended && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    var prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(
      history2.done.addTransform(
        tr,
        newGroup ? state.selection.getBookmark() : null,
        options,
        mustPreserveItems(state)
      ),
      Branch.empty,
      prevRanges,
      tr.time
    );
  } else if (rebased2 = tr.getMeta("rebased")) {
    return new HistoryState(
      history2.done.rebased(tr, rebased2),
      history2.undone.rebased(tr, rebased2),
      mapRanges(history2.prevRanges, tr.mapping),
      history2.prevTime
    );
  } else {
    return new HistoryState(
      history2.done.addMaps(tr.mapping.maps),
      history2.undone.addMaps(tr.mapping.maps),
      mapRanges(history2.prevRanges, tr.mapping),
      history2.prevTime
    );
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) {
    return false;
  }
  if (!transform.docChanged) {
    return true;
  }
  var adjacent = false;
  transform.mapping.maps[0].forEach(function(start3, end2) {
    for (var i = 0; i < prevRanges.length; i += 2) {
      if (start3 <= prevRanges[i + 1] && end2 >= prevRanges[i]) {
        adjacent = true;
      }
    }
  });
  return adjacent;
}
function rangesFor(map14) {
  var result2 = [];
  map14.forEach(function(_from, _to, from4, to) {
    return result2.push(from4, to);
  });
  return result2;
}
function mapRanges(ranges, mapping) {
  if (!ranges) {
    return null;
  }
  var result2 = [];
  for (var i = 0; i < ranges.length; i += 2) {
    var from4 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from4 <= to) {
      result2.push(from4, to);
    }
  }
  return result2;
}
function histTransaction(history2, state, dispatch2, redo2) {
  var preserveItems = mustPreserveItems(state), histOptions = historyKey.get(state).spec.config;
  var pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop) {
    return;
  }
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo2 ? history2.done : history2.undone).addTransform(
    pop.transform,
    state.selection.getBookmark(),
    histOptions,
    preserveItems
  );
  var newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0);
  dispatch2(pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist }).scrollIntoView());
}
var cachedPreserveItems = false;
var cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var i = 0; i < plugins.length; i++) {
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
  }
  return cachedPreserveItems;
}
var historyKey = new PluginKey("history");
var closeHistoryKey = new PluginKey("closeHistory");
function history(config) {
  config = {
    depth: config && config.depth || 100,
    newGroupDelay: config && config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init: function init5() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0);
      },
      apply: function apply9(tr, hist, state) {
        return applyTransaction2(hist, state, tr, config);
      }
    },
    config
  });
}
function undo(state, dispatch2) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) {
    return false;
  }
  if (dispatch2) {
    histTransaction(hist, state, dispatch2, false);
  }
  return true;
}
function redo(state, dispatch2) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) {
    return false;
  }
  if (dispatch2) {
    histTransaction(hist, state, dispatch2, true);
  }
  return true;
}
function undoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}

// ../../node_modules/.pnpm/@toast-ui+editor@3.1.10/node_modules/@toast-ui/editor/dist/esm/index.js
var extendStatics$1 = function(d, b) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign4(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
function __spreadArray$1(to, from4, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from4.length, ar; i < l; i++) {
    if (ar || !(i in from4)) {
      if (!ar) ar = Array.prototype.slice.call(from4, 0, i);
      ar[i] = from4[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from4));
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function forEachOwnProperties$2(obj, iteratee, context) {
  var key;
  context = context || null;
  for (key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (iteratee.call(context, obj[key], key, obj) === false) {
        break;
      }
    }
  }
}
var forEachOwnProperties_1 = forEachOwnProperties$2;
function extend(target2, objects) {
  var hasOwnProp = Object.prototype.hasOwnProperty;
  var source, prop2, i, len;
  for (i = 1, len = arguments.length; i < len; i += 1) {
    source = arguments[i];
    for (prop2 in source) {
      if (hasOwnProp.call(source, prop2)) {
        target2[prop2] = source[prop2];
      }
    }
  }
  return target2;
}
var extend_1 = extend;
function isString$3(obj) {
  return typeof obj === "string" || obj instanceof String;
}
var isString_1 = isString$3;
function isArray$3(obj) {
  return obj instanceof Array;
}
var isArray_1 = isArray$3;
function forEachArray$3(arr, iteratee, context) {
  var index3 = 0;
  var len = arr.length;
  context = context || null;
  for (; index3 < len; index3 += 1) {
    if (iteratee.call(context, arr[index3], index3, arr) === false) {
      break;
    }
  }
}
var forEachArray_1 = forEachArray$3;
var isArray$2 = isArray_1;
var forEachArray$2 = forEachArray_1;
var forEachOwnProperties$1 = forEachOwnProperties_1;
function forEach$4(obj, iteratee, context) {
  if (isArray$2(obj)) {
    forEachArray$2(obj, iteratee, context);
  } else {
    forEachOwnProperties$1(obj, iteratee, context);
  }
}
var forEach_1 = forEach$4;
var isString$2 = isString_1;
var forEach$3 = forEach_1;
function css(element, key, value) {
  var style = element.style;
  if (isString$2(key)) {
    style[key] = value;
    return;
  }
  forEach$3(key, function(v, k) {
    style[k] = v;
  });
}
var css_1 = css;
var isArray$1 = isArray_1;
function inArray$4(searchElement, array, startIndex) {
  var i;
  var length;
  startIndex = startIndex || 0;
  if (!isArray$1(array)) {
    return -1;
  }
  if (Array.prototype.indexOf) {
    return Array.prototype.indexOf.call(array, searchElement, startIndex);
  }
  length = array.length;
  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
    if (array[i] === searchElement) {
      return i;
    }
  }
  return -1;
}
var inArray_1 = inArray$4;
function isUndefined$4(obj) {
  return obj === void 0;
}
var isUndefined_1 = isUndefined$4;
var isUndefined$3 = isUndefined_1;
function getClass$3(element) {
  if (!element || !element.className) {
    return "";
  }
  if (isUndefined$3(element.className.baseVal)) {
    return element.className;
  }
  return element.className.baseVal;
}
var getClass_1 = getClass$3;
var isArray2 = isArray_1;
var isUndefined$2 = isUndefined_1;
function setClassName$2(element, cssClass) {
  cssClass = isArray2(cssClass) ? cssClass.join(" ") : cssClass;
  cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  if (isUndefined$2(element.className.baseVal)) {
    element.className = cssClass;
    return;
  }
  element.className.baseVal = cssClass;
}
var _setClassName = setClassName$2;
var forEach$2 = forEach_1;
var inArray$3 = inArray_1;
var getClass$2 = getClass_1;
var setClassName$1 = _setClassName;
function addClass(element) {
  var cssClass = Array.prototype.slice.call(arguments, 1);
  var classList = element.classList;
  var newClass = [];
  var origin;
  if (classList) {
    forEach$2(cssClass, function(name) {
      element.classList.add(name);
    });
    return;
  }
  origin = getClass$2(element);
  if (origin) {
    cssClass = [].concat(origin.split(/\s+/), cssClass);
  }
  forEach$2(cssClass, function(cls2) {
    if (inArray$3(cls2, newClass) < 0) {
      newClass.push(cls2);
    }
  });
  setClassName$1(element, newClass);
}
var addClass_1 = addClass;
var forEachArray$1 = forEachArray_1;
var inArray$2 = inArray_1;
var getClass$1 = getClass_1;
var setClassName = _setClassName;
function removeClass(element) {
  var cssClass = Array.prototype.slice.call(arguments, 1);
  var classList = element.classList;
  var origin, newClass;
  if (classList) {
    forEachArray$1(cssClass, function(name) {
      classList.remove(name);
    });
    return;
  }
  origin = getClass$1(element).split(/\s+/);
  newClass = [];
  forEachArray$1(origin, function(name) {
    if (inArray$2(name, cssClass) < 0) {
      newClass.push(name);
    }
  });
  setClassName(element, newClass);
}
var removeClass_1 = removeClass;
function isNumber(obj) {
  return typeof obj === "number" || obj instanceof Number;
}
var isNumber_1 = isNumber;
function isNull$1(obj) {
  return obj === null;
}
var isNull_1 = isNull$1;
var forEachOwnProperties2 = forEachOwnProperties_1;
function imagePing$1(url, trackingInfo) {
  var trackingElement = document.createElement("img");
  var queryString = "";
  forEachOwnProperties2(trackingInfo, function(value, key) {
    queryString += "&" + key + "=" + value;
  });
  queryString = queryString.substring(1);
  trackingElement.src = url + "?" + queryString;
  trackingElement.style.display = "none";
  document.body.appendChild(trackingElement);
  document.body.removeChild(trackingElement);
  return trackingElement;
}
var imagePing_1 = imagePing$1;
var isUndefined$1 = isUndefined_1;
var imagePing = imagePing_1;
var ms7days = 7 * 24 * 60 * 60 * 1e3;
function isExpired(date) {
  var now = (/* @__PURE__ */ new Date()).getTime();
  return now - date > ms7days;
}
function sendHostname2(appName, trackingId) {
  var url = "https://www.google-analytics.com/collect";
  var hostname = location.hostname;
  var hitType = "event";
  var eventCategory = "use";
  var applicationKeyForStorage = "TOAST UI " + appName + " for " + hostname + ": Statistics";
  var date = window.localStorage.getItem(applicationKeyForStorage);
  if (!isUndefined$1(window.tui) && window.tui.usageStatistics === false) {
    return;
  }
  if (date && !isExpired(date)) {
    return;
  }
  window.localStorage.setItem(applicationKeyForStorage, (/* @__PURE__ */ new Date()).getTime());
  setTimeout(function() {
    if (document.readyState === "interactive" || document.readyState === "complete") {
      imagePing(url, {
        v: 1,
        t: hitType,
        tid: trackingId,
        cid: hostname,
        dp: hostname,
        dh: appName,
        el: appName,
        ec: eventCategory
      });
    }
  }, 1e3);
}
var sendHostname_1 = sendHostname2;
/Mac/.test(navigator.platform);
var reSpaceMoreThanOne = /[\u0020]+/g;
var reEscapeChars$1 = /[>(){}[\]+-.!#|]/g;
var reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\-._]*)(\s|[^\\>])*\/?>|<(\/)([a-zA-Z_][a-zA-Z0-9\-._]*)\s*\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\-.:/]*)>/g;
var reEscapeBackSlash = /\\[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~\\]/g;
var reEscapePairedChars = /[*_~`]/g;
var reMdImageSyntax = /!\[.*\]\(.*\)/g;
var reEscapedCharInLinkSyntax = /[[\]]/g;
var reEscapeBackSlashInSentence = /(?:^|[^\\])\\(?!\\)/g;
var XMLSPECIAL$1 = '[&<>"]';
var reXmlSpecial$1 = new RegExp(XMLSPECIAL$1, "g");
function replaceUnsafeChar$1(char) {
  switch (char) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return char;
  }
}
function escapeXml$1(text3) {
  if (reXmlSpecial$1.test(text3)) {
    return text3.replace(reXmlSpecial$1, replaceUnsafeChar$1);
  }
  return text3;
}
function sendHostName() {
  sendHostname_1("editor", "UA-129966929-1");
}
function includes2(arr, targetItem) {
  return arr.indexOf(targetItem) !== -1;
}
var availableLinkAttributes = ["rel", "target", "hreflang", "type"];
var reMarkdownTextToEscapeMap = {
  codeblock: /(^ {4}[^\n]+\n*)+/,
  thematicBreak: /^ *((\* *){3,}|(- *){3,} *|(_ *){3,}) */,
  atxHeading: /^(#{1,6}) +[\s\S]+/,
  seTextheading: /^([^\n]+)\n *(=|-){2,} */,
  blockquote: /^( *>[^\n]+.*)+/,
  list: /^ *(\*+|-+|\d+\.) [\s\S]+/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? */,
  link: /!?\[.*\]\(.*\)/,
  reflink: /!?\[.*\]\s*\[([^\]]*)\]/,
  verticalBar: /\u007C/,
  fencedCodeblock: /^((`|~){3,})/
};
function sanitizeLinkAttribute(attribute) {
  if (!attribute) {
    return null;
  }
  var linkAttributes = {};
  availableLinkAttributes.forEach(function(key) {
    if (!isUndefined_1(attribute[key])) {
      linkAttributes[key] = attribute[key];
    }
  });
  return linkAttributes;
}
function repeat$1(text3, count) {
  var result2 = "";
  for (var i = 0; i < count; i += 1) {
    result2 += text3;
  }
  return result2;
}
function isNeedEscapeText(text3) {
  var needEscape = false;
  forEachOwnProperties_1(reMarkdownTextToEscapeMap, function(reMarkdownTextToEscape) {
    if (reMarkdownTextToEscape.test(text3)) {
      needEscape = true;
    }
    return !needEscape;
  });
  return needEscape;
}
function escapeTextForLink(text3) {
  var imageSyntaxRanges = [];
  var result2 = reMdImageSyntax.exec(text3);
  while (result2) {
    imageSyntaxRanges.push([result2.index, result2.index + result2[0].length]);
    result2 = reMdImageSyntax.exec(text3);
  }
  return text3.replace(reEscapedCharInLinkSyntax, function(matched, offset2) {
    var isDelimiter = imageSyntaxRanges.some(function(range2) {
      return offset2 > range2[0] && offset2 < range2[1];
    });
    return isDelimiter ? matched : "\\" + matched;
  });
}
function escape$1(text3) {
  var aheadReplacer = function(matched) {
    return "\\" + matched;
  };
  var behindReplacer = function(matched) {
    return matched + "\\";
  };
  var escapedText = text3.replace(reSpaceMoreThanOne, " ");
  if (reEscapeBackSlash.test(escapedText)) {
    escapedText = escapedText.replace(reEscapeBackSlash, aheadReplacer);
  }
  if (reEscapeBackSlashInSentence.test(escapedText)) {
    escapedText = escapedText.replace(reEscapeBackSlashInSentence, behindReplacer);
  }
  escapedText = escapedText.replace(reEscapePairedChars, aheadReplacer);
  if (reEscapeHTML.test(escapedText)) {
    escapedText = escapedText.replace(reEscapeHTML, aheadReplacer);
  }
  if (isNeedEscapeText(escapedText)) {
    escapedText = escapedText.replace(reEscapeChars$1, aheadReplacer);
  }
  return escapedText;
}
function quote(text3) {
  var result2;
  if (text3.indexOf('"') === -1) {
    result2 = '""';
  } else {
    result2 = text3.indexOf("'") === -1 ? "''" : "()";
  }
  return result2[0] + text3 + result2[1];
}
function isNil2(value) {
  return isNull_1(value) || isUndefined_1(value);
}
function shallowEqual(o1, o2) {
  if (o1 === null && o1 === o2) {
    return true;
  }
  if (typeof o1 !== "object" || typeof o2 !== "object" || isNil2(o1) || isNil2(o2)) {
    return o1 === o2;
  }
  for (var key in o1) {
    if (o1[key] !== o2[key]) {
      return false;
    }
  }
  for (var key in o2) {
    if (!(key in o1)) {
      return false;
    }
  }
  return true;
}
function last$1(arr) {
  return arr[arr.length - 1];
}
function between$1(value, min2, max2) {
  return value >= min2 && value <= max2;
}
function isObject$1(obj) {
  return typeof obj === "object" && obj !== null;
}
function deepMergedCopy(targetObj, obj) {
  var resultObj = __assign$1({}, targetObj);
  if (targetObj && obj) {
    Object.keys(obj).forEach(function(prop2) {
      if (isObject$1(resultObj[prop2])) {
        if (Array.isArray(obj[prop2])) {
          resultObj[prop2] = deepCopyArray(obj[prop2]);
        } else if (resultObj.hasOwnProperty(prop2)) {
          resultObj[prop2] = deepMergedCopy(resultObj[prop2], obj[prop2]);
        } else {
          resultObj[prop2] = deepCopy(obj[prop2]);
        }
      } else {
        resultObj[prop2] = obj[prop2];
      }
    });
  }
  return resultObj;
}
function deepCopyArray(items) {
  return items.map(function(item2) {
    if (isObject$1(item2)) {
      return Array.isArray(item2) ? deepCopyArray(item2) : deepCopy(item2);
    }
    return item2;
  });
}
function deepCopy(obj) {
  var keys2 = Object.keys(obj);
  if (!keys2.length) {
    return obj;
  }
  return keys2.reduce(function(acc, prop2) {
    if (isObject$1(obj[prop2])) {
      acc[prop2] = Array.isArray(obj[prop2]) ? deepCopyArray(obj[prop2]) : deepCopy(obj[prop2]);
    } else {
      acc[prop2] = obj[prop2];
    }
    return acc;
  }, {});
}
function assign(targetObj, obj) {
  if (obj === void 0) {
    obj = {};
  }
  Object.keys(obj).forEach(function(prop2) {
    if (targetObj.hasOwnProperty(prop2) && typeof targetObj[prop2] === "object") {
      if (Array.isArray(obj[prop2])) {
        targetObj[prop2] = obj[prop2];
      } else {
        assign(targetObj[prop2], obj[prop2]);
      }
    } else {
      targetObj[prop2] = obj[prop2];
    }
  });
  return targetObj;
}
function getSortedNumPair(valueA, valueB) {
  return valueA > valueB ? [valueB, valueA] : [valueA, valueB];
}
function isStartWithSpace(text3) {
  var reStartWithSpace = /^\s(\S*)/g;
  return reStartWithSpace.test(text3);
}
function isEndWithSpace(text3) {
  var reEndWithSpace = /(\S*)\s$/g;
  return reEndWithSpace.test(text3);
}
var forEachArray = forEachArray_1;
function toArray$1(arrayLike) {
  var arr;
  try {
    arr = Array.prototype.slice.call(arrayLike);
  } catch (e) {
    arr = [];
    forEachArray(arrayLike, function(value) {
      arr.push(value);
    });
  }
  return arr;
}
var toArray_1 = toArray$1;
function createParagraph(schema, content2) {
  var paragraph2 = schema.nodes.paragraph;
  if (!content2) {
    return paragraph2.createAndFill();
  }
  return paragraph2.create(null, isString_1(content2) ? schema.text(content2) : content2);
}
function createTextNode$1(schema, text3, marks2) {
  return schema.text(text3, marks2);
}
function createTextSelection(tr, from4, to) {
  if (to === void 0) {
    to = from4;
  }
  var contentSize = tr.doc.content.size;
  var size = contentSize > 0 ? contentSize - 1 : 1;
  return TextSelection.create(tr.doc, Math.min(from4, size), Math.min(to, size));
}
function addParagraph(tr, _a, schema) {
  var pos = _a.pos;
  tr.replaceWith(pos, pos, createParagraph(schema));
  return tr.setSelection(createTextSelection(tr, pos + 1));
}
function replaceTextNode(_a) {
  var state = _a.state, from4 = _a.from, startIndex = _a.startIndex, endIndex = _a.endIndex, createText = _a.createText;
  var tr = state.tr, doc2 = state.doc, schema = state.schema;
  for (var i = startIndex; i <= endIndex; i += 1) {
    var _b = doc2.child(i), nodeSize2 = _b.nodeSize, textContent = _b.textContent, content2 = _b.content;
    var text3 = createText(textContent);
    var node4 = text3 ? createTextNode$1(schema, text3) : Fragment.empty;
    var mappedFrom = tr.mapping.map(from4);
    var mappedTo = mappedFrom + content2.size;
    tr.replaceWith(mappedFrom, mappedTo, node4);
    from4 += nodeSize2;
  }
  return tr;
}
function splitAndExtendBlock(tr, pos, text3, node4) {
  var textLen = text3.length;
  tr.split(pos).delete(pos - textLen, pos).insert(tr.mapping.map(pos), node4).setSelection(createTextSelection(tr, tr.mapping.map(pos) - textLen));
}
function getMdStartLine2(mdNode) {
  return mdNode.sourcepos[0][0];
}
function getMdEndLine2(mdNode) {
  return mdNode.sourcepos[1][0];
}
function getMdStartCh(mdNode) {
  return mdNode.sourcepos[0][1];
}
function getMdEndCh(mdNode) {
  return mdNode.sourcepos[1][1];
}
function isHTMLNode(mdNode) {
  var type = mdNode.type;
  return type === "htmlBlock" || type === "htmlInline";
}
function isStyledInlineNode2(mdNode) {
  var type = mdNode.type;
  return type === "strike" || type === "strong" || type === "emph" || type === "code" || type === "link" || type === "image";
}
function isCodeBlockNode(mdNode) {
  return mdNode && mdNode.type === "codeBlock";
}
function isListNode$1(mdNode) {
  return mdNode && (mdNode.type === "item" || mdNode.type === "list");
}
function isOrderedListNode(mdNode) {
  return isListNode$1(mdNode) && mdNode.listData.type === "ordered";
}
function isBulletListNode(mdNode) {
  return isListNode$1(mdNode) && mdNode.listData.type !== "ordered";
}
function isTableCellNode(mdNode) {
  return mdNode && (mdNode.type === "tableCell" || mdNode.type === "tableDelimCell");
}
function isInlineNode$1(mdNode) {
  switch (mdNode.type) {
    case "code":
    case "text":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "htmlInline":
    case "linebreak":
    case "softbreak":
    case "customInline":
      return true;
    default:
      return false;
  }
}
function findClosestNode(mdNode, condition, includeSelf) {
  if (includeSelf === void 0) {
    includeSelf = true;
  }
  mdNode = includeSelf ? mdNode : mdNode.parent;
  while (mdNode && mdNode.type !== "document") {
    if (condition(mdNode)) {
      return mdNode;
    }
    mdNode = mdNode.parent;
  }
  return null;
}
function traverseParentNodes(mdNode, iteratee, includeSelf) {
  if (includeSelf === void 0) {
    includeSelf = true;
  }
  mdNode = includeSelf ? mdNode : mdNode.parent;
  while (mdNode && mdNode.type !== "document") {
    iteratee(mdNode);
    mdNode = mdNode.parent;
  }
}
function addOffsetPos(originPos, offset2) {
  return [originPos[0], originPos[1] + offset2];
}
function setOffsetPos(originPos, newOffset) {
  return [originPos[0], newOffset];
}
function getInlineMarkdownText(mdNode) {
  var text3 = mdNode.firstChild.literal;
  switch (mdNode.type) {
    case "emph":
      return "*" + text3 + "*";
    case "strong":
      return "**" + text3 + "**";
    case "strike":
      return "~~" + text3 + "~~";
    case "code":
      return "`" + text3 + "`";
    case "link":
    case "image":
      var _a = mdNode, destination = _a.destination, title = _a.title;
      var delim = mdNode.type === "link" ? "" : "!";
      return delim + "[" + text3 + "](" + destination + (title ? ' "' + title + '"' : "") + ")";
    default:
      return null;
  }
}
function isContainer$2(node4) {
  switch (node4.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return true;
    default:
      return false;
  }
}
function getChildrenText$1(node4) {
  var buffer = [];
  var walker = node4.walker();
  var event = null;
  while (event = walker.next()) {
    var childNode = event.node;
    if (childNode.type === "text") {
      buffer.push(childNode.literal);
    }
  }
  return buffer.join("");
}
var widgetRules = [];
var widgetRuleMap = {};
var reWidgetPrefix = /\$\$widget\d+\s/;
function unwrapWidgetSyntax(text3) {
  var index3 = text3.search(reWidgetPrefix);
  if (index3 !== -1) {
    var rest = text3.substring(index3);
    var replaced = rest.replace(reWidgetPrefix, "").replace("$$", "");
    text3 = text3.substring(0, index3);
    text3 += unwrapWidgetSyntax(replaced);
  }
  return text3;
}
function createWidgetContent(info, text3) {
  return "$$" + info + " " + text3 + "$$";
}
function widgetToDOM(info, text3) {
  var _a = widgetRuleMap[info], rule = _a.rule, toDOM = _a.toDOM;
  var matches4 = unwrapWidgetSyntax(text3).match(rule);
  if (matches4) {
    text3 = matches4[0];
  }
  return toDOM(text3);
}
function getWidgetRules() {
  return widgetRules;
}
function setWidgetRules(rules) {
  widgetRules = rules;
  widgetRules.forEach(function(rule, index3) {
    widgetRuleMap["widget" + index3] = rule;
  });
}
function mergeNodes(nodes, text3, schema, ruleIndex) {
  return nodes.concat(createNodesWithWidget(text3, schema, ruleIndex));
}
function createNodesWithWidget(text3, schema, ruleIndex) {
  if (ruleIndex === void 0) {
    ruleIndex = 0;
  }
  var nodes = [];
  var rule = (widgetRules[ruleIndex] || {}).rule;
  var nextRuleIndex = ruleIndex + 1;
  text3 = unwrapWidgetSyntax(text3);
  if (rule && rule.test(text3)) {
    var index3 = void 0;
    while ((index3 = text3.search(rule)) !== -1) {
      var prev = text3.substring(0, index3);
      if (prev) {
        nodes = mergeNodes(nodes, prev, schema, nextRuleIndex);
      }
      text3 = text3.substring(index3);
      var literal = text3.match(rule)[0];
      var info = "widget" + ruleIndex;
      nodes.push(schema.nodes.widget.create({ info }, schema.text(createWidgetContent(info, literal))));
      text3 = text3.substring(literal.length);
    }
    if (text3) {
      nodes = mergeNodes(nodes, text3, schema, nextRuleIndex);
    }
  } else if (text3) {
    nodes = ruleIndex < widgetRules.length - 1 ? mergeNodes(nodes, text3, schema, nextRuleIndex) : [schema.text(text3)];
  }
  return nodes;
}
function getWidgetContent(widgetNode) {
  var event;
  var text3 = "";
  var walker = widgetNode.walker();
  while (event = walker.next()) {
    var node4 = event.node, entering = event.entering;
    if (entering) {
      if (node4 !== widgetNode && node4.type !== "text") {
        text3 += getInlineMarkdownText(node4);
        walker.resumeAt(widgetNode, false);
        walker.next();
      } else if (node4.type === "text") {
        text3 += node4.literal;
      }
    }
  }
  return text3;
}
function getDefaultCommands() {
  return {
    deleteSelection: function() {
      return deleteSelection;
    },
    selectAll: function() {
      return selectAll;
    },
    undo: function() {
      return undo;
    },
    redo: function() {
      return redo;
    }
  };
}
function placeholder(options) {
  return new Plugin({
    props: {
      decorations: function(state) {
        var doc2 = state.doc;
        if (options.text && doc2.childCount === 1 && doc2.firstChild.isTextblock && doc2.firstChild.content.size === 0) {
          var placeHolder = document.createElement("span");
          addClass_1(placeHolder, "placeholder");
          if (options.className) {
            addClass_1(placeHolder, options.className);
          }
          placeHolder.textContent = options.text;
          return DecorationSet.create(doc2, [Decoration.widget(1, placeHolder)]);
        }
        return null;
      }
    }
  });
}
var inArray$1 = inArray_1;
var getClass = getClass_1;
function hasClass(element, cssClass) {
  var origin;
  if (element.classList) {
    return element.classList.contains(cssClass);
  }
  origin = getClass(element).split(/\s+/);
  return inArray$1(cssClass, origin) > -1;
}
var hasClass_1 = hasClass;
var inArray = inArray_1;
var toArray2 = toArray_1;
var elProto = Element.prototype;
var matchSelector = elProto.matches || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || function(selector) {
  var doc2 = this.document || this.ownerDocument;
  return inArray(this, toArray2(doc2.querySelectorAll(selector))) > -1;
};
function matches3(element, selector) {
  return matchSelector.call(element, selector);
}
var matches_1 = matches3;
var TAG_NAME = "[A-Za-z][A-Za-z0-9-]*";
var ATTRIBUTE_NAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var UNQUOTED_VALUE = "[^\"'=<>`\\x00-\\x20]+";
var SINGLE_QUOTED_VALUE = "'[^']*'";
var DOUBLE_QUOTED_VALUE = '"[^"]*"';
var ATTRIBUTE_VALUE = "(?:" + UNQUOTED_VALUE + "|" + SINGLE_QUOTED_VALUE + "|" + DOUBLE_QUOTED_VALUE + ")";
var ATTRIBUTE_VALUE_SPEC = "(?:\\s*=\\s*" + ATTRIBUTE_VALUE + ")";
var ATTRIBUTE$1 = "(?:\\s+" + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + "?)";
var OPEN_TAG2 = "<(" + TAG_NAME + ")(" + ATTRIBUTE$1 + ")*\\s*/?>";
var CLOSE_TAG = "</(" + TAG_NAME + ")\\s*[>]";
var HTML_TAG2 = "(?:" + OPEN_TAG2 + "|" + CLOSE_TAG + ")";
var reHTMLTag = new RegExp("^" + HTML_TAG2, "i");
var reBR2 = /<br\s*\/*>/i;
var reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;
var ALTERNATIVE_TAG_FOR_BR2 = "</p><p>";
var DEFAULT_TEXT_NOT_START_OR_END_WITH_SPACE = "a";
function isPositionInBox(style, offsetX, offsetY) {
  var left = parseInt(style.left, 10);
  var top2 = parseInt(style.top, 10);
  var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);
  var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);
  return offsetX >= left && offsetX <= left + width && offsetY >= top2 && offsetY <= top2 + height;
}
var CLS_PREFIX = "toastui-editor-";
function cls() {
  var names = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    names[_i] = arguments[_i];
  }
  var result2 = [];
  for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {
    var name_1 = names_1[_a];
    var className = void 0;
    if (Array.isArray(name_1)) {
      className = name_1[0] ? name_1[1] : null;
    } else {
      className = name_1;
    }
    if (className) {
      result2.push("" + CLS_PREFIX + className);
    }
  }
  return result2.join(" ");
}
function clsWithMdPrefix() {
  var names = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    names[_i] = arguments[_i];
  }
  return names.map(function(className) {
    return CLS_PREFIX + "md-" + className;
  }).join(" ");
}
function isTextNode(node4) {
  return (node4 === null || node4 === void 0 ? void 0 : node4.nodeType) === Node.TEXT_NODE;
}
function isElemNode(node4) {
  return node4 && node4.nodeType === Node.ELEMENT_NODE;
}
function findNodes(element, selector) {
  var nodeList = toArray_1(element.querySelectorAll(selector));
  if (nodeList.length) {
    return nodeList;
  }
  return [];
}
function appendNodes(node4, nodesToAppend) {
  nodesToAppend = isArray_1(nodesToAppend) ? toArray_1(nodesToAppend) : [nodesToAppend];
  nodesToAppend.forEach(function(nodeToAppend) {
    node4.appendChild(nodeToAppend);
  });
}
function insertBeforeNode(insertedNode, node4) {
  if (node4.parentNode) {
    node4.parentNode.insertBefore(insertedNode, node4);
  }
}
function removeNode$1(node4) {
  if (node4.parentNode) {
    node4.parentNode.removeChild(node4);
  }
}
function unwrapNode(node4) {
  var result2 = [];
  while (node4.firstChild) {
    result2.push(node4.firstChild);
    if (node4.parentNode) {
      node4.parentNode.insertBefore(node4.firstChild, node4);
    }
  }
  removeNode$1(node4);
  return result2;
}
function toggleClass(element, className, state) {
  if (isUndefined_1(state)) {
    state = !hasClass_1(element, className);
  }
  var toggleFn = state ? addClass_1 : removeClass_1;
  toggleFn(element, className);
}
function createElementWith(contents, target2) {
  var container = document.createElement("div");
  if (isString_1(contents)) {
    container.innerHTML = contents;
  } else {
    container.appendChild(contents);
  }
  var firstChild = container.firstChild;
  if (target2) {
    target2.appendChild(firstChild);
  }
  return firstChild;
}
function getOuterWidth(el2) {
  var computed = window.getComputedStyle(el2);
  return ["margin-left", "margin-right"].reduce(function(acc, type) {
    return acc + parseInt(computed.getPropertyValue(type), 10);
  }, 0) + el2.offsetWidth;
}
function closest(node4, found2) {
  var condition;
  if (isString_1(found2)) {
    condition = function(target2) {
      return matches_1(target2, found2);
    };
  } else {
    condition = function(target2) {
      return target2 === found2;
    };
  }
  while (node4 && node4 !== document) {
    if (isElemNode(node4) && condition(node4)) {
      return node4;
    }
    node4 = node4.parentNode;
  }
  return null;
}
function getTotalOffset(el2, root) {
  var offsetTop = 0;
  var offsetLeft = 0;
  while (el2 && el2 !== root) {
    var top_1 = el2.offsetTop, left = el2.offsetLeft, offsetParent = el2.offsetParent;
    offsetTop += top_1;
    offsetLeft += left;
    if (offsetParent === root.offsetParent) {
      break;
    }
    el2 = el2.offsetParent;
  }
  return { offsetTop, offsetLeft };
}
function setAttributes(attributes, element) {
  Object.keys(attributes).forEach(function(attrName) {
    if (isNil2(attributes[attrName])) {
      element.removeAttribute(attrName);
    } else {
      element.setAttribute(attrName, attributes[attrName]);
    }
  });
}
function replaceBRWithEmptyBlock(html2) {
  var replacedHTML = html2.replace(/<p><br\s*\/*><\/p>/gi, "<p></p>");
  var reHTMLTag2 = new RegExp(HTML_TAG2, "ig");
  var htmlTagMatched = replacedHTML.match(reHTMLTag2);
  htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function(htmlTag, index3) {
    if (reBR2.test(htmlTag)) {
      var alternativeTag = ALTERNATIVE_TAG_FOR_BR2;
      if (index3) {
        var prevTag = htmlTagMatched[index3 - 1];
        var openTagMatched = prevTag.match(OPEN_TAG2);
        if (openTagMatched && !/br/i.test(openTagMatched[1])) {
          var tagName = openTagMatched[1];
          alternativeTag = "</" + tagName + "><" + tagName + ">";
        }
      }
      replacedHTML = replacedHTML.replace(reBR2, alternativeTag);
    }
  });
  return replacedHTML;
}
var pluginKey$1 = new PluginKey("widget");
var MARGIN = 5;
var PopupWidget = (
  /** @class */
  (function() {
    function PopupWidget2(view, eventEmitter) {
      var _this = this;
      this.popup = null;
      this.removeWidget = function() {
        if (_this.popup) {
          _this.rootEl.removeChild(_this.popup);
          _this.popup = null;
        }
      };
      this.rootEl = view.dom.parentElement;
      this.eventEmitter = eventEmitter;
      this.eventEmitter.listen("blur", this.removeWidget);
      this.eventEmitter.listen("loadUI", function() {
        _this.rootEl = closest(view.dom.parentElement, "." + cls("defaultUI"));
      });
      this.eventEmitter.listen("removePopupWidget", this.removeWidget);
    }
    PopupWidget2.prototype.update = function(view) {
      var widget2 = pluginKey$1.getState(view.state);
      this.removeWidget();
      if (widget2) {
        var node4 = widget2.node, style = widget2.style;
        var _a = view.coordsAtPos(widget2.pos), top_1 = _a.top, left = _a.left, bottom2 = _a.bottom;
        var height = bottom2 - top_1;
        var rect2 = this.rootEl.getBoundingClientRect();
        var relTopPos = top_1 - rect2.top;
        css_1(node4, { opacity: "0" });
        this.rootEl.appendChild(node4);
        css_1(node4, {
          position: "absolute",
          left: left - rect2.left + MARGIN + "px",
          top: (style === "bottom" ? relTopPos + height - MARGIN : relTopPos - height) + "px",
          opacity: "1"
        });
        this.popup = node4;
        view.focus();
      }
    };
    PopupWidget2.prototype.destroy = function() {
      this.eventEmitter.removeEventHandler("blur", this.removeWidget);
    };
    return PopupWidget2;
  })()
);
function addWidget(eventEmitter) {
  return new Plugin({
    key: pluginKey$1,
    state: {
      init: function() {
        return null;
      },
      apply: function(tr) {
        return tr.getMeta("widget");
      }
    },
    view: function(editorView) {
      return new PopupWidget(editorView, eventEmitter);
    }
  });
}
function addDefaultImageBlobHook(eventEmitter) {
  eventEmitter.listen("addImageBlobHook", function(blob, callback) {
    var reader = new FileReader();
    reader.onload = function(_a) {
      var target2 = _a.target;
      return callback(target2.result);
    };
    reader.readAsDataURL(blob);
  });
}
function emitImageBlobHook(eventEmitter, blob, type) {
  var hook = function(imageUrl, altText) {
    eventEmitter.emit("command", "addImage", {
      imageUrl,
      altText: altText || blob.name || "image"
    });
  };
  eventEmitter.emit("addImageBlobHook", blob, hook, type);
}
function pasteImageOnly(items) {
  var images = toArray_1(items).filter(function(_a) {
    var type = _a.type;
    return type.indexOf("image") !== -1;
  });
  if (images.length === 1) {
    var item2 = images[0];
    if (item2) {
      return item2.getAsFile();
    }
  }
  return null;
}
function dropImage(_a) {
  var eventEmitter = _a.eventEmitter;
  return new Plugin({
    props: {
      handleDOMEvents: {
        drop: function(_, ev) {
          var _a2;
          var items = (_a2 = ev.dataTransfer) === null || _a2 === void 0 ? void 0 : _a2.files;
          if (items) {
            forEachArray_1(items, function(item2) {
              if (item2.type.indexOf("image") !== -1) {
                ev.preventDefault();
                ev.stopPropagation();
                emitImageBlobHook(eventEmitter, item2, ev.type);
                return false;
              }
              return true;
            });
          }
          return true;
        }
      }
    }
  });
}
var Node$2 = (
  /** @class */
  (function() {
    function Node4() {
    }
    Object.defineProperty(Node4.prototype, "type", {
      get: function() {
        return "node";
      },
      enumerable: false,
      configurable: true
    });
    Node4.prototype.setContext = function(context) {
      this.context = context;
    };
    return Node4;
  })()
);
function widgetNodeView(pmNode) {
  var dom = document.createElement("span");
  var node4 = widgetToDOM(pmNode.attrs.info, pmNode.textContent);
  dom.className = "tui-widget";
  dom.appendChild(node4);
  return { dom };
}
function isWidgetNode(pmNode) {
  return pmNode.type.name === "widget";
}
var Widget = (
  /** @class */
  (function(_super) {
    __extends$1(Widget2, _super);
    function Widget2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Widget2.prototype, "name", {
      get: function() {
        return "widget";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Widget2.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            info: { default: null }
          },
          group: "inline",
          inline: true,
          content: "text*",
          selectable: false,
          atom: true,
          toDOM: function() {
            return ["span", { class: "tui-widget" }, 0];
          },
          parseDOM: [
            {
              tag: "span.tui-widget",
              getAttrs: function(dom) {
                var text3 = dom.textContent;
                var _a = text3.match(/\$\$(widget\d+)/), info = _a[1];
                return { info };
              }
            }
          ]
        };
      },
      enumerable: false,
      configurable: true
    });
    return Widget2;
  })(Node$2)
);
var EditorBase = (
  /** @class */
  (function() {
    function EditorBase2(eventEmitter) {
      this.timer = null;
      this.el = document.createElement("div");
      this.el.className = "toastui-editor";
      this.eventEmitter = eventEmitter;
      this.placeholder = { text: "" };
    }
    EditorBase2.prototype.createState = function() {
      return EditorState.create({
        schema: this.schema,
        plugins: this.createPlugins()
      });
    };
    EditorBase2.prototype.initEvent = function() {
      var _a = this, eventEmitter = _a.eventEmitter, view = _a.view, editorType = _a.editorType;
      view.dom.addEventListener("focus", function() {
        return eventEmitter.emit("focus", editorType);
      });
      view.dom.addEventListener("blur", function() {
        return eventEmitter.emit("blur", editorType);
      });
    };
    EditorBase2.prototype.emitChangeEvent = function(tr) {
      this.eventEmitter.emit("caretChange", this.editorType);
      if (tr.docChanged) {
        this.eventEmitter.emit("change", this.editorType);
      }
    };
    Object.defineProperty(EditorBase2.prototype, "defaultPlugins", {
      get: function() {
        var rules = this.createInputRules();
        var plugins = __spreadArray$1(__spreadArray$1([], this.keymaps), [
          keymap(__assign$1({ "Shift-Enter": baseKeymap.Enter }, baseKeymap)),
          history(),
          placeholder(this.placeholder),
          addWidget(this.eventEmitter),
          dropImage(this.context)
        ]);
        return rules ? plugins.concat(rules) : plugins;
      },
      enumerable: false,
      configurable: true
    });
    EditorBase2.prototype.createInputRules = function() {
      var widgetRules2 = getWidgetRules();
      var rules = widgetRules2.map(function(_a) {
        var rule = _a.rule;
        return new InputRule(rule, function(state, match, start3, end2) {
          var schema = state.schema, tr = state.tr, doc2 = state.doc;
          var allMatched = match.input.match(new RegExp(rule, "g"));
          var pos = doc2.resolve(start3);
          var parent = pos.parent;
          var count = 0;
          if (isWidgetNode(parent)) {
            parent = pos.node(pos.depth - 1);
          }
          parent.forEach(function(child3) {
            return isWidgetNode(child3) && (count += 1);
          });
          if (allMatched.length > count) {
            var content2 = last$1(allMatched);
            var nodes = createNodesWithWidget(content2, schema);
            return tr.replaceWith(end2 - content2.length + 1, end2, nodes);
          }
          return null;
        });
      });
      return rules.length ? inputRules({ rules }) : null;
    };
    EditorBase2.prototype.clearTimer = function() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    };
    EditorBase2.prototype.createSchema = function() {
      return new Schema({
        nodes: this.specs.nodes,
        marks: this.specs.marks
      });
    };
    EditorBase2.prototype.createKeymaps = function(useCommandShortcut) {
      var _a = getDefaultCommands(), undo2 = _a.undo, redo2 = _a.redo;
      var allKeymaps = this.specs.keymaps(useCommandShortcut);
      var historyKeymap = {
        "Mod-z": undo2(),
        "Shift-Mod-z": redo2()
      };
      return useCommandShortcut ? allKeymaps.concat(keymap(historyKeymap)) : allKeymaps;
    };
    EditorBase2.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    };
    EditorBase2.prototype.createPluginProps = function() {
      var _this = this;
      return this.extraPlugins.map(function(plugin) {
        return plugin(_this.eventEmitter);
      });
    };
    EditorBase2.prototype.focus = function() {
      var _this = this;
      this.clearTimer();
      this.timer = setTimeout(function() {
        _this.view.focus();
        _this.view.dispatch(_this.view.state.tr.scrollIntoView());
      });
    };
    EditorBase2.prototype.blur = function() {
      this.view.dom.blur();
    };
    EditorBase2.prototype.destroy = function() {
      var _this = this;
      this.clearTimer();
      this.view.destroy();
      Object.keys(this).forEach(function(prop2) {
        delete _this[prop2];
      });
    };
    EditorBase2.prototype.moveCursorToStart = function(focus2) {
      var tr = this.view.state.tr;
      this.view.dispatch(tr.setSelection(createTextSelection(tr, 1)).scrollIntoView());
      if (focus2) {
        this.focus();
      }
    };
    EditorBase2.prototype.moveCursorToEnd = function(focus2) {
      var tr = this.view.state.tr;
      this.view.dispatch(tr.setSelection(createTextSelection(tr, tr.doc.content.size - 1)).scrollIntoView());
      if (focus2) {
        this.focus();
      }
    };
    EditorBase2.prototype.setScrollTop = function(top2) {
      this.view.dom.scrollTop = top2;
    };
    EditorBase2.prototype.getScrollTop = function() {
      return this.view.dom.scrollTop;
    };
    EditorBase2.prototype.setPlaceholder = function(text3) {
      this.placeholder.text = text3;
      this.view.dispatch(this.view.state.tr.scrollIntoView());
    };
    EditorBase2.prototype.setHeight = function(height) {
      css_1(this.el, { height: height + "px" });
    };
    EditorBase2.prototype.setMinHeight = function(minHeight) {
      css_1(this.el, { minHeight: minHeight + "px" });
    };
    EditorBase2.prototype.getElement = function() {
      return this.el;
    };
    return EditorBase2;
  })()
);
function isFunction(obj) {
  return obj instanceof Function;
}
var isFunction_1 = isFunction;
var defaultCommandShortcuts = [
  "Enter",
  "Shift-Enter",
  "Mod-Enter",
  "Tab",
  "Shift-Tab",
  "Delete",
  "Backspace",
  "Mod-Delete",
  "Mod-Backspace",
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "Mod-d",
  "Mod-D",
  "Alt-ArrowUp",
  "Alt-ArrowDown"
];
function execCommand(view, command, payload) {
  view.focus();
  return command(payload)(view.state, view.dispatch, view);
}
var SpecManager = (
  /** @class */
  (function() {
    function SpecManager2(specs) {
      this.specs = specs;
    }
    Object.defineProperty(SpecManager2.prototype, "nodes", {
      get: function() {
        return this.specs.filter(function(spec) {
          return spec.type === "node";
        }).reduce(function(nodes, _a) {
          var _b;
          var name = _a.name, schema = _a.schema;
          return __assign$1(__assign$1({}, nodes), (_b = {}, _b[name] = schema, _b));
        }, {});
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(SpecManager2.prototype, "marks", {
      get: function() {
        return this.specs.filter(function(spec) {
          return spec.type === "mark";
        }).reduce(function(marks2, _a) {
          var _b;
          var name = _a.name, schema = _a.schema;
          return __assign$1(__assign$1({}, marks2), (_b = {}, _b[name] = schema, _b));
        }, {});
      },
      enumerable: false,
      configurable: true
    });
    SpecManager2.prototype.commands = function(view, addedCommands) {
      var specCommands = this.specs.filter(function(_a) {
        var commands = _a.commands;
        return commands;
      }).reduce(function(allCommands, spec) {
        var commands = {};
        var specCommand = spec.commands();
        if (isFunction_1(specCommand)) {
          commands[spec.name] = function(payload) {
            return execCommand(view, specCommand, payload);
          };
        } else {
          Object.keys(specCommand).forEach(function(name) {
            commands[name] = function(payload) {
              return execCommand(view, specCommand[name], payload);
            };
          });
        }
        return __assign$1(__assign$1({}, allCommands), commands);
      }, {});
      var defaultCommands = getDefaultCommands();
      Object.keys(defaultCommands).forEach(function(name) {
        specCommands[name] = function(payload) {
          return execCommand(view, defaultCommands[name], payload);
        };
      });
      if (addedCommands) {
        Object.keys(addedCommands).forEach(function(name) {
          specCommands[name] = function(payload) {
            return execCommand(view, addedCommands[name], payload);
          };
        });
      }
      return specCommands;
    };
    SpecManager2.prototype.keymaps = function(useCommandShortcut) {
      var specKeymaps = this.specs.filter(function(spec) {
        return spec.keymaps;
      }).map(function(spec) {
        return spec.keymaps();
      });
      return specKeymaps.map(function(keys2) {
        if (!useCommandShortcut) {
          Object.keys(keys2).forEach(function(key) {
            if (!includes2(defaultCommandShortcuts, key)) {
              delete keys2[key];
            }
          });
        }
        return keymap(keys2);
      });
    };
    SpecManager2.prototype.setContext = function(context) {
      this.specs.forEach(function(spec) {
        spec.setContext(context);
      });
    };
    return SpecManager2;
  })()
);
function resolveSelectionPos(selection) {
  var from4 = selection.from, to = selection.to;
  if (selection instanceof AllSelection) {
    return [from4 + 1, to - 1];
  }
  return [from4, to];
}
function getMdLine(resolvedPos) {
  return resolvedPos.index(0) + 1;
}
function getWidgetNodePos(node4, chPos, direction) {
  if (direction === void 0) {
    direction = 1;
  }
  var additionalPos = 0;
  node4.forEach(function(child3, pos) {
    if (isWidgetNode(child3) && pos + 2 < chPos) {
      additionalPos += 2 * direction;
    }
  });
  return additionalPos;
}
function getEditorToMdPos(doc2, from4, to) {
  if (to === void 0) {
    to = from4;
  }
  var collapsed = from4 === to;
  var startResolvedPos = doc2.resolve(from4);
  var startLine = getMdLine(startResolvedPos);
  var endLine = startLine;
  var startOffset = startResolvedPos.start(1);
  var endOffset = startOffset;
  if (!collapsed) {
    var endResolvedPos = doc2.resolve(to === doc2.content.size ? to - 1 : to);
    endOffset = endResolvedPos.start(1);
    endLine = getMdLine(endResolvedPos);
    if (endResolvedPos.pos === doc2.content.size) {
      to = doc2.content.size - 2;
    }
  }
  var startCh = Math.max(from4 - startOffset + 1, 1);
  var endCh = Math.max(to - endOffset + 1, 1);
  return [
    [startLine, startCh + getWidgetNodePos(doc2.child(startLine - 1), startCh, -1)],
    [endLine, endCh + getWidgetNodePos(doc2.child(endLine - 1), endCh, -1)]
  ];
}
function getStartPosListPerLine(doc2, endIndex) {
  var startPosListPerLine = [];
  for (var i = 0, pos = 0; i < endIndex; i += 1) {
    var child3 = doc2.child(i);
    startPosListPerLine[i] = pos;
    pos += child3.nodeSize;
  }
  return startPosListPerLine;
}
function getMdToEditorPos(doc2, startPos, endPos) {
  var startPosListPerLine = getStartPosListPerLine(doc2, endPos[0]);
  var startIndex = startPos[0] - 1;
  var endIndex = endPos[0] - 1;
  var startNode = doc2.child(startIndex);
  var endNode = doc2.child(endIndex);
  var from4 = startPosListPerLine[startIndex];
  var to = startPosListPerLine[endIndex];
  from4 += startPos[1] + getWidgetNodePos(startNode, startPos[1] - 1);
  to += endPos[1] + getWidgetNodePos(endNode, endPos[1] - 1);
  return [from4, Math.min(to, doc2.content.size)];
}
function getRangeInfo(selection) {
  var $from = selection.$from, $to = selection.$to;
  var from4 = selection.from, to = selection.to;
  var doc2 = $from.doc;
  if (selection instanceof AllSelection) {
    $from = doc2.resolve(from4 + 1);
    $to = doc2.resolve(to - 1);
  }
  if ($from.depth === 0) {
    $from = doc2.resolve(from4 - 1);
    $to = $from;
  }
  return {
    startFromOffset: $from.start(1),
    endFromOffset: $to.start(1),
    startToOffset: $from.end(1),
    endToOffset: $to.end(1),
    startIndex: $from.index(0),
    endIndex: $to.index(0),
    from: $from.pos,
    to: $to.pos
  };
}
function getNodeContentOffsetRange(doc2, targetIndex) {
  var startOffset = 1;
  var endOffset = 1;
  for (var i = 0, offset2 = 0; i < doc2.childCount; i += 1) {
    var nodeSize2 = doc2.child(i).nodeSize;
    startOffset = offset2 + 1;
    endOffset = offset2 + nodeSize2 - 1;
    if (i === targetIndex) {
      break;
    }
    offset2 += nodeSize2;
  }
  return { startOffset, endOffset };
}
var HEADING = "heading";
var BLOCK_QUOTE = "blockQuote";
var LIST_ITEM = "listItem";
var TABLE = "table";
var TABLE_CELL = "tableCell";
var CODE_BLOCK = "codeBlock";
var THEMATIC_BREAK = "thematicBreak";
var LINK = "link";
var CODE = "code";
var META = "meta";
var DELIM = "delimiter";
var TASK_DELIM = "taskDelimiter";
var TEXT = "markedText";
var HTML = "html";
var CUSTOM_BLOCK = "customBlock";
var delimSize = {
  strong: 2,
  emph: 1,
  strike: 2
};
function markInfo(start3, end2, type, attrs) {
  return { start: start3, end: end2, spec: { type, attrs } };
}
function heading$1(_a, start3, end2) {
  var level = _a.level, headingType = _a.headingType;
  var marks2 = [markInfo(start3, end2, HEADING, { level })];
  if (headingType === "atx") {
    marks2.push(markInfo(start3, addOffsetPos(start3, level), DELIM));
  } else {
    marks2.push(markInfo(setOffsetPos(end2, 0), end2, HEADING, { seText: true }));
  }
  return marks2;
}
function emphasisAndStrikethrough(_a, start3, end2) {
  var type = _a.type;
  var startDelimPos = addOffsetPos(start3, delimSize[type]);
  var endDelimPos = addOffsetPos(end2, -delimSize[type]);
  return [
    markInfo(startDelimPos, endDelimPos, type),
    markInfo(start3, startDelimPos, DELIM),
    markInfo(endDelimPos, end2, DELIM)
  ];
}
function markLink(start3, end2, linkTextStart, lastChildCh) {
  return [
    markInfo(start3, end2, LINK),
    markInfo(setOffsetPos(start3, linkTextStart[1] + 1), setOffsetPos(end2, lastChildCh), LINK, {
      desc: true
    }),
    markInfo(setOffsetPos(end2, lastChildCh + 2), addOffsetPos(end2, -1), LINK, { url: true })
  ];
}
function image$1(_a, start3, end2) {
  var lastChild = _a.lastChild;
  var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 3;
  var linkTextEnd = addOffsetPos(start3, 1);
  return __spreadArray$1([markInfo(start3, linkTextEnd, META)], markLink(start3, end2, linkTextEnd, lastChildCh));
}
function link(_a, start3, end2) {
  var lastChild = _a.lastChild, extendedAutolink = _a.extendedAutolink;
  var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 2;
  return extendedAutolink ? [markInfo(start3, end2, LINK, { desc: true })] : markLink(start3, end2, start3, lastChildCh);
}
function code(_a, start3, end2) {
  var tickCount = _a.tickCount;
  var openDelimEnd = addOffsetPos(start3, tickCount);
  var closeDelimStart = addOffsetPos(end2, -tickCount);
  return [
    markInfo(start3, end2, CODE),
    markInfo(start3, openDelimEnd, CODE, { start: true }),
    markInfo(openDelimEnd, closeDelimStart, CODE, { marked: true }),
    markInfo(closeDelimStart, end2, CODE, { end: true })
  ];
}
function lineBackground(parent, start3, end2, prefix) {
  var defaultBackground = {
    start: start3,
    end: end2,
    spec: {
      attrs: { className: prefix + "-line-background", codeStart: start3[0], codeEnd: end2[0] }
    },
    lineBackground: true
  };
  return parent.type !== "item" && parent.type !== "blockQuote" ? [
    __assign$1(__assign$1({}, defaultBackground), { end: start3, spec: { attrs: { className: prefix + "-line-background start" } } }),
    __assign$1(__assign$1({}, defaultBackground), { start: [Math.min(start3[0] + 1, end2[0]), start3[1]] })
  ] : null;
}
function codeBlock$1(node4, start3, end2, endLine) {
  var fenceOffset = node4.fenceOffset, fenceLength = node4.fenceLength, fenceChar = node4.fenceChar, info = node4.info, infoPadding = node4.infoPadding, parent = node4.parent;
  var fenceEnd = fenceOffset + fenceLength;
  var marks2 = [markInfo(setOffsetPos(start3, 1), end2, CODE_BLOCK)];
  if (fenceChar) {
    marks2.push(markInfo(start3, addOffsetPos(start3, fenceEnd), DELIM));
  }
  if (info) {
    marks2.push(markInfo(addOffsetPos(start3, fenceLength), addOffsetPos(start3, fenceLength + infoPadding + info.length), META));
  }
  var codeBlockEnd = "^(\\s{0,4})(" + fenceChar + "{" + fenceLength + ",})";
  var reCodeBlockEnd = new RegExp(codeBlockEnd);
  if (reCodeBlockEnd.test(endLine)) {
    marks2.push(markInfo(setOffsetPos(end2, 1), end2, DELIM));
  }
  var lineBackgroundMarkInfo = lineBackground(parent, start3, end2, "code-block");
  return lineBackgroundMarkInfo ? marks2.concat(lineBackgroundMarkInfo) : marks2;
}
function customBlock$2(node4, start3, end2) {
  var _a = node4, offset2 = _a.offset, syntaxLength = _a.syntaxLength, info = _a.info, parent = _a.parent;
  var syntaxEnd = offset2 + syntaxLength;
  var marks2 = [markInfo(setOffsetPos(start3, 1), end2, CUSTOM_BLOCK)];
  marks2.push(markInfo(start3, addOffsetPos(start3, syntaxEnd), DELIM));
  if (info) {
    marks2.push(markInfo(addOffsetPos(start3, syntaxEnd), addOffsetPos(start3, syntaxLength + info.length), META));
  }
  marks2.push(markInfo(setOffsetPos(end2, 1), end2, DELIM));
  var lineBackgroundMarkInfo = lineBackground(parent, start3, end2, "custom-block");
  return lineBackgroundMarkInfo ? marks2.concat(lineBackgroundMarkInfo) : marks2;
}
function markListItemChildren(node4, markType) {
  var marks2 = [];
  while (node4) {
    var type = node4.type;
    if (type === "paragraph" || type === "codeBlock") {
      marks2.push(markInfo([getMdStartLine2(node4), getMdStartCh(node4) - 1], [getMdEndLine2(node4), getMdEndCh(node4) + 1], markType));
    }
    node4 = node4.next;
  }
  return marks2;
}
function markParagraphInBlockQuote(node4) {
  var marks2 = [];
  while (node4) {
    marks2.push(markInfo([getMdStartLine2(node4), getMdStartCh(node4)], [getMdEndLine2(node4), getMdEndCh(node4) + 1], TEXT));
    node4 = node4.next;
  }
  return marks2;
}
function blockQuote$2(node4, start3, end2) {
  var marks2 = node4.parent && node4.parent.type !== "blockQuote" ? [markInfo(start3, end2, BLOCK_QUOTE)] : [];
  if (node4.firstChild) {
    var childMarks = [];
    if (node4.firstChild.type === "paragraph") {
      childMarks = markParagraphInBlockQuote(node4.firstChild.firstChild);
    } else if (node4.firstChild.type === "list") {
      childMarks = markListItemChildren(node4.firstChild, TEXT);
    }
    marks2 = __spreadArray$1(__spreadArray$1([], marks2), childMarks);
  }
  return marks2;
}
function getSpecOfListItemStyle(node4) {
  var depth = 0;
  while (node4.parent.parent && node4.parent.parent.type === "item") {
    node4 = node4.parent.parent;
    depth += 1;
  }
  var attrs = [{ odd: true }, { even: true }][depth % 2];
  return [LIST_ITEM, __assign$1(__assign$1({}, attrs), { listStyle: true })];
}
function item$1(node4, start3) {
  var _a = node4.listData, padding = _a.padding, task2 = _a.task;
  var spec = getSpecOfListItemStyle(node4);
  var marks2 = [markInfo.apply(void 0, __spreadArray$1([start3, addOffsetPos(start3, padding)], spec))];
  if (task2) {
    marks2.push(markInfo(addOffsetPos(start3, padding), addOffsetPos(start3, padding + 3), TASK_DELIM));
    marks2.push(markInfo(addOffsetPos(start3, padding + 1), addOffsetPos(start3, padding + 2), META));
  }
  return marks2.concat(markListItemChildren(node4.firstChild, TEXT));
}
var markNodeFuncMap = {
  heading: heading$1,
  strong: emphasisAndStrikethrough,
  emph: emphasisAndStrikethrough,
  strike: emphasisAndStrikethrough,
  link,
  image: image$1,
  code,
  codeBlock: codeBlock$1,
  blockQuote: blockQuote$2,
  item: item$1,
  customBlock: customBlock$2
};
var simpleMarkClassNameMap = {
  thematicBreak: THEMATIC_BREAK,
  table: TABLE,
  tableCell: TABLE_CELL,
  htmlInline: HTML
};
function getMarkInfo(node4, start3, end2, endLine) {
  var type = node4.type;
  if (isFunction_1(markNodeFuncMap[type])) {
    return markNodeFuncMap[type](node4, start3, end2, endLine);
  }
  if (simpleMarkClassNameMap[type]) {
    return [markInfo(start3, end2, simpleMarkClassNameMap[type])];
  }
  return null;
}
var removingBackgroundIndexMap = {};
function syntaxHighlight(_a) {
  var schema = _a.schema, toastMark = _a.toastMark;
  return new Plugin({
    appendTransaction: function(transactions, _, newState) {
      var tr = transactions[0];
      var newTr = newState.tr;
      if (tr.docChanged) {
        var markInfo_1 = [];
        var editResult = tr.getMeta("editResult");
        editResult.forEach(function(result2) {
          var nodes = result2.nodes, removedNodeRange = result2.removedNodeRange;
          if (nodes.length) {
            markInfo_1 = markInfo_1.concat(getMarkForRemoving(newTr, nodes));
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
              var parent_1 = nodes_1[_i];
              var walker = parent_1.walker();
              var event_1 = walker.next();
              while (event_1) {
                var node4 = event_1.node, entering = event_1.entering;
                if (entering) {
                  markInfo_1 = markInfo_1.concat(getMarkForAdding(node4, toastMark));
                }
                event_1 = walker.next();
              }
            }
          } else if (removedNodeRange) {
            var maxIndex = newTr.doc.childCount - 1;
            var _a2 = removedNodeRange.line, startLine = _a2[0], endLine = _a2[1];
            var startIndex = Math.min(startLine, maxIndex);
            var endIndex = Math.min(endLine, maxIndex);
            for (var i = startIndex; i <= endIndex; i += 1) {
              removingBackgroundIndexMap[i] = true;
            }
          }
        });
        appendMarkTr(newTr, schema, markInfo_1);
      }
      return newTr.setMeta("widget", tr.getMeta("widget"));
    }
  });
}
function isDifferentBlock(doc2, index3, attrs) {
  return Object.keys(attrs).some(function(name) {
    return attrs[name] !== doc2.child(index3).attrs[name];
  });
}
function addLineBackground(tr, doc2, paragraph2, blockPosInfo, attrs) {
  if (attrs === void 0) {
    attrs = {};
  }
  var startIndex = blockPosInfo.startIndex, endIndex = blockPosInfo.endIndex, from4 = blockPosInfo.from, to = blockPosInfo.to;
  var shouldChangeBlockType = false;
  for (var i = startIndex; i <= endIndex; i += 1) {
    delete removingBackgroundIndexMap[i];
    shouldChangeBlockType = isDifferentBlock(doc2, i, attrs);
  }
  if (shouldChangeBlockType) {
    tr.setBlockType(from4, to, paragraph2, attrs);
  }
}
function appendMarkTr(tr, schema, marks2) {
  var doc2 = tr.doc;
  var paragraph2 = schema.nodes.paragraph;
  var startPosListPerLine = getStartPosListPerLine(doc2, doc2.childCount);
  marks2.forEach(function(_a) {
    var start3 = _a.start, end2 = _a.end, spec = _a.spec, lineBackground2 = _a.lineBackground;
    var startIndex = Math.min(start3[0], doc2.childCount) - 1;
    var endIndex = Math.min(end2[0], doc2.childCount) - 1;
    var startNode = doc2.child(startIndex);
    var endNode = doc2.child(endIndex);
    var from4 = startPosListPerLine[startIndex];
    var to = startPosListPerLine[endIndex];
    from4 += start3[1] + getWidgetNodePos(startNode, start3[1] - 1);
    to += end2[1] + getWidgetNodePos(endNode, end2[1] - 1);
    if (spec) {
      if (lineBackground2) {
        var posInfo = { from: from4, to, startIndex, endIndex };
        addLineBackground(tr, doc2, paragraph2, posInfo, spec.attrs);
      } else {
        tr.addMark(from4, to, schema.mark(spec.type, spec.attrs));
      }
    } else {
      tr.removeMark(from4, to);
    }
  });
  removeBlockBackground(tr, startPosListPerLine, paragraph2);
}
function removeBlockBackground(tr, startPosListPerLine, paragraph2) {
  Object.keys(removingBackgroundIndexMap).forEach(function(index3) {
    var startIndex = Number(index3);
    var endIndex = Math.min(Number(index3) + 1, tr.doc.childCount - 1);
    var from4 = startPosListPerLine[startIndex];
    var to = startPosListPerLine[endIndex] - 1;
    if (startIndex === endIndex) {
      to += 2;
    }
    tr.setBlockType(from4, to, paragraph2);
  });
}
function cacheIndexToRemoveBackground(doc2, start3, end2) {
  var skipLines = [];
  removingBackgroundIndexMap = {};
  for (var i = start3[0] - 1; i < end2[0]; i += 1) {
    var node4 = doc2.child(i);
    var codeEnd = node4.attrs.codeEnd;
    var codeStart = node4.attrs.codeStart;
    if (codeStart && codeEnd && !includes2(skipLines, codeStart)) {
      skipLines.push(codeStart);
      codeEnd = Math.min(codeEnd, doc2.childCount);
      var startIndex = codeStart - 1;
      var endIndex = end2[0];
      for (var index3 = startIndex; index3 < endIndex; index3 += 1) {
        removingBackgroundIndexMap[index3] = true;
      }
    }
  }
}
function getMarkForRemoving(_a, nodes) {
  var doc2 = _a.doc;
  var start3 = nodes[0].sourcepos[0];
  var _b = last$1(nodes).sourcepos, end2 = _b[1];
  var startPos = [start3[0], start3[1]];
  var endPos = [end2[0], end2[1] + 1];
  var marks2 = [];
  cacheIndexToRemoveBackground(doc2, start3, end2);
  marks2.push({ start: startPos, end: endPos });
  return marks2;
}
function getMarkForAdding(node4, toastMark) {
  var lineTexts = toastMark.getLineTexts();
  var startPos = [getMdStartLine2(node4), getMdStartCh(node4)];
  var endPos = [getMdEndLine2(node4), getMdEndCh(node4) + 1];
  var markInfo2 = getMarkInfo(node4, startPos, endPos, lineTexts[endPos[0] - 1]);
  return markInfo2 !== null && markInfo2 !== void 0 ? markInfo2 : [];
}
var defaultToolbarStateKeys = [
  "taskList",
  "orderedList",
  "bulletList",
  "table",
  "strong",
  "emph",
  "strike",
  "heading",
  "thematicBreak",
  "blockQuote",
  "code",
  "codeBlock",
  "indent",
  "outdent"
];
function getToolbarStateType$1(mdNode) {
  var type = mdNode.type;
  if (isListNode$1(mdNode)) {
    if (mdNode.listData.task) {
      return "taskList";
    }
    return mdNode.listData.type === "ordered" ? "orderedList" : "bulletList";
  }
  if (type.indexOf("table") !== -1) {
    return "table";
  }
  if (!includes2(defaultToolbarStateKeys, type)) {
    return null;
  }
  return type;
}
function getToolbarState$1(targetNode) {
  var toolbarState = {
    indent: { active: false, disabled: true },
    outdent: { active: false, disabled: true }
  };
  var listEnabled = true;
  traverseParentNodes(targetNode, function(mdNode) {
    var type = getToolbarStateType$1(mdNode);
    if (!type) {
      return;
    }
    if (type === "bulletList" || type === "orderedList") {
      if (listEnabled) {
        toolbarState[type] = { active: true };
        toolbarState.indent.disabled = false;
        toolbarState.outdent.disabled = false;
        listEnabled = false;
      }
    } else {
      toolbarState[type] = { active: true };
    }
  });
  return toolbarState;
}
function previewHighlight(_a) {
  var toastMark = _a.toastMark, eventEmitter = _a.eventEmitter;
  return new Plugin({
    view: function() {
      return {
        update: function(view, prevState) {
          var state = view.state;
          var doc2 = state.doc, selection = state.selection;
          if (prevState && prevState.doc.eq(doc2) && prevState.selection.eq(selection)) {
            return;
          }
          var from4 = selection.from;
          var startChOffset = state.doc.resolve(from4).start();
          var line = state.doc.content.findIndex(from4).index + 1;
          var ch = from4 - startChOffset;
          if (from4 === startChOffset) {
            ch += 1;
          }
          var cursorPos = [line, ch];
          var mdNode = toastMark.findNodeAtPosition(cursorPos);
          var toolbarState = getToolbarState$1(mdNode);
          eventEmitter.emit("changeToolbarState", {
            cursorPos,
            mdNode,
            toolbarState
          });
          eventEmitter.emit("setFocusedNode", mdNode);
        }
      };
    }
  });
}
var Doc$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Doc2, _super);
    function Doc2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Doc2.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Doc2.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: false,
      configurable: true
    });
    return Doc2;
  })(Node$2)
);
var Mark3 = (
  /** @class */
  (function() {
    function Mark4() {
    }
    Object.defineProperty(Mark4.prototype, "type", {
      get: function() {
        return "mark";
      },
      enumerable: false,
      configurable: true
    });
    Mark4.prototype.setContext = function(context) {
      this.context = context;
    };
    return Mark4;
  })()
);
function getTextByMdLine(doc2, mdLine) {
  return getTextContent(doc2, mdLine - 1);
}
function getTextContent(doc2, index3) {
  return doc2.child(index3).textContent;
}
var reBlockQuote = /^\s*> ?/;
var BlockQuote$1 = (
  /** @class */
  (function(_super) {
    __extends$1(BlockQuote2, _super);
    function BlockQuote2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BlockQuote2.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BlockQuote2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("block-quote") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    BlockQuote2.prototype.createBlockQuoteText = function(text3, isBlockQuote) {
      return isBlockQuote ? text3.replace(reBlockQuote, "").trim() : "> " + text3.trim();
    };
    BlockQuote2.prototype.extendBlockQuote = function() {
      var _this = this;
      return function(_a, dispatch2) {
        var selection = _a.selection, doc2 = _a.doc, tr = _a.tr, schema = _a.schema;
        var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;
        var textContent = getTextContent(doc2, endIndex);
        var isBlockQuote = reBlockQuote.test(textContent);
        if (isBlockQuote && to > endFromOffset && selection.empty) {
          var isEmpty2 = !textContent.replace(reBlockQuote, "").trim();
          if (isEmpty2) {
            tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));
          } else {
            var slicedText = textContent.slice(to - endFromOffset).trim();
            var node4 = createTextNode$1(schema, _this.createBlockQuoteText(slicedText));
            splitAndExtendBlock(tr, endToOffset, slicedText, node4);
          }
          dispatch2(tr);
          return true;
        }
        return false;
      };
    };
    BlockQuote2.prototype.commands = function() {
      var _this = this;
      return function() {
        return function(state, dispatch2) {
          var selection = state.selection, doc2 = state.doc;
          var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;
          var isBlockQuote = reBlockQuote.test(getTextContent(doc2, startIndex));
          var tr = replaceTextNode({
            state,
            startIndex,
            endIndex,
            from: startFromOffset,
            createText: function(textContent) {
              return _this.createBlockQuoteText(textContent, isBlockQuote);
            }
          });
          dispatch2(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));
          return true;
        };
      };
    };
    BlockQuote2.prototype.keymaps = function() {
      var blockQuoteCommand = this.commands()();
      return {
        "alt-q": blockQuoteCommand,
        "alt-Q": blockQuoteCommand,
        Enter: this.extendBlockQuote()
      };
    };
    return BlockQuote2;
  })(Mark3)
);
var reList = /(^\s*)([-*+] |[\d]+\. )/;
var reOrderedList = /(^\s*)([\d])+\.( \[[ xX]])? /;
var reOrderedListGroup = /^(\s*)((\d+)([.)]\s(?:\[(?:x|\s)\]\s)?))(.*)/;
var reCanBeTaskList = /(^\s*)([-*+]|[\d]+\.)( \[[ xX]])? /;
var reBulletListGroup = /^(\s*)([-*+]+(\s(?:\[(?:x|\s)\]\s)?))(.*)/;
var reTaskList = /(^\s*)([-*+] |[\d]+\. )(\[[ xX]] )/;
var reBulletTaskList = /(^\s*)([-*+])( \[[ xX]]) /;
function getListType(text3) {
  return reOrderedList.test(text3) ? "ordered" : "bullet";
}
function getListDepth(mdNode) {
  var depth = 0;
  while (mdNode && mdNode.type !== "document") {
    if (mdNode.type === "list") {
      depth += 1;
    }
    mdNode = mdNode.parent;
  }
  return depth;
}
function findSameDepthList(toastMark, currentLine, depth, backward) {
  var lineTexts = toastMark.getLineTexts();
  var lineLen = lineTexts.length;
  var result2 = [];
  var line = currentLine;
  while (backward ? line < lineLen : line > 1) {
    line = backward ? line + 1 : line - 1;
    var mdNode = toastMark.findFirstNodeAtLine(line);
    var currentListDepth = getListDepth(mdNode);
    if (currentListDepth === depth) {
      result2.push({ line, depth, mdNode });
    } else if (currentListDepth < depth) {
      break;
    }
  }
  return result2;
}
function getSameDepthItems(_a) {
  var toastMark = _a.toastMark, mdNode = _a.mdNode, line = _a.line;
  var depth = getListDepth(mdNode);
  var forwardList = findSameDepthList(toastMark, line, depth, false).reverse();
  var backwardList = findSameDepthList(toastMark, line, depth, true);
  return forwardList.concat([{ line, depth, mdNode }]).concat(backwardList);
}
function textToBullet(text3) {
  if (!reList.test(text3)) {
    return "* " + text3;
  }
  var type = getListType(text3);
  if (type === "bullet" && reCanBeTaskList.test(text3)) {
    text3 = text3.replace(reBulletTaskList, "$1$2 ");
  } else if (type === "ordered") {
    text3 = text3.replace(reOrderedList, "$1* ");
  }
  return text3;
}
function textToOrdered(text3, ordinalNum) {
  if (!reList.test(text3)) {
    return ordinalNum + ". " + text3;
  }
  var type = getListType(text3);
  if (type === "bullet" || type === "ordered" && reCanBeTaskList.test(text3)) {
    text3 = text3.replace(reCanBeTaskList, "$1" + ordinalNum + ". ");
  } else if (type === "ordered") {
    var start3 = reOrderedListGroup.exec(text3)[3];
    if (Number(start3) !== ordinalNum) {
      text3 = text3.replace(reOrderedList, "$1" + ordinalNum + ". ");
    }
  }
  return text3;
}
function getChangedInfo(doc2, sameDepthItems, type, start3) {
  if (start3 === void 0) {
    start3 = 0;
  }
  var firstIndex = Number.MAX_VALUE;
  var lastIndex = 0;
  var changedResults = sameDepthItems.map(function(_a, index3) {
    var line = _a.line;
    firstIndex = Math.min(line - 1, firstIndex);
    lastIndex = Math.max(line - 1, lastIndex);
    var text3 = getTextByMdLine(doc2, line);
    text3 = type === "bullet" ? textToBullet(text3) : textToOrdered(text3, index3 + 1 + start3);
    return { text: text3, line };
  });
  return { changedResults, firstIndex, lastIndex };
}
function getBulletOrOrdered(type, context) {
  var sameDepthListInfo = getSameDepthItems(context);
  return getChangedInfo(context.doc, sameDepthListInfo, type);
}
var otherListToList = {
  bullet: function(context) {
    return getBulletOrOrdered("bullet", context);
  },
  ordered: function(context) {
    return getBulletOrOrdered("ordered", context);
  },
  task: function(_a) {
    var mdNode = _a.mdNode, doc2 = _a.doc, line = _a.line;
    var text3 = getTextByMdLine(doc2, line);
    if (mdNode.listData.task) {
      text3 = text3.replace(reTaskList, "$1$2");
    } else if (isListNode$1(mdNode)) {
      text3 = text3.replace(reList, "$1$2[ ] ");
    }
    return { changedResults: [{ text: text3, line }] };
  }
};
var otherNodeToList = {
  bullet: function(_a) {
    var doc2 = _a.doc, line = _a.line;
    var lineText = getTextByMdLine(doc2, line);
    var changedResults = [{ text: "* " + lineText, line }];
    return { changedResults };
  },
  ordered: function(_a) {
    var toastMark = _a.toastMark, doc2 = _a.doc, line = _a.line, startLine = _a.startLine;
    var lineText = getTextByMdLine(doc2, line);
    var firstOrderedListNum = 1;
    var firstOrderedListLine = startLine;
    var skipped = 0;
    for (var i = startLine - 1; i > 0; i -= 1) {
      var mdNode = toastMark.findFirstNodeAtLine(i);
      var text3 = getTextByMdLine(doc2, i);
      var canBeListNode = text3 && !!findClosestNode(mdNode, function(targetNode) {
        return isListNode$1(targetNode);
      });
      var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc2, i));
      if (!searchResult && !canBeListNode) {
        break;
      }
      if (!searchResult && canBeListNode) {
        skipped += 1;
        continue;
      }
      var _b = searchResult, indent2 = _b[1], start3 = _b[3];
      if (!indent2) {
        firstOrderedListNum = Number(start3);
        firstOrderedListLine = i;
        break;
      }
    }
    var ordinalNum = firstOrderedListNum + line - firstOrderedListLine - skipped;
    var changedResults = [{ text: ordinalNum + ". " + lineText, line }];
    return { changedResults };
  },
  task: function(_a) {
    var doc2 = _a.doc, line = _a.line;
    var lineText = getTextByMdLine(doc2, line);
    var changedResults = [{ text: "* [ ] " + lineText, line }];
    return { changedResults };
  }
};
var extendList = {
  bullet: function(_a) {
    var line = _a.line, doc2 = _a.doc;
    var lineText = getTextByMdLine(doc2, line);
    var _b = reBulletListGroup.exec(lineText), indent2 = _b[1], delimiter = _b[2];
    return { listSyntax: "" + indent2 + delimiter };
  },
  ordered: function(_a) {
    var toastMark = _a.toastMark, line = _a.line, mdNode = _a.mdNode, doc2 = _a.doc;
    var depth = getListDepth(mdNode);
    var lineText = getTextByMdLine(doc2, line);
    var _b = reOrderedListGroup.exec(lineText), indent2 = _b[1], start3 = _b[3], delimiter = _b[4];
    var ordinalNum = Number(start3) + 1;
    var listSyntax = "" + indent2 + ordinalNum + delimiter;
    var backwardList = findSameDepthList(toastMark, line, depth, true);
    var filteredList = backwardList.filter(function(info) {
      var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc2, info.line));
      return searchResult && searchResult[1].length === indent2.length && !!findClosestNode(info.mdNode, function(targetNode) {
        return isOrderedListNode(targetNode);
      });
    });
    return __assign$1({ listSyntax }, getChangedInfo(doc2, filteredList, "ordered", ordinalNum));
  }
};
function getReorderedListInfo(doc2, schema, line, ordinalNum, prevIndentLength) {
  var nodes = [];
  var lineText = getTextByMdLine(doc2, line);
  var searchResult = reOrderedListGroup.exec(lineText);
  while (searchResult) {
    var indent2 = searchResult[1], delimiter = searchResult[4], text3 = searchResult[5];
    var indentLength = indent2.length;
    if (indentLength === prevIndentLength) {
      nodes.push(createTextNode$1(schema, "" + indent2 + ordinalNum + delimiter + text3));
      ordinalNum += 1;
      line += 1;
    } else if (indentLength > prevIndentLength) {
      var nestedListInfo = getReorderedListInfo(doc2, schema, line, 1, indentLength);
      line = nestedListInfo.line;
      nodes = nodes.concat(nestedListInfo.nodes);
    }
    if (indentLength < prevIndentLength || line > doc2.childCount) {
      break;
    }
    lineText = getTextByMdLine(doc2, line);
    searchResult = reOrderedListGroup.exec(lineText);
  }
  return { nodes, line };
}
var reStartSpace = /(^\s{1,4})(.*)/;
function isBlockUnit(from4, to, text3) {
  return from4 < to || reList.test(text3) || reBlockQuote.test(text3);
}
function isInTableCellNode(doc2, schema, selection) {
  var $pos = selection.$from;
  if ($pos.depth === 0) {
    $pos = doc2.resolve($pos.pos - 1);
  }
  var node4 = $pos.node(1);
  var startOffset = $pos.start(1);
  var contentSize = node4.content.size;
  return node4.rangeHasMark(0, contentSize, schema.marks.table) && $pos.pos - startOffset !== contentSize && $pos.pos !== startOffset;
}
function createSelection(tr, posInfo) {
  var from4 = posInfo.from, to = posInfo.to;
  if (posInfo.type === "indent") {
    var softTabLen = 4;
    from4 += softTabLen;
    to += (posInfo.lineLen + 1) * softTabLen;
  } else {
    var spaceLenList = posInfo.spaceLenList;
    from4 -= spaceLenList[0];
    for (var i = 0; i < spaceLenList.length; i += 1) {
      to -= spaceLenList[i];
    }
  }
  return createTextSelection(tr, from4, to);
}
var Paragraph$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Paragraph2, _super);
    function Paragraph2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Paragraph2.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Paragraph2.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          attrs: {
            className: { default: null },
            codeStart: { default: null },
            codeEnd: { default: null }
          },
          selectable: false,
          group: "block",
          parseDOM: [{ tag: "div" }],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return attrs.className ? ["div", { class: clsWithMdPrefix(attrs.className) }, 0] : ["div", 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Paragraph2.prototype.reorderList = function(startLine, endLine) {
      var _a = this.context, view = _a.view, toastMark = _a.toastMark, schema = _a.schema;
      var _b = view.state, tr = _b.tr, selection = _b.selection, doc2 = _b.doc;
      var mdNode = toastMark.findFirstNodeAtLine(startLine);
      var topListNode = mdNode;
      while (mdNode && !isBulletListNode(mdNode) && mdNode.parent.type !== "document") {
        mdNode = mdNode.parent;
        if (isOrderedListNode(mdNode)) {
          topListNode = mdNode;
          break;
        }
      }
      if (topListNode) {
        startLine = topListNode.sourcepos[0][0];
      }
      var _c = reOrderedListGroup.exec(getTextByMdLine(doc2, startLine)), indent2 = _c[1], start3 = _c[3];
      var indentLen = indent2.length;
      var _d = getReorderedListInfo(doc2, schema, startLine, Number(start3), indentLen), line = _d.line, nodes = _d.nodes;
      endLine = Math.max(endLine, line - 1);
      var startOffset = getNodeContentOffsetRange(doc2, startLine - 1).startOffset;
      for (var i = startLine - 1; i <= endLine - 1; i += 1) {
        var _e = doc2.child(i), nodeSize2 = _e.nodeSize, content2 = _e.content;
        var mappedFrom = tr.mapping.map(startOffset);
        var mappedTo = mappedFrom + content2.size;
        tr.replaceWith(mappedFrom, mappedTo, nodes[i - startLine + 1]);
        startOffset += nodeSize2;
      }
      var newSelection = createTextSelection(tr, selection.from, selection.to);
      view.dispatch(tr.setSelection(newSelection));
    };
    Paragraph2.prototype.indent = function(tabKey) {
      var _this = this;
      if (tabKey === void 0) {
        tabKey = false;
      }
      return function() {
        return function(state, dispatch2) {
          var schema = state.schema, selection = state.selection, doc2 = state.doc;
          var _a = getRangeInfo(selection), from4 = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;
          if (tabKey && isInTableCellNode(doc2, schema, selection)) {
            return false;
          }
          var startLineText = getTextContent(doc2, startIndex);
          if (tabKey && isBlockUnit(from4, to, startLineText) || !tabKey && reList.test(startLineText)) {
            var tr = replaceTextNode({
              state,
              from: startFromOffset,
              startIndex,
              endIndex,
              createText: function(textContent) {
                return "    " + textContent;
              }
            });
            var posInfo = {
              type: "indent",
              from: from4,
              to,
              lineLen: endIndex - startIndex
            };
            dispatch2(tr.setSelection(createSelection(tr, posInfo)));
            if (reOrderedListGroup.test(startLineText)) {
              _this.reorderList(startIndex + 1, endIndex + 1);
            }
          } else if (tabKey) {
            dispatch2(state.tr.insert(to, createTextNode$1(schema, "    ")));
          }
          return true;
        };
      };
    };
    Paragraph2.prototype.outdent = function(tabKey) {
      var _this = this;
      if (tabKey === void 0) {
        tabKey = false;
      }
      return function() {
        return function(state, dispatch2) {
          var selection = state.selection, doc2 = state.doc, schema = state.schema;
          var _a = getRangeInfo(selection), from4 = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;
          if (tabKey && isInTableCellNode(doc2, schema, selection)) {
            return false;
          }
          var startLineText = getTextContent(doc2, startIndex);
          if (tabKey && isBlockUnit(from4, to, startLineText) || !tabKey && reList.test(startLineText)) {
            var spaceLenList_1 = [];
            var tr = replaceTextNode({
              state,
              from: startFromOffset,
              startIndex,
              endIndex,
              createText: function(textContent) {
                var searchResult = reStartSpace.exec(textContent);
                spaceLenList_1.push(searchResult ? searchResult[1].length : 0);
                return textContent.replace(reStartSpace, "$2");
              }
            });
            var posInfo = { type: "outdent", from: from4, to, spaceLenList: spaceLenList_1 };
            dispatch2(tr.setSelection(createSelection(tr, posInfo)));
            if (reOrderedListGroup.test(startLineText)) {
              _this.reorderList(startIndex + 1, endIndex + 1);
            }
          } else if (tabKey) {
            var startText = startLineText.slice(0, to - startFromOffset);
            var startTextWithoutSpace = startText.replace(/\s{1,4}$/, "");
            var deletStart = to - (startText.length - startTextWithoutSpace.length);
            dispatch2(state.tr.delete(deletStart, to));
          }
          return true;
        };
      };
    };
    Paragraph2.prototype.deleteLines = function() {
      var _this = this;
      return function(state, dispatch2) {
        var view = _this.context.view;
        var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;
        var deleteRange = function() {
          dispatch2(state.tr.deleteRange(startFromOffset, endToOffset));
          return true;
        };
        return chainCommands(deleteRange, joinForward)(state, dispatch2, view);
      };
    };
    Paragraph2.prototype.moveDown = function() {
      return function(state, dispatch2) {
        var doc2 = state.doc, tr = state.tr, selection = state.selection, schema = state.schema;
        var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, endIndex = _a.endIndex;
        if (endIndex < doc2.content.childCount - 1) {
          var _b = doc2.child(endIndex + 1), nodeSize2 = _b.nodeSize, textContent = _b.textContent;
          tr.delete(endToOffset, endToOffset + nodeSize2).split(startFromOffset).insert(tr.mapping.map(startFromOffset) - 2, createTextNode$1(schema, textContent));
          dispatch2(tr);
          return true;
        }
        return false;
      };
    };
    Paragraph2.prototype.moveUp = function() {
      return function(state, dispatch2) {
        var tr = state.tr, doc2 = state.doc, selection = state.selection, schema = state.schema;
        var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex;
        if (startIndex > 0) {
          var _b = doc2.child(startIndex - 1), nodeSize2 = _b.nodeSize, textContent = _b.textContent;
          tr.delete(startFromOffset - nodeSize2, startFromOffset).split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), createTextNode$1(schema, textContent));
          dispatch2(tr);
          return true;
        }
        return false;
      };
    };
    Paragraph2.prototype.commands = function() {
      return {
        indent: this.indent(),
        outdent: this.outdent()
      };
    };
    Paragraph2.prototype.keymaps = function() {
      return {
        Tab: this.indent(true)(),
        "Shift-Tab": this.outdent(true)(),
        "Mod-d": this.deleteLines(),
        "Mod-D": this.deleteLines(),
        "Alt-ArrowUp": this.moveUp(),
        "Alt-ArrowDown": this.moveDown()
      };
    };
    return Paragraph2;
  })(Node$2)
);
var Text$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Text2, _super);
    function Text2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Text2.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: false,
      configurable: true
    });
    return Text2;
  })(Node$2)
);
var reHeading = /^#{1,6}\s/;
var Heading$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Heading2, _super);
    function Heading2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Heading2.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Heading2.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            level: { default: 1 },
            seText: { default: false }
          },
          toDOM: function(_a) {
            var attrs = _a.attrs;
            var level = attrs.level, seText = attrs.seText;
            var classNames = "heading|heading" + level;
            if (seText) {
              classNames += "|delimiter|setext";
            }
            return ["span", { class: clsWithMdPrefix.apply(void 0, classNames.split("|")) }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Heading2.prototype.createHeadingText = function(level, text3, curHeadingSyntax) {
      var textContent = text3.replace(curHeadingSyntax, "").trim();
      var headingText = "";
      while (level > 0) {
        headingText += "#";
        level -= 1;
      }
      return headingText + " " + textContent;
    };
    Heading2.prototype.commands = function() {
      var _this = this;
      return function(payload) {
        return function(state, dispatch2) {
          var level = payload.level;
          var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;
          var tr = replaceTextNode({
            state,
            from: startFromOffset,
            startIndex,
            endIndex,
            createText: function(textContent) {
              var matchedHeading = textContent.match(reHeading);
              var curHeadingSyntax = matchedHeading ? matchedHeading[0] : "";
              return _this.createHeadingText(level, textContent, curHeadingSyntax);
            }
          });
          dispatch2(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));
          return true;
        };
      };
    };
    return Heading2;
  })(Mark3)
);
var fencedCodeBlockSyntax = "```";
var CodeBlock$1 = (
  /** @class */
  (function(_super) {
    __extends$1(CodeBlock2, _super);
    function CodeBlock2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CodeBlock2.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CodeBlock2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("code-block") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    CodeBlock2.prototype.commands = function() {
      return function() {
        return function(state, dispatch2) {
          var selection = state.selection, schema = state.schema, tr = state.tr;
          var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;
          var fencedNode = createTextNode$1(schema, fencedCodeBlockSyntax);
          tr.insert(startFromOffset, fencedNode).split(startFromOffset + fencedCodeBlockSyntax.length);
          tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), fencedNode);
          dispatch2(tr.setSelection(
            // subtract fenced syntax length and open, close tag(2)
            createTextSelection(tr, tr.mapping.map(endToOffset) - (fencedCodeBlockSyntax.length + 2))
          ));
          return true;
        };
      };
    };
    CodeBlock2.prototype.keepIndentation = function() {
      var _this = this;
      return function(_a, dispatch2) {
        var selection = _a.selection, tr = _a.tr, doc2 = _a.doc, schema = _a.schema;
        var toastMark = _this.context.toastMark;
        var _b = getRangeInfo(selection), startFromOffset = _b.startFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, from4 = _b.from, to = _b.to;
        var textContent = getTextContent(doc2, endIndex);
        if (from4 === to && textContent.trim()) {
          var matched = textContent.match(/^\s+/);
          var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);
          if (isCodeBlockNode(mdNode) && matched) {
            var spaces = matched[0];
            var slicedText = textContent.slice(to - startFromOffset);
            var node4 = createTextNode$1(schema, spaces + slicedText);
            splitAndExtendBlock(tr, endToOffset, slicedText, node4);
            dispatch2(tr);
            return true;
          }
        }
        return false;
      };
    };
    CodeBlock2.prototype.keymaps = function() {
      var codeBlockCommand = this.commands()();
      return {
        "Shift-Mod-p": codeBlockCommand,
        "Shift-Mod-P": codeBlockCommand,
        Enter: this.keepIndentation()
      };
    };
    return CodeBlock2;
  })(Mark3)
);
var reEmptyTable = /\||\s/g;
function createTableHeader(columnCount) {
  return [createTableRow(columnCount), createTableRow(columnCount, true)];
}
function createTableBody$1(columnCount, rowCount) {
  var bodyRows = [];
  for (var i = 0; i < rowCount; i += 1) {
    bodyRows.push(createTableRow(columnCount));
  }
  return bodyRows;
}
function createTableRow(columnCount, delim) {
  var row = "|";
  for (var i = 0; i < columnCount; i += 1) {
    row += delim ? " --- |" : "  |";
  }
  return row;
}
function createTargetTypes(moveNext) {
  return moveNext ? { type: "next", parentType: "tableHead", childType: "firstChild" } : { type: "prev", parentType: "tableBody", childType: "lastChild" };
}
var Table$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Table2, _super);
    function Table2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Table2.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Table2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("table") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Table2.prototype.extendTable = function() {
      var _this = this;
      return function(_a, dispatch2) {
        var selection = _a.selection, doc2 = _a.doc, tr = _a.tr, schema = _a.schema;
        if (!selection.empty) {
          return false;
        }
        var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;
        var textContent = getTextContent(doc2, endIndex);
        var mdPos = [endIndex + 1, to - endFromOffset + 1];
        var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);
        var cellNode = findClosestNode(mdNode, function(node4) {
          return isTableCellNode(node4) && (node4.parent.type === "tableDelimRow" || node4.parent.parent.type === "tableBody");
        });
        if (cellNode) {
          var isEmpty2 = !textContent.replace(reEmptyTable, "").trim();
          var parent_1 = cellNode.parent;
          var columnCount = parent_1.parent.parent.columns.length;
          var row = createTableRow(columnCount);
          if (isEmpty2) {
            tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));
          } else {
            tr.split(endToOffset).insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row)).setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - 2));
          }
          dispatch2(tr);
          return true;
        }
        return false;
      };
    };
    Table2.prototype.moveTableCell = function(moveNext) {
      var _this = this;
      return function(_a, dispatch2) {
        var selection = _a.selection, tr = _a.tr;
        var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, to = _b.to;
        var mdPos = [endIndex + 1, to - endFromOffset];
        var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);
        var cellNode = findClosestNode(mdNode, function(node4) {
          return isTableCellNode(node4);
        });
        if (cellNode) {
          var parent_2 = cellNode.parent;
          var _c = createTargetTypes(moveNext), type = _c.type, parentType = _c.parentType, childType = _c.childType;
          var chOffset = getMdEndCh(cellNode);
          if (cellNode[type]) {
            chOffset = getMdEndCh(cellNode[type]) - 1;
          } else {
            var row = !parent_2[type] && parent_2.parent.type === parentType ? parent_2.parent[type][childType] : parent_2[type];
            if (type === "next") {
              var baseOffset = row ? getMdEndCh(row[childType]) : 0;
              chOffset += baseOffset + 2;
            } else if (type === "prev") {
              chOffset = row ? -4 : 0;
            }
          }
          dispatch2(tr.setSelection(createTextSelection(tr, endFromOffset + chOffset)));
          return true;
        }
        return false;
      };
    };
    Table2.prototype.addTable = function() {
      return function(payload) {
        return function(_a, dispatch2) {
          var selection = _a.selection, tr = _a.tr, schema = _a.schema;
          var _b = payload, columnCount = _b.columnCount, rowCount = _b.rowCount;
          var endToOffset = getRangeInfo(selection).endToOffset;
          var headerRows = createTableHeader(columnCount);
          var bodyRows = createTableBody$1(columnCount, rowCount - 1);
          var rows = __spreadArray$1(__spreadArray$1([], headerRows), bodyRows);
          rows.forEach(function(row) {
            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), createTextNode$1(schema, row));
          });
          dispatch2(tr.setSelection(createTextSelection(tr, endToOffset + 4)));
          return true;
        };
      };
    };
    Table2.prototype.commands = function() {
      return { addTable: this.addTable() };
    };
    Table2.prototype.keymaps = function() {
      return {
        Enter: this.extendTable(),
        Tab: this.moveTableCell(true),
        "Shift-Tab": this.moveTableCell(false)
      };
    };
    return Table2;
  })(Mark3)
);
var thematicBreakSyntax = "***";
var ThematicBreak$1 = (
  /** @class */
  (function(_super) {
    __extends$1(ThematicBreak2, _super);
    function ThematicBreak2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ThematicBreak2.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ThematicBreak2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("thematic-break") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    ThematicBreak2.prototype.hr = function() {
      return function() {
        return function(state, dispatch2) {
          var selection = state.selection, schema = state.schema, tr = state.tr;
          var _a = getRangeInfo(selection), from4 = _a.from, to = _a.to, endToOffset = _a.endToOffset;
          var node4 = createTextNode$1(schema, thematicBreakSyntax);
          tr.split(from4).replaceWith(tr.mapping.map(from4), tr.mapping.map(to), node4).split(tr.mapping.map(to)).setSelection(createTextSelection(tr, tr.mapping.map(endToOffset)));
          dispatch2(tr);
          return true;
        };
      };
    };
    ThematicBreak2.prototype.commands = function() {
      return { hr: this.hr() };
    };
    ThematicBreak2.prototype.keymaps = function() {
      var lineCommand = this.hr()();
      return { "Mod-l": lineCommand, "Mod-L": lineCommand };
    };
    return ThematicBreak2;
  })(Mark3)
);
function cannotBeListNode(_a, line) {
  var type = _a.type, sourcepos = _a.sourcepos;
  var startLine = sourcepos[0][0];
  return line <= startLine && (type === "codeBlock" || type === "heading" || type.match("table"));
}
var ListItem$1 = (
  /** @class */
  (function(_super) {
    __extends$1(ListItem2, _super);
    function ListItem2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ListItem2.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ListItem2.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            odd: { default: false },
            even: { default: false },
            listStyle: { default: false }
          },
          toDOM: function(_a) {
            var attrs = _a.attrs;
            var odd = attrs.odd, even = attrs.even, listStyle = attrs.listStyle;
            var classNames = "list-item";
            if (listStyle) {
              classNames += "|list-item-style";
            }
            if (odd) {
              classNames += "|list-item-odd";
            }
            if (even) {
              classNames += "|list-item-even";
            }
            return ["span", { class: clsWithMdPrefix.apply(void 0, classNames.split("|")) }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    ListItem2.prototype.extendList = function() {
      var _this = this;
      return function(_a, dispatch2) {
        var selection = _a.selection, doc2 = _a.doc, schema = _a.schema, tr = _a.tr;
        var toastMark = _this.context.toastMark;
        var _b = getRangeInfo(selection), to = _b.to, startFromOffset = _b.startFromOffset, endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, endToOffset = _b.endToOffset;
        var textContent = getTextContent(doc2, endIndex);
        var isList2 = reList.test(textContent);
        if (!isList2 || selection.from === startFromOffset || !selection.empty) {
          return false;
        }
        var isEmpty2 = !textContent.replace(reCanBeTaskList, "").trim();
        if (isEmpty2) {
          tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));
        } else {
          var commandType = getListType(textContent);
          var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);
          var slicedText = textContent.slice(to - endFromOffset);
          var context = { toastMark, mdNode, doc: doc2, line: endIndex + 1 };
          var _c = extendList[commandType](context), listSyntax = _c.listSyntax, changedResults = _c.changedResults;
          if (changedResults === null || changedResults === void 0 ? void 0 : changedResults.length) {
            tr.split(to);
            changedResults.unshift({ text: listSyntax + slicedText, line: endIndex + 1 });
            _this.changeToListPerLine(tr, changedResults, {
              from: to,
              // don't subtract 1 because the line has increased through 'split' command.
              startLine: changedResults[0].line,
              endLine: last$1(changedResults).line
            });
            var pos = tr.mapping.map(endToOffset) - slicedText.length;
            tr.setSelection(createTextSelection(tr, pos));
          } else {
            var node4 = createTextNode$1(schema, listSyntax + slicedText);
            splitAndExtendBlock(tr, endToOffset, slicedText, node4);
          }
        }
        dispatch2(tr);
        return true;
      };
    };
    ListItem2.prototype.toList = function(commandType) {
      var _this = this;
      return function() {
        return function(_a, dispatch2) {
          var doc2 = _a.doc, tr = _a.tr, selection = _a.selection;
          var toastMark = _this.context.toastMark;
          var rangeInfo = getRangeInfo(selection);
          var startLine = rangeInfo.startIndex + 1;
          var endLine = rangeInfo.endIndex + 1;
          var endToOffset = rangeInfo.endToOffset;
          var skipLines = [];
          for (var line = startLine; line <= endLine; line += 1) {
            var mdNode = toastMark.findFirstNodeAtLine(line);
            if (mdNode && cannotBeListNode(mdNode, line)) {
              break;
            }
            if (skipLines.indexOf(line) !== -1) {
              continue;
            }
            var context = { toastMark, mdNode, doc: doc2, line, startLine };
            var changedResults = (isListNode$1(mdNode) ? otherListToList[commandType](context) : otherNodeToList[commandType](context)).changedResults;
            var endOffset = _this.changeToListPerLine(tr, changedResults, {
              from: getNodeContentOffsetRange(doc2, changedResults[0].line - 1).startOffset,
              startLine: changedResults[0].line,
              endLine: last$1(changedResults).line,
              indexDiff: 1
            });
            endToOffset = Math.max(endOffset, endToOffset);
            if (changedResults) {
              skipLines = skipLines.concat(changedResults.map(function(info) {
                return info.line;
              }));
            }
          }
          dispatch2(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));
          return true;
        };
      };
    };
    ListItem2.prototype.changeToListPerLine = function(tr, changedResults, _a) {
      var from4 = _a.from, startLine = _a.startLine, endLine = _a.endLine, _b = _a.indexDiff, indexDiff = _b === void 0 ? 0 : _b;
      var maxEndOffset = 0;
      var _loop_1 = function(i2) {
        var _c = tr.doc.child(i2), nodeSize2 = _c.nodeSize, content2 = _c.content;
        var mappedFrom = tr.mapping.map(from4);
        var mappedTo = mappedFrom + content2.size;
        var changedResult = changedResults.filter(function(result2) {
          return result2.line - indexDiff === i2;
        })[0];
        if (changedResult) {
          tr.replaceWith(mappedFrom, mappedTo, createTextNode$1(this_1.context.schema, changedResult.text));
          maxEndOffset = Math.max(maxEndOffset, from4 + content2.size);
        }
        from4 += nodeSize2;
      };
      var this_1 = this;
      for (var i = startLine - indexDiff; i <= endLine - indexDiff; i += 1) {
        _loop_1(i);
      }
      return maxEndOffset;
    };
    ListItem2.prototype.toggleTask = function() {
      var _this = this;
      return function(_a, dispatch2) {
        var selection = _a.selection, tr = _a.tr, doc2 = _a.doc, schema = _a.schema;
        var toastMark = _this.context.toastMark;
        var _b = getRangeInfo(selection), startIndex = _b.startIndex, endIndex = _b.endIndex;
        var newTr = null;
        for (var i = startIndex; i <= endIndex; i += 1) {
          var mdNode = toastMark.findFirstNodeAtLine(i + 1);
          if (isListNode$1(mdNode) && mdNode.listData.task) {
            var _c = mdNode.listData, checked = _c.checked, padding = _c.padding;
            var stateChar = checked ? " " : "x";
            var mdPos = mdNode.sourcepos[0];
            var startOffset = getNodeContentOffsetRange(doc2, mdPos[0] - 1).startOffset;
            startOffset += mdPos[1] + padding;
            newTr = tr.replaceWith(startOffset, startOffset + 1, schema.text(stateChar));
          }
        }
        if (newTr) {
          dispatch2(newTr);
          return true;
        }
        return false;
      };
    };
    ListItem2.prototype.commands = function() {
      return {
        bulletList: this.toList("bullet"),
        orderedList: this.toList("ordered"),
        taskList: this.toList("task")
      };
    };
    ListItem2.prototype.keymaps = function() {
      var bulletCommand = this.toList("bullet")();
      var orderedCommand = this.toList("ordered")();
      var taskCommand = this.toList("task")();
      var togleTaskCommand = this.toggleTask();
      return {
        "Mod-u": bulletCommand,
        "Mod-U": bulletCommand,
        "Mod-o": orderedCommand,
        "Mod-O": orderedCommand,
        "alt-t": taskCommand,
        "alt-T": taskCommand,
        "Shift-Ctrl-x": togleTaskCommand,
        "Shift-Ctrl-X": togleTaskCommand,
        Enter: this.extendList()
      };
    };
    return ListItem2;
  })(Mark3)
);
function toggleMark2(condition, syntax) {
  return function() {
    return function(_a, dispatch2) {
      var tr = _a.tr, selection = _a.selection;
      var conditionFn = !isFunction_1(condition) ? function(text3) {
        return condition.test(text3);
      } : condition;
      var syntaxLen = syntax.length;
      var doc2 = tr.doc;
      var _b = resolveSelectionPos(selection), from4 = _b[0], to = _b[1];
      var prevPos = Math.max(from4 - syntaxLen, 1);
      var nextPos = Math.min(to + syntaxLen, doc2.content.size - 1);
      var slice4 = selection.content();
      var textContent = slice4.content.textBetween(0, slice4.content.size, "\n");
      var prevText = doc2.textBetween(prevPos, from4, "\n");
      var nextText = doc2.textBetween(to, nextPos, "\n");
      textContent = "" + prevText + textContent + nextText;
      if (prevText && nextText && conditionFn(textContent)) {
        tr.delete(nextPos - syntaxLen, nextPos).delete(prevPos, prevPos + syntaxLen);
      } else {
        tr.insertText(syntax, to).insertText(syntax, from4);
        var newSelection = selection.empty ? createTextSelection(tr, from4 + syntaxLen) : createTextSelection(tr, from4 + syntaxLen, to + syntaxLen);
        tr.setSelection(newSelection);
      }
      dispatch2(tr);
      return true;
    };
  };
}
var reStrong = /^(\*{2}|_{2}).*([\s\S]*)\1$/m;
var strongSyntax = "**";
var Strong$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Strong2, _super);
    function Strong2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Strong2.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Strong2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("strong") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Strong2.prototype.bold = function() {
      return toggleMark2(reStrong, strongSyntax);
    };
    Strong2.prototype.commands = function() {
      return { bold: this.bold() };
    };
    Strong2.prototype.keymaps = function() {
      var boldCommand = this.bold()();
      return { "Mod-b": boldCommand, "Mod-B": boldCommand };
    };
    return Strong2;
  })(Mark3)
);
var reStrike = /^(~{2}).*([\s\S]*)\1$/m;
var strikeSyntax = "~~";
var Strike$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Strike2, _super);
    function Strike2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Strike2.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Strike2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("strike") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Strike2.prototype.commands = function() {
      return toggleMark2(reStrike, strikeSyntax);
    };
    Strike2.prototype.keymaps = function() {
      var strikeCommand = this.commands()();
      return { "Mod-s": strikeCommand, "Mod-S": strikeCommand };
    };
    return Strike2;
  })(Mark3)
);
var reEmph = /^(\*|_).*([\s\S]*)\1$/m;
var emphSyntax = "*";
var Emph$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Emph2, _super);
    function Emph2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Emph2.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Emph2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("emph") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Emph2.prototype.italic = function() {
      return toggleMark2(reEmph, emphSyntax);
    };
    Emph2.prototype.commands = function() {
      return { italic: this.italic() };
    };
    Emph2.prototype.keymaps = function() {
      var italicCommand = this.italic()();
      return { "Mod-i": italicCommand, "Mod-I": italicCommand };
    };
    return Emph2;
  })(Mark3)
);
var reCode = /^(`).*([\s\S]*)\1$/m;
var codeSyntax = "`";
var Code$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Code2, _super);
    function Code2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Code2.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Code2.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            start: { default: false },
            end: { default: false },
            marked: { default: false }
          },
          toDOM: function(mark3) {
            var _a = mark3.attrs, start3 = _a.start, end2 = _a.end, marked = _a.marked;
            var classNames = "code";
            if (start3) {
              classNames += "|delimiter|start";
            }
            if (end2) {
              classNames += "|delimiter|end";
            }
            if (marked) {
              classNames += "|marked-text";
            }
            return ["span", { class: clsWithMdPrefix.apply(void 0, classNames.split("|")) }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Code2.prototype.commands = function() {
      return toggleMark2(reCode, codeSyntax);
    };
    Code2.prototype.keymaps = function() {
      var codeCommand = this.commands()();
      return { "Shift-Mod-c": codeCommand, "Shift-Mod-C": codeCommand };
    };
    return Code2;
  })(Mark3)
);
var Link$1 = (
  /** @class */
  (function(_super) {
    __extends$1(Link2, _super);
    function Link2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Link2.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Link2.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            url: { default: false },
            desc: { default: false }
          },
          toDOM: function(_a) {
            var attrs = _a.attrs;
            var url = attrs.url, desc = attrs.desc;
            var classNames = "link";
            if (url) {
              classNames += "|link-url|marked-text";
            }
            if (desc) {
              classNames += "|link-desc|marked-text";
            }
            return ["span", { class: clsWithMdPrefix.apply(void 0, classNames.split("|")) }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Link2.prototype.addLinkOrImage = function(commandType) {
      return function(payload) {
        return function(_a, dispatch2) {
          var selection = _a.selection, tr = _a.tr, schema = _a.schema;
          var _b = resolveSelectionPos(selection), from4 = _b[0], to = _b[1];
          var _c = payload, linkText = _c.linkText, altText = _c.altText, linkUrl = _c.linkUrl, imageUrl = _c.imageUrl;
          var text3 = linkText;
          var url = linkUrl;
          var syntax = "";
          if (commandType === "image") {
            text3 = altText;
            url = imageUrl;
            syntax = "!";
          }
          text3 = escapeTextForLink(text3);
          syntax += "[" + text3 + "](" + url + ")";
          dispatch2(tr.replaceWith(from4, to, createTextNode$1(schema, syntax)));
          return true;
        };
      };
    };
    Link2.prototype.commands = function() {
      return {
        addImage: this.addLinkOrImage("image"),
        addLink: this.addLinkOrImage("link")
      };
    };
    return Link2;
  })(Mark3)
);
var TaskDelimiter = (
  /** @class */
  (function(_super) {
    __extends$1(TaskDelimiter2, _super);
    function TaskDelimiter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TaskDelimiter2.prototype, "name", {
      get: function() {
        return "taskDelimiter";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TaskDelimiter2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("delimiter", "list-item") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return TaskDelimiter2;
  })(Mark3)
);
var Delimiter = (
  /** @class */
  (function(_super) {
    __extends$1(Delimiter2, _super);
    function Delimiter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Delimiter2.prototype, "name", {
      get: function() {
        return "delimiter";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Delimiter2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("delimiter") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return Delimiter2;
  })(Mark3)
);
var Meta = (
  /** @class */
  (function(_super) {
    __extends$1(Meta2, _super);
    function Meta2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Meta2.prototype, "name", {
      get: function() {
        return "meta";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Meta2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("meta") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return Meta2;
  })(Mark3)
);
var MarkedText = (
  /** @class */
  (function(_super) {
    __extends$1(MarkedText2, _super);
    function MarkedText2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MarkedText2.prototype, "name", {
      get: function() {
        return "markedText";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MarkedText2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("marked-text") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return MarkedText2;
  })(Mark3)
);
var TableCell = (
  /** @class */
  (function(_super) {
    __extends$1(TableCell2, _super);
    function TableCell2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableCell2.prototype, "name", {
      get: function() {
        return "tableCell";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TableCell2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("table-cell") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return TableCell2;
  })(Mark3)
);
var Html = (
  /** @class */
  (function(_super) {
    __extends$1(Html2, _super);
    function Html2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Html2.prototype, "name", {
      get: function() {
        return "html";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Html2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("html") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return Html2;
  })(Mark3)
);
var customBlockSyntax = "$$";
var CustomBlock$1 = (
  /** @class */
  (function(_super) {
    __extends$1(CustomBlock2, _super);
    function CustomBlock2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CustomBlock2.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CustomBlock2.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: clsWithMdPrefix("custom-block") }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    CustomBlock2.prototype.commands = function() {
      return function(payload) {
        return function(state, dispatch2) {
          var selection = state.selection, schema = state.schema, tr = state.tr;
          var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;
          if (!(payload === null || payload === void 0 ? void 0 : payload.info)) {
            return false;
          }
          var customBlock2 = "" + customBlockSyntax + payload.info;
          var startNode = createTextNode$1(schema, customBlock2);
          var endNode = createTextNode$1(schema, customBlockSyntax);
          tr.insert(startFromOffset, startNode).split(startFromOffset + customBlock2.length);
          tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), endNode);
          dispatch2(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - (customBlockSyntax.length + 2))));
          return true;
        };
      };
    };
    return CustomBlock2;
  })(Mark3)
);
var reTaskMarkerKey = /x|backspace/i;
var reTaskMarker = /^\[(\s*)(x?)(\s*)\](?:\s+)/i;
function smartTask(_a) {
  var schema = _a.schema, toastMark = _a.toastMark;
  return new Plugin({
    props: {
      handleDOMEvents: {
        keyup: function(view, ev) {
          var _a2;
          var _b = view.state, doc2 = _b.doc, tr = _b.tr, selection = _b.selection;
          if (selection.empty && reTaskMarkerKey.test(ev.key)) {
            var _c = getRangeInfo(selection), startIndex = _c.startIndex, startFromOffset = _c.startFromOffset, from4 = _c.from;
            var mdPos = [startIndex + 1, from4 - startFromOffset + 1];
            var mdNode = toastMark.findNodeAtPosition(mdPos);
            var paraNode = findClosestNode(mdNode, function(node4) {
              var _a3;
              return node4.type === "paragraph" && ((_a3 = node4.parent) === null || _a3 === void 0 ? void 0 : _a3.type) === "item";
            });
            if ((_a2 = paraNode === null || paraNode === void 0 ? void 0 : paraNode.firstChild) === null || _a2 === void 0 ? void 0 : _a2.literal) {
              var firstChild = paraNode.firstChild;
              var matched = firstChild.literal.match(reTaskMarker);
              if (matched) {
                var startMdPos = firstChild.sourcepos[0];
                var startSpaces = matched[1], stateChar = matched[2], lastSpaces = matched[3];
                var spaces = startSpaces.length + lastSpaces.length;
                var startOffset = getNodeContentOffsetRange(doc2, startMdPos[0] - 1).startOffset;
                var startPos = startMdPos[1] + startOffset;
                if (stateChar) {
                  var addedPos = spaces ? spaces + 1 : 0;
                  tr.replaceWith(startPos, addedPos + startPos, schema.text(stateChar));
                  view.dispatch(tr);
                } else if (!spaces) {
                  tr.insertText(" ", startPos);
                  view.dispatch(tr);
                }
              }
            }
          }
          return false;
        }
      }
    }
  });
}
var EVENT_TYPE = "cut";
var reLineEnding$2 = /\r\n|\n|\r/;
var MdEditor = (
  /** @class */
  (function(_super) {
    __extends$1(MdEditor2, _super);
    function MdEditor2(eventEmitter, options) {
      var _this = _super.call(this, eventEmitter) || this;
      var toastMark = options.toastMark, _a = options.useCommandShortcut, useCommandShortcut = _a === void 0 ? true : _a, _b = options.mdPlugins, mdPlugins = _b === void 0 ? [] : _b;
      _this.editorType = "markdown";
      _this.el.classList.add("md-mode");
      _this.toastMark = toastMark;
      _this.extraPlugins = mdPlugins;
      _this.specs = _this.createSpecs();
      _this.schema = _this.createSchema();
      _this.context = _this.createContext();
      _this.keymaps = _this.createKeymaps(useCommandShortcut);
      _this.view = _this.createView();
      _this.commands = _this.createCommands();
      _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));
      _this.createClipboard();
      _this.eventEmitter.listen("changePreviewTabWrite", function(isMarkdownTabMounted) {
        return _this.toggleActive(true, isMarkdownTabMounted);
      });
      _this.eventEmitter.listen("changePreviewTabPreview", function() {
        return _this.toggleActive(false);
      });
      _this.initEvent();
      return _this;
    }
    MdEditor2.prototype.toggleActive = function(active, isMarkdownTabMounted) {
      toggleClass(this.el, "active", active);
      if (active) {
        if (!isMarkdownTabMounted) {
          this.focus();
        }
      } else {
        this.blur();
      }
    };
    MdEditor2.prototype.createClipboard = function() {
      var _this = this;
      this.clipboard = document.createElement("textarea");
      this.clipboard.className = cls("pseudo-clipboard");
      this.clipboard.addEventListener("paste", function(ev) {
        var clipboardData = ev.clipboardData || window.clipboardData;
        var items = clipboardData && clipboardData.items;
        if (items) {
          var containRtfItem = toArray_1(items).some(function(item2) {
            return item2.kind === "string" && item2.type === "text/rtf";
          });
          if (!containRtfItem) {
            var imageBlob = pasteImageOnly(items);
            if (imageBlob) {
              ev.preventDefault();
              emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);
            }
          }
        }
      });
      this.clipboard.addEventListener("input", function(ev) {
        var text3 = ev.target.value;
        _this.replaceSelection(text3);
        ev.preventDefault();
        ev.target.value = "";
      });
      this.el.insertBefore(this.clipboard, this.view.dom);
    };
    MdEditor2.prototype.createContext = function() {
      return {
        toastMark: this.toastMark,
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    };
    MdEditor2.prototype.createSpecs = function() {
      return new SpecManager([
        new Doc$1(),
        new Paragraph$1(),
        new Widget(),
        new Text$1(),
        new Heading$1(),
        new BlockQuote$1(),
        new CodeBlock$1(),
        new CustomBlock$1(),
        new Table$1(),
        new TableCell(),
        new ThematicBreak$1(),
        new ListItem$1(),
        new Strong$1(),
        new Strike$1(),
        new Emph$1(),
        new Code$1(),
        new Link$1(),
        new Delimiter(),
        new TaskDelimiter(),
        new MarkedText(),
        new Meta(),
        new Html()
      ]);
    };
    MdEditor2.prototype.createPlugins = function() {
      return __spreadArray$1([
        syntaxHighlight(this.context),
        previewHighlight(this.context),
        smartTask(this.context)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    };
    MdEditor2.prototype.createView = function() {
      var _this = this;
      return new EditorView(this.el, {
        state: this.createState(),
        dispatchTransaction: function(tr) {
          _this.updateMarkdown(tr);
          var state = _this.view.state.applyTransaction(tr).state;
          _this.view.updateState(state);
          _this.emitChangeEvent(tr);
        },
        handleKeyDown: function(_, ev) {
          if ((ev.metaKey || ev.ctrlKey) && ev.key.toUpperCase() === "V") {
            _this.clipboard.focus();
          }
          _this.eventEmitter.emit("keydown", _this.editorType, ev);
          return false;
        },
        handleDOMEvents: {
          copy: function(_, ev) {
            return _this.captureCopy(ev);
          },
          cut: function(_, ev) {
            return _this.captureCopy(ev, EVENT_TYPE);
          },
          scroll: function() {
            _this.eventEmitter.emit("scroll", "editor");
            return true;
          },
          keyup: function(_, ev) {
            _this.eventEmitter.emit("keyup", _this.editorType, ev);
            return false;
          }
        },
        nodeViews: {
          widget: widgetNodeView
        }
      });
    };
    MdEditor2.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    };
    MdEditor2.prototype.captureCopy = function(ev, type) {
      ev.preventDefault();
      var _a = this.view.state, selection = _a.selection, tr = _a.tr;
      if (selection.empty) {
        return true;
      }
      var text3 = this.getChanged(selection.content());
      if (ev.clipboardData) {
        ev.clipboardData.setData("text/plain", text3);
      } else {
        window.clipboardData.setData("Text", text3);
      }
      if (type === EVENT_TYPE) {
        this.view.dispatch(tr.deleteSelection().scrollIntoView().setMeta("uiEvent", EVENT_TYPE));
      }
      return true;
    };
    MdEditor2.prototype.updateMarkdown = function(tr) {
      var _this = this;
      if (tr.docChanged) {
        tr.steps.forEach(function(step2, index3) {
          if (step2.slice && !(step2 instanceof ReplaceAroundStep)) {
            var doc2 = tr.docs[index3];
            var _a = [step2.from, step2.to], from4 = _a[0], to = _a[1];
            var _b = getEditorToMdPos(doc2, from4, to), startPos = _b[0], endPos = _b[1];
            var changed = _this.getChanged(step2.slice);
            if (startPos[0] === endPos[0] && startPos[1] === endPos[1] && changed === "") {
              changed = "\n";
            }
            var editResult = _this.toastMark.editMarkdown(startPos, endPos, changed);
            _this.eventEmitter.emit("updatePreview", editResult);
            tr.setMeta("editResult", editResult).scrollIntoView();
          }
        });
      }
    };
    MdEditor2.prototype.getChanged = function(slice4) {
      var changed = "";
      var from4 = 0;
      var to = slice4.content.size;
      slice4.content.nodesBetween(from4, to, function(node4, pos) {
        if (node4.isText) {
          changed += node4.text.slice(Math.max(from4, pos) - pos, to - pos);
        } else if (node4.isBlock && pos > 0) {
          changed += "\n";
        }
      });
      return changed;
    };
    MdEditor2.prototype.setSelection = function(start3, end2) {
      if (end2 === void 0) {
        end2 = start3;
      }
      var tr = this.view.state.tr;
      var _a = getMdToEditorPos(tr.doc, start3, end2), from4 = _a[0], to = _a[1];
      this.view.dispatch(tr.setSelection(createTextSelection(tr, from4, to)).scrollIntoView());
    };
    MdEditor2.prototype.replaceSelection = function(text3, start3, end2) {
      var newTr;
      var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc2 = _a.doc;
      var lineTexts = text3.split(reLineEnding$2);
      var nodes = lineTexts.map(function(lineText) {
        return createParagraph(schema, createNodesWithWidget(lineText, schema));
      });
      var slice4 = new Slice(Fragment.from(nodes), 1, 1);
      this.focus();
      if (start3 && end2) {
        var _b = getMdToEditorPos(doc2, start3, end2), from4 = _b[0], to = _b[1];
        newTr = tr.replaceRange(from4, to, slice4);
      } else {
        newTr = tr.replaceSelection(slice4);
      }
      this.view.dispatch(newTr.scrollIntoView());
    };
    MdEditor2.prototype.deleteSelection = function(start3, end2) {
      var newTr;
      var _a = this.view.state, tr = _a.tr, doc2 = _a.doc;
      if (start3 && end2) {
        var _b = getMdToEditorPos(doc2, start3, end2), from4 = _b[0], to = _b[1];
        newTr = tr.deleteRange(from4, to);
      } else {
        newTr = tr.deleteSelection();
      }
      this.view.dispatch(newTr.scrollIntoView());
    };
    MdEditor2.prototype.getSelectedText = function(start3, end2) {
      var _a = this.view.state, doc2 = _a.doc, selection = _a.selection;
      var from4 = selection.from, to = selection.to;
      if (start3 && end2) {
        var pos = getMdToEditorPos(doc2, start3, end2);
        from4 = pos[0];
        to = pos[1];
      }
      return doc2.textBetween(from4, to, "\n");
    };
    MdEditor2.prototype.getSelection = function() {
      var _a = this.view.state.selection, from4 = _a.from, to = _a.to;
      return getEditorToMdPos(this.view.state.tr.doc, from4, to);
    };
    MdEditor2.prototype.setMarkdown = function(markdown, cursorToEnd) {
      if (cursorToEnd === void 0) {
        cursorToEnd = true;
      }
      var lineTexts = markdown.split(reLineEnding$2);
      var _a = this.view.state, tr = _a.tr, doc2 = _a.doc, schema = _a.schema;
      var nodes = lineTexts.map(function(lineText) {
        return createParagraph(schema, createNodesWithWidget(lineText, schema));
      });
      this.view.dispatch(tr.replaceWith(0, doc2.content.size, nodes));
      if (cursorToEnd) {
        this.moveCursorToEnd(true);
      }
    };
    MdEditor2.prototype.addWidget = function(node4, style, mdPos) {
      var _a = this.view.state, tr = _a.tr, doc2 = _a.doc, selection = _a.selection;
      var pos = mdPos ? getMdToEditorPos(doc2, mdPos, mdPos)[0] : selection.to;
      this.view.dispatch(tr.setMeta("widget", { pos, node: node4, style }));
    };
    MdEditor2.prototype.replaceWithWidget = function(start3, end2, text3) {
      var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc2 = _a.doc;
      var pos = getMdToEditorPos(doc2, start3, end2);
      var nodes = createNodesWithWidget(text3, schema);
      this.view.dispatch(tr.replaceWith(pos[0], pos[1], nodes));
    };
    MdEditor2.prototype.getRangeInfoOfNode = function(pos) {
      var _a = this.view.state, doc2 = _a.doc, selection = _a.selection;
      var mdPos = pos || getEditorToMdPos(doc2, selection.from)[0];
      var mdNode = this.toastMark.findNodeAtPosition(mdPos);
      if (mdNode.type === "text" && mdNode.parent.type !== "paragraph") {
        mdNode = mdNode.parent;
      }
      mdNode.sourcepos[1][1] += 1;
      return { range: mdNode.sourcepos, type: mdNode.type };
    };
    MdEditor2.prototype.getMarkdown = function() {
      return this.toastMark.getLineTexts().map(function(lineText) {
        return unwrapWidgetSyntax(lineText);
      }).join("\n");
    };
    MdEditor2.prototype.getToastMark = function() {
      return this.toastMark;
    };
    return MdEditor2;
  })(EditorBase)
);
var EVENT_KEY = "_feEventKey";
function safeEvent$2(element, type) {
  var events = element[EVENT_KEY];
  var handlers2;
  if (!events) {
    events = element[EVENT_KEY] = {};
  }
  handlers2 = events[type];
  if (!handlers2) {
    handlers2 = events[type] = [];
  }
  return handlers2;
}
var _safeEvent = safeEvent$2;
var isString$1 = isString_1;
var forEach$1 = forEach_1;
var safeEvent$1 = _safeEvent;
function off(element, types, handler) {
  if (isString$1(types)) {
    forEach$1(types.split(/\s+/g), function(type) {
      unbindEvent(element, type, handler);
    });
    return;
  }
  forEach$1(types, function(func, type) {
    unbindEvent(element, type, func);
  });
}
function unbindEvent(element, type, handler) {
  var events = safeEvent$1(element, type);
  var index3;
  if (!handler) {
    forEach$1(events, function(item2) {
      removeHandler(element, type, item2.wrappedHandler);
    });
    events.splice(0, events.length);
  } else {
    forEach$1(events, function(item2, idx) {
      if (handler === item2.handler) {
        removeHandler(element, type, item2.wrappedHandler);
        index3 = idx;
        return false;
      }
      return true;
    });
    events.splice(index3, 1);
  }
}
function removeHandler(element, type, handler) {
  if ("removeEventListener" in element) {
    element.removeEventListener(type, handler);
  } else if ("detachEvent" in element) {
    element.detachEvent("on" + type, handler);
  }
}
var off_1 = off;
var isString2 = isString_1;
var forEach5 = forEach_1;
var safeEvent = _safeEvent;
function on(element, types, handler, context) {
  if (isString2(types)) {
    forEach5(types.split(/\s+/g), function(type) {
      bindEvent(element, type, handler, context);
    });
    return;
  }
  forEach5(types, function(func, type) {
    bindEvent(element, type, func, handler);
  });
}
function bindEvent(element, type, handler, context) {
  function eventHandler(e) {
    handler.call(context || element, e || window.event);
  }
  if ("addEventListener" in element) {
    element.addEventListener(type, eventHandler);
  } else if ("attachEvent" in element) {
    element.attachEvent("on" + type, eventHandler);
  }
  memorizeHandler(element, type, handler, eventHandler);
}
function memorizeHandler(element, type, handler, wrappedHandler) {
  var events = safeEvent(element, type);
  var existInEvents = false;
  forEach5(events, function(obj) {
    if (obj.handler === handler) {
      existInEvents = true;
      return false;
    }
    return true;
  });
  if (!existInEvents) {
    events.push({
      handler,
      wrappedHandler
    });
  }
}
var on_1 = on;
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign2 = function() {
  __assign2 = Object.assign || function __assign4(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function __spreadArray(to, from4, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from4.length, ar; i < l; i++) {
    if (ar || !(i in from4)) {
      if (!ar) ar = Array.prototype.slice.call(from4, 0, i);
      ar[i] = from4[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from4));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var encodeCache = {};
function getEncodeCache(exclude) {
  var i, ch, cache2 = encodeCache[exclude];
  if (cache2) {
    return cache2;
  }
  cache2 = encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache2.push(ch);
    } else {
      cache2.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i = 0; i < exclude.length; i++) {
    cache2[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache2;
}
function encode$1(string, exclude, keepEscaped) {
  var i, l, code2, nextCode, cache2, result2 = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  cache2 = getEncodeCache(exclude);
  for (i = 0, l = string.length; i < l; i++) {
    code2 = string.charCodeAt(i);
    if (keepEscaped && code2 === 37 && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result2 += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code2 < 128) {
      result2 += cache2[code2];
      continue;
    }
    if (code2 >= 55296 && code2 <= 57343) {
      if (code2 >= 55296 && code2 <= 56319 && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result2 += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result2 += "%EF%BF%BD";
      continue;
    }
    result2 += encodeURIComponent(string[i]);
  }
  return result2;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1;
var lib = {};
var decode = {};
var Aacute$1 = "Á";
var aacute$1 = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc$1 = "Â";
var acirc$1 = "â";
var acute$1 = "´";
var Acy = "А";
var acy = "а";
var AElig$1 = "Æ";
var aelig$1 = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave$1 = "À";
var agrave$1 = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha = "Α";
var alpha = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var amp$2 = "&";
var AMP$1 = "&";
var andand = "⩕";
var And = "⩓";
var and = "∧";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angmsd = "∡";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var apacir = "⩯";
var ap = "≈";
var apE = "⩰";
var ape = "≊";
var apid = "≋";
var apos$1 = "'";
var ApplyFunction = "⁡";
var approx = "≈";
var approxeq = "≊";
var Aring$1 = "Å";
var aring$1 = "å";
var Ascr = "𝒜";
var ascr = "𝒶";
var Assign = "≔";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde$1 = "Ã";
var atilde$1 = "ã";
var Auml$1 = "Ä";
var auml$1 = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash = "∖";
var Barv = "⫧";
var barvee = "⊽";
var barwed = "⌅";
var Barwed = "⌆";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var Because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var Bernoullis = "ℬ";
var Beta = "Β";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxbox = "⧉";
var boxdl = "┐";
var boxdL = "╕";
var boxDl = "╖";
var boxDL = "╗";
var boxdr = "┌";
var boxdR = "╒";
var boxDr = "╓";
var boxDR = "╔";
var boxh = "─";
var boxH = "═";
var boxhd = "┬";
var boxHd = "╤";
var boxhD = "╥";
var boxHD = "╦";
var boxhu = "┴";
var boxHu = "╧";
var boxhU = "╨";
var boxHU = "╩";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxul = "┘";
var boxuL = "╛";
var boxUl = "╜";
var boxUL = "╝";
var boxur = "└";
var boxuR = "╘";
var boxUr = "╙";
var boxUR = "╚";
var boxv = "│";
var boxV = "║";
var boxvh = "┼";
var boxvH = "╪";
var boxVh = "╫";
var boxVH = "╬";
var boxvl = "┤";
var boxvL = "╡";
var boxVl = "╢";
var boxVL = "╣";
var boxvr = "├";
var boxvR = "╞";
var boxVr = "╟";
var boxVR = "╠";
var bprime = "‵";
var breve = "˘";
var Breve = "˘";
var brvbar$1 = "¦";
var bscr = "𝒷";
var Bscr = "ℬ";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsolb = "⧅";
var bsol = "\\";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute = "ć";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var cap = "∩";
var Cap = "⋒";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil$1 = "Ç";
var ccedil$1 = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil$1 = "¸";
var Cedilla = "¸";
var cemptyv = "⦲";
var cent$1 = "¢";
var centerdot = "·";
var CenterDot = "·";
var cfr = "𝔠";
var Cfr = "ℭ";
var CHcy = "Ч";
var chcy = "ч";
var check2 = "✓";
var checkmark = "✓";
var Chi = "Χ";
var chi = "χ";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cir = "○";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var Colon = "∷";
var Colone = "⩴";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var Congruent = "≡";
var conint = "∮";
var Conint = "∯";
var ContourIntegral = "∮";
var copf = "𝕔";
var Copf = "ℂ";
var coprod = "∐";
var Coproduct = "∐";
var copy$1 = "©";
var COPY$1 = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var cross = "✗";
var Cross = "⨯";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cupbrcap = "⩈";
var cupcap = "⩆";
var CupCap = "≍";
var cup = "∪";
var Cup = "⋓";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren$1 = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dagger = "†";
var Dagger = "‡";
var daleth = "ℸ";
var darr = "↓";
var Darr = "↡";
var dArr = "⇓";
var dash = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var ddagger = "‡";
var ddarr = "⇊";
var DD = "ⅅ";
var dd = "ⅆ";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg$1 = "°";
var Del = "∇";
var Delta = "Δ";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam = "⋄";
var diamond = "⋄";
var Diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var DifferentialD = "ⅆ";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divide$1 = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var Dopf = "𝔻";
var dopf = "𝕕";
var Dot = "¨";
var dot = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrowBar = "⤓";
var downarrow = "↓";
var DownArrow = "↓";
var Downarrow = "⇓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVectorBar = "⥖";
var DownLeftVector = "↽";
var DownRightTeeVector = "⥟";
var DownRightVectorBar = "⥗";
var DownRightVector = "⇁";
var DownTeeArrow = "↧";
var DownTee = "⊤";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute$1 = "É";
var eacute$1 = "é";
var easter = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var Ecirc$1 = "Ê";
var ecirc$1 = "ê";
var ecir = "≖";
var ecolon = "≕";
var Ecy = "Э";
var ecy = "э";
var eDDot = "⩷";
var Edot = "Ė";
var edot = "ė";
var eDot = "≑";
var ee = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr = "𝔢";
var eg = "⪚";
var Egrave$1 = "È";
var egrave$1 = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var Element$1 = "∈";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty2 = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var ENG = "Ŋ";
var eng = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var Epsilon = "Ε";
var epsilon = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal = "⩵";
var equals = "=";
var EqualTilde = "≂";
var equest = "≟";
var Equilibrium = "⇌";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var escr = "ℯ";
var Escr = "ℰ";
var esdot = "≐";
var Esim = "⩳";
var esim = "≂";
var Eta = "Η";
var eta = "η";
var ETH$1 = "Ð";
var eth$1 = "ð";
var Euml$1 = "Ë";
var euml$1 = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var Exists = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var ExponentialE = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var forall = "∀";
var ForAll = "∀";
var fork = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12$1 = "½";
var frac13 = "⅓";
var frac14$1 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34$1 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var Fscr = "ℱ";
var gacute = "ǵ";
var Gamma = "Γ";
var gamma = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var ge = "≥";
var gE = "≧";
var gEl = "⪌";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var gescc = "⪩";
var ges = "⩾";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var gg = "≫";
var Gg = "⋙";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gla = "⪥";
var gl = "≷";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gnE = "≩";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var gtcc = "⪧";
var gtcir = "⩺";
var gt$2 = ">";
var GT$1 = ">";
var Gt = "≫";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var harrcir = "⥈";
var harr = "↔";
var hArr = "⇔";
var harrw = "↭";
var Hat = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var Hopf = "ℍ";
var horbar = "―";
var HorizontalLine = "─";
var hscr = "𝒽";
var Hscr = "ℋ";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen = "‐";
var Iacute$1 = "Í";
var iacute$1 = "í";
var ic = "⁣";
var Icirc$1 = "Î";
var icirc$1 = "î";
var Icy = "И";
var icy = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl$1 = "¡";
var iff = "⇔";
var ifr = "𝔦";
var Ifr = "ℑ";
var Igrave$1 = "Ì";
var igrave$1 = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Imacr = "Ī";
var imacr = "ī";
var image = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var Im = "ℑ";
var imof = "⊷";
var imped = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var intcal = "⊺";
var int = "∫";
var Int = "∬";
var integers = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy = "ё";
var Iogon = "Į";
var iogon = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota = "ι";
var iprod = "⨼";
var iquest$1 = "¿";
var iscr = "𝒾";
var Iscr = "ℐ";
var isin = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml$1 = "Ï";
var iuml$1 = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa = "Κ";
var kappa = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda = "Λ";
var lambda = "λ";
var lang = "⟨";
var Lang = "⟪";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var Laplacetrf = "ℒ";
var laquo$1 = "«";
var larrb = "⇤";
var larrbfs = "⤟";
var larr = "←";
var Larr = "↞";
var lArr = "⇐";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var latail = "⤙";
var lAtail = "⤛";
var lat = "⪫";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lBarr = "⤎";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le = "≤";
var lE = "≦";
var LeftAngleBracket = "⟨";
var LeftArrowBar = "⇤";
var leftarrow = "←";
var LeftArrow = "←";
var Leftarrow = "⇐";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVectorBar = "⥙";
var LeftDownVector = "⇃";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTeeArrow = "↤";
var LeftTee = "⊣";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangleBar = "⧏";
var LeftTriangle = "⊲";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVectorBar = "⥘";
var LeftUpVector = "↿";
var LeftVectorBar = "⥒";
var LeftVector = "↼";
var lEg = "⪋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var lescc = "⪨";
var les = "⩽";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var llarr = "⇇";
var ll = "≪";
var Ll = "⋘";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoustache = "⎰";
var lmoust = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lnE = "≨";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftrightarrow = "⟷";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var Lscr = "ℒ";
var lsh = "↰";
var Lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var ltcc = "⪦";
var ltcir = "⩹";
var lt$2 = "<";
var LT$1 = "<";
var Lt = "≪";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr$1 = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map13 = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro$1 = "µ";
var midast = "*";
var midcir = "⫰";
var mid = "∣";
var middot$1 = "·";
var minusb = "⊟";
var minus = "−";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var Mscr = "ℳ";
var mstpos = "∾";
var Mu = "Μ";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natural = "♮";
var naturals = "ℕ";
var natur = "♮";
var nbsp$1 = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy = "н";
var ndash = "–";
var nearhk = "⤤";
var nearr = "↗";
var neArr = "⇗";
var nearrow = "↗";
var ne = "≠";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nharr = "↮";
var nhArr = "⇎";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlarr = "↚";
var nlArr = "⇍";
var nldr = "‥";
var nlE = "≦̸";
var nle = "≰";
var nleftarrow = "↚";
var nLeftarrow = "⇍";
var nleftrightarrow = "↮";
var nLeftrightarrow = "⇎";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var nopf = "𝕟";
var Nopf = "ℕ";
var Not = "⫬";
var not$1 = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangle = "⋫";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var nparallel = "∦";
var npar = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var nprec = "⊀";
var npreceq = "⪯̸";
var npre = "⪯̸";
var nrarrc = "⤳̸";
var nrarr = "↛";
var nrArr = "⇏";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nRightarrow = "⇏";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde$1 = "Ñ";
var ntilde$1 = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvDash = "⊭";
var nVdash = "⊮";
var nVDash = "⊯";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwarr = "↖";
var nwArr = "⇖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute$1 = "Ó";
var oacute$1 = "ó";
var oast = "⊛";
var Ocirc$1 = "Ô";
var ocirc$1 = "ô";
var ocir = "⊚";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve$1 = "Ò";
var ograve$1 = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega = "Ω";
var omega = "ω";
var Omicron = "Ο";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf = "𝕠";
var opar = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var orarr = "↻";
var Or = "⩔";
var or = "∨";
var ord = "⩝";
var order = "ℴ";
var orderof = "ℴ";
var ordf$1 = "ª";
var ordm$1 = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash$1 = "Ø";
var oslash$1 = "ø";
var osol = "⊘";
var Otilde$1 = "Õ";
var otilde$1 = "õ";
var otimesas = "⨶";
var Otimes = "⨷";
var otimes = "⊗";
var Ouml$1 = "Ö";
var ouml$1 = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var para$1 = "¶";
var parallel = "∥";
var par = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var Pi = "Π";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plus = "+";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn$1 = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var popf = "𝕡";
var Popf = "ℙ";
var pound$1 = "£";
var prap = "⪷";
var Pr = "⪻";
var pr = "≺";
var prcue = "≼";
var precapprox = "⪷";
var prec = "≺";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var pre = "⪯";
var prE = "⪳";
var precsim = "≾";
var prime = "′";
var Prime = "″";
var primes = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod = "∏";
var Product = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop = "∝";
var Proportional = "∝";
var Proportion = "∷";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var Qopf = "ℚ";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quot$2 = '"';
var QUOT$1 = '"';
var rAarr = "⇛";
var race = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var Rang = "⟫";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raquo$1 = "»";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarr = "→";
var Rarr = "↠";
var rArr = "⇒";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var rAtail = "⤜";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rBarr = "⤏";
var RBarr = "⤐";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var Re = "ℜ";
var rect = "▭";
var reg$1 = "®";
var REG$1 = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var Rfr = "ℜ";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrowBar = "⇥";
var rightarrow = "→";
var RightArrow = "→";
var Rightarrow = "⇒";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVectorBar = "⥕";
var RightDownVector = "⇂";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTeeArrow = "↦";
var RightTee = "⊢";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangleBar = "⧐";
var RightTriangle = "⊳";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVectorBar = "⥔";
var RightUpVector = "↾";
var RightVectorBar = "⥓";
var RightVector = "⇀";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoustache = "⎱";
var rmoust = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var Ropf = "ℝ";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var rscr = "𝓇";
var Rscr = "ℛ";
var rsh = "↱";
var Rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var scap = "⪸";
var Scaron = "Š";
var scaron = "š";
var Sc = "⪼";
var sc = "≻";
var sccue = "≽";
var sce = "⪰";
var scE = "⪴";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy = "с";
var sdotb = "⊡";
var sdot = "⋅";
var sdote = "⩦";
var searhk = "⤥";
var searr = "↘";
var seArr = "⇘";
var searrow = "↘";
var sect$1 = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy$1 = "­";
var Sigma = "Σ";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var solbar = "⌿";
var solb = "⧄";
var sol = "/";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var square = "□";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squ = "□";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub = "⊂";
var Sub = "⋐";
var subdot = "⪽";
var subE = "⫅";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var Subset = "⋐";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succapprox = "⪸";
var succ = "≻";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var sum = "∑";
var Sum = "∑";
var sung = "♪";
var sup1$1 = "¹";
var sup2$1 = "²";
var sup3$1 = "³";
var sup = "⊃";
var Sup = "⋑";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var Supset = "⋑";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swarr = "↙";
var swArr = "⇙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig$1 = "ß";
var Tab = "	";
var target = "⌖";
var Tau = "Τ";
var tau = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var Therefore = "∴";
var Theta = "Θ";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var ThinSpace = " ";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var THORN$1 = "Þ";
var thorn$1 = "þ";
var tilde = "˜";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var timesbar = "⨱";
var timesb = "⊠";
var times$1 = "×";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var topbot = "⌶";
var topcir = "⫱";
var top = "⊤";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var TRADE = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute$1 = "Ú";
var uacute$1 = "ú";
var uarr = "↑";
var Uarr = "↟";
var uArr = "⇑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc$1 = "Û";
var ucirc$1 = "û";
var Ucy = "У";
var ucy = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave$1 = "Ù";
var ugrave$1 = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml$1 = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrowBar = "⤒";
var uparrow = "↑";
var UpArrow = "↑";
var Uparrow = "⇑";
var UpArrowDownArrow = "⇅";
var updownarrow = "↕";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var upsi = "υ";
var Upsi = "ϒ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTeeArrow = "↥";
var UpTee = "⊥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml$1 = "Ü";
var uuml$1 = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var vArr = "⇕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vBar = "⫨";
var Vbar = "⫫";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var vdash = "⊢";
var vDash = "⊨";
var Vdash = "⊩";
var VDash = "⊫";
var Vdashl = "⫦";
var veebar = "⊻";
var vee = "∨";
var Vee = "⋁";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var Verbar = "‖";
var vert = "|";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var Wedge = "⋀";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xharr = "⟷";
var xhArr = "⟺";
var Xi = "Ξ";
var xi = "ξ";
var xlarr = "⟵";
var xlArr = "⟸";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrarr = "⟶";
var xrArr = "⟹";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute$1 = "Ý";
var yacute$1 = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc = "Ŷ";
var ycirc = "ŷ";
var Ycy = "Ы";
var ycy = "ы";
var yen$1 = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var yuml$1 = "ÿ";
var Yuml = "Ÿ";
var Zacute = "Ź";
var zacute = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var zeta = "ζ";
var zfr = "𝔷";
var Zfr = "ℨ";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var Zopf = "ℤ";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
var require$$1$1 = {
  Aacute: Aacute$1,
  aacute: aacute$1,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc: Acirc$1,
  acirc: acirc$1,
  acute: acute$1,
  Acy,
  acy,
  AElig: AElig$1,
  aelig: aelig$1,
  af,
  Afr,
  afr,
  Agrave: Agrave$1,
  agrave: agrave$1,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp: amp$2,
  AMP: AMP$1,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos: apos$1,
  ApplyFunction,
  approx,
  approxeq,
  Aring: Aring$1,
  aring: aring$1,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde: Atilde$1,
  atilde: atilde$1,
  Auml: Auml$1,
  auml: auml$1,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar: brvbar$1,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil: Ccedil$1,
  ccedil: ccedil$1,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil: cedil$1,
  Cedilla,
  cemptyv,
  cent: cent$1,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check: check2,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY: COPY$1,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren: curren$1,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg: deg$1,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide: divide$1,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute: Eacute$1,
  eacute: eacute$1,
  easter,
  Ecaron,
  ecaron,
  Ecirc: Ecirc$1,
  ecirc: ecirc$1,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave: Egrave$1,
  egrave: egrave$1,
  egs,
  egsdot,
  el,
  Element: Element$1,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty: empty2,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH: ETH$1,
  eth: eth$1,
  Euml: Euml$1,
  euml: euml$1,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12: frac12$1,
  frac13,
  frac14: frac14$1,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34: frac34$1,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt: gt$2,
  GT: GT$1,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute: Iacute$1,
  iacute: iacute$1,
  ic,
  Icirc: Icirc$1,
  icirc: icirc$1,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl: iexcl$1,
  iff,
  ifr,
  Ifr,
  Igrave: Igrave$1,
  igrave: igrave$1,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "∈",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest: iquest$1,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml: Iuml$1,
  iuml: iuml$1,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo: laquo$1,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt: lt$2,
  LT: LT$1,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr: macr$1,
  male,
  malt,
  maltese,
  "Map": "⤅",
  map: map13,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro: micro$1,
  midast,
  midcir,
  mid,
  middot: middot$1,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp: nbsp$1,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not: not$1,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde: Ntilde$1,
  ntilde: ntilde$1,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute: Oacute$1,
  oacute: oacute$1,
  oast,
  Ocirc: Ocirc$1,
  ocirc: ocirc$1,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve: Ograve$1,
  ograve: ograve$1,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf: ordf$1,
  ordm: ordm$1,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash: Oslash$1,
  oslash: oslash$1,
  osol,
  Otilde: Otilde$1,
  otilde: otilde$1,
  otimesas,
  Otimes,
  otimes,
  Ouml: Ouml$1,
  ouml: ouml$1,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para: para$1,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn: plusmn$1,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound: pound$1,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot: quot$2,
  QUOT: QUOT$1,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo: raquo$1,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg: reg$1,
  REG: REG$1,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect: sect$1,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy: shy$1,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig: szlig$1,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN: THORN$1,
  thorn: thorn$1,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times: times$1,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute: Uacute$1,
  uacute: uacute$1,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc: Ucirc$1,
  ucirc: ucirc$1,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave: Ugrave$1,
  ugrave: ugrave$1,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml: uml$1,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml: Uuml$1,
  uuml: uuml$1,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute: Yacute$1,
  yacute: yacute$1,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen: yen$1,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml: yuml$1,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
var Aacute = "Á";
var aacute = "á";
var Acirc = "Â";
var acirc = "â";
var acute = "´";
var AElig = "Æ";
var aelig = "æ";
var Agrave = "À";
var agrave = "à";
var amp$1 = "&";
var AMP = "&";
var Aring = "Å";
var aring = "å";
var Atilde = "Ã";
var atilde = "ã";
var Auml = "Ä";
var auml = "ä";
var brvbar = "¦";
var Ccedil = "Ç";
var ccedil = "ç";
var cedil = "¸";
var cent = "¢";
var copy5 = "©";
var COPY = "©";
var curren = "¤";
var deg = "°";
var divide = "÷";
var Eacute = "É";
var eacute = "é";
var Ecirc = "Ê";
var ecirc = "ê";
var Egrave = "È";
var egrave = "è";
var ETH = "Ð";
var eth = "ð";
var Euml = "Ë";
var euml = "ë";
var frac12 = "½";
var frac14 = "¼";
var frac34 = "¾";
var gt$1 = ">";
var GT = ">";
var Iacute = "Í";
var iacute = "í";
var Icirc = "Î";
var icirc = "î";
var iexcl = "¡";
var Igrave = "Ì";
var igrave = "ì";
var iquest = "¿";
var Iuml = "Ï";
var iuml = "ï";
var laquo = "«";
var lt$1 = "<";
var LT = "<";
var macr = "¯";
var micro = "µ";
var middot = "·";
var nbsp = " ";
var not = "¬";
var Ntilde = "Ñ";
var ntilde = "ñ";
var Oacute = "Ó";
var oacute = "ó";
var Ocirc = "Ô";
var ocirc = "ô";
var Ograve = "Ò";
var ograve = "ò";
var ordf = "ª";
var ordm = "º";
var Oslash = "Ø";
var oslash = "ø";
var Otilde = "Õ";
var otilde = "õ";
var Ouml = "Ö";
var ouml = "ö";
var para = "¶";
var plusmn = "±";
var pound = "£";
var quot$1 = '"';
var QUOT = '"';
var raquo = "»";
var reg = "®";
var REG = "®";
var sect = "§";
var shy = "­";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var szlig = "ß";
var THORN = "Þ";
var thorn = "þ";
var times = "×";
var Uacute = "Ú";
var uacute = "ú";
var Ucirc = "Û";
var ucirc = "û";
var Ugrave = "Ù";
var ugrave = "ù";
var uml = "¨";
var Uuml = "Ü";
var uuml = "ü";
var Yacute = "Ý";
var yacute = "ý";
var yen = "¥";
var yuml = "ÿ";
var require$$1 = {
  Aacute,
  aacute,
  Acirc,
  acirc,
  acute,
  AElig,
  aelig,
  Agrave,
  agrave,
  amp: amp$1,
  AMP,
  Aring,
  aring,
  Atilde,
  atilde,
  Auml,
  auml,
  brvbar,
  Ccedil,
  ccedil,
  cedil,
  cent,
  copy: copy5,
  COPY,
  curren,
  deg,
  divide,
  Eacute,
  eacute,
  Ecirc,
  ecirc,
  Egrave,
  egrave,
  ETH,
  eth,
  Euml,
  euml,
  frac12,
  frac14,
  frac34,
  gt: gt$1,
  GT,
  Iacute,
  iacute,
  Icirc,
  icirc,
  iexcl,
  Igrave,
  igrave,
  iquest,
  Iuml,
  iuml,
  laquo,
  lt: lt$1,
  LT,
  macr,
  micro,
  middot,
  nbsp,
  not,
  Ntilde,
  ntilde,
  Oacute,
  oacute,
  Ocirc,
  ocirc,
  Ograve,
  ograve,
  ordf,
  ordm,
  Oslash,
  oslash,
  Otilde,
  otilde,
  Ouml,
  ouml,
  para,
  plusmn,
  pound,
  quot: quot$1,
  QUOT,
  raquo,
  reg,
  REG,
  sect,
  shy,
  sup1,
  sup2,
  sup3,
  szlig,
  THORN,
  thorn,
  times,
  Uacute,
  uacute,
  Ucirc,
  ucirc,
  Ugrave,
  ugrave,
  uml,
  Uuml,
  uuml,
  Yacute,
  yacute,
  yen,
  yuml
};
var amp = "&";
var apos = "'";
var gt = ">";
var lt = "<";
var quot = '"';
var require$$0$1 = {
  amp,
  apos,
  gt,
  lt,
  quot
};
var decode_codepoint = {};
var require$$0 = {
  "0": 65533,
  "128": 8364,
  "130": 8218,
  "131": 402,
  "132": 8222,
  "133": 8230,
  "134": 8224,
  "135": 8225,
  "136": 710,
  "137": 8240,
  "138": 352,
  "139": 8249,
  "140": 338,
  "142": 381,
  "145": 8216,
  "146": 8217,
  "147": 8220,
  "148": 8221,
  "149": 8226,
  "150": 8211,
  "151": 8212,
  "152": 732,
  "153": 8482,
  "154": 353,
  "155": 8250,
  "156": 339,
  "158": 382,
  "159": 376
};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(decode_codepoint, "__esModule", { value: true });
var decode_json_1 = __importDefault$2(require$$0);
var fromCodePoint$2 = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.fromCodePoint || function(codePoint) {
    var output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function decodeCodePoint(codePoint) {
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return "�";
  }
  if (codePoint in decode_json_1.default) {
    codePoint = decode_json_1.default[codePoint];
  }
  return fromCodePoint$2(codePoint);
}
decode_codepoint.default = decodeCodePoint;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(decode, "__esModule", { value: true });
decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
var entities_json_1$1 = __importDefault$1(require$$1$1);
var legacy_json_1 = __importDefault$1(require$$1);
var xml_json_1$1 = __importDefault$1(require$$0$1);
var decode_codepoint_1 = __importDefault$1(decode_codepoint);
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
decode.decodeXML = getStrictDecoder(xml_json_1$1.default);
decode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);
function getStrictDecoder(map14) {
  var replace3 = getReplacer(map14);
  return function(str) {
    return String(str).replace(strictEntityRe, replace3);
  };
}
var sorter = function(a, b) {
  return a < b ? 1 : -1;
};
decode.decodeHTML = (function() {
  var legacy = Object.keys(legacy_json_1.default).sort(sorter);
  var keys2 = Object.keys(entities_json_1$1.default).sort(sorter);
  for (var i = 0, j = 0; i < keys2.length; i++) {
    if (legacy[j] === keys2[i]) {
      keys2[i] += ";?";
      j++;
    } else {
      keys2[i] += ";";
    }
  }
  var re = new RegExp("&(?:" + keys2.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
  var replace3 = getReplacer(entities_json_1$1.default);
  function replacer(str) {
    if (str.substr(-1) !== ";")
      str += ";";
    return replace3(str);
  }
  return function(str) {
    return String(str).replace(re, replacer);
  };
})();
function getReplacer(map14) {
  return function replace3(str) {
    if (str.charAt(1) === "#") {
      var secondChar = str.charAt(2);
      if (secondChar === "X" || secondChar === "x") {
        return decode_codepoint_1.default(parseInt(str.substr(3), 16));
      }
      return decode_codepoint_1.default(parseInt(str.substr(2), 10));
    }
    return map14[str.slice(1, -1)] || str;
  };
}
var encode = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(encode, "__esModule", { value: true });
encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
var xml_json_1 = __importDefault(require$$0$1);
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
encode.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = __importDefault(require$$1$1);
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
  return Object.keys(obj).sort().reduce(function(inverse, name) {
    inverse[obj[name]] = "&" + name + ";";
    return inverse;
  }, {});
}
function getInverseReplacer(inverse) {
  var single = [];
  var multiple = [];
  for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
    var k = _a[_i];
    if (k.length === 1) {
      single.push("\\" + k);
    } else {
      multiple.push(k);
    }
  }
  single.sort();
  for (var start3 = 0; start3 < single.length - 1; start3++) {
    var end2 = start3;
    while (end2 < single.length - 1 && single[end2].charCodeAt(1) + 1 === single[end2 + 1].charCodeAt(1)) {
      end2 += 1;
    }
    var count = 1 + end2 - start3;
    if (count < 3)
      continue;
    single.splice(start3, count, single[start3] + "-" + single[end2]);
  }
  multiple.unshift("[" + single.join("") + "]");
  return new RegExp(multiple.join("|"), "g");
}
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    function(str) {
      return str.codePointAt(0);
    }
  ) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(c) {
      return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
    }
  )
);
function singleCharReplacer(c) {
  return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
}
function getInverse(inverse, re) {
  return function(data) {
    return data.replace(re, function(name) {
      return inverse[name];
    }).replace(reNonASCII, singleCharReplacer);
  };
}
var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
function escape(data) {
  return data.replace(reEscapeChars, singleCharReplacer);
}
encode.escape = escape;
function escapeUTF8(data) {
  return data.replace(xmlReplacer, singleCharReplacer);
}
encode.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
  return function(data) {
    return data.replace(reEscapeChars, function(c) {
      return obj[c] || singleCharReplacer(c);
    });
  };
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
  var decode_1 = decode;
  var encode_12 = encode;
  function decode$1(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
  }
  exports.decode = decode$1;
  function decodeStrict(data, level) {
    return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
  }
  exports.decodeStrict = decodeStrict;
  function encode$12(data, level) {
    return (!level || level <= 0 ? encode_12.encodeXML : encode_12.encodeHTML)(data);
  }
  exports.encode = encode$12;
  var encode_2 = encode;
  Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function() {
    return encode_2.encodeXML;
  } });
  Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function() {
    return encode_2.encodeNonAsciiHTML;
  } });
  Object.defineProperty(exports, "escape", { enumerable: true, get: function() {
    return encode_2.escape;
  } });
  Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function() {
    return encode_2.escapeUTF8;
  } });
  Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function() {
    return encode_2.encodeHTML;
  } });
  var decode_2 = decode;
  Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
  Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function() {
    return decode_2.decodeHTML;
  } });
  Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function() {
    return decode_2.decodeHTMLStrict;
  } });
  Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function() {
    return decode_2.decodeXML;
  } });
})(lib);
var ENTITY = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});";
var C_BACKSLASH$1 = 92;
var reBackslashOrAmp = /[\\&]/;
var ESCAPABLE = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]";
var reEntityOrEscapedChar = new RegExp("\\\\" + ESCAPABLE + "|" + ENTITY, "gi");
var XMLSPECIAL = '[&<>"]';
var reXmlSpecial = new RegExp(XMLSPECIAL, "g");
var unescapeChar = function(s) {
  if (s.charCodeAt(0) === C_BACKSLASH$1) {
    return s.charAt(1);
  }
  return lib.decodeHTML(s);
};
function unescapeString(s) {
  if (reBackslashOrAmp.test(s)) {
    return s.replace(reEntityOrEscapedChar, unescapeChar);
  }
  return s;
}
function normalizeURI(uri) {
  try {
    return encode_1(uri);
  } catch (err2) {
    return uri;
  }
}
function replaceUnsafeChar(s) {
  switch (s) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return s;
  }
}
function escapeXml(s) {
  if (reXmlSpecial.test(s)) {
    return s.replace(reXmlSpecial, replaceUnsafeChar);
  }
  return s;
}
function repeat(str, count) {
  var arr = [];
  for (var i = 0; i < count; i++) {
    arr.push(str);
  }
  return arr.join("");
}
function isEmpty(str) {
  if (!str) {
    return true;
  }
  return !/[^ \t]+/.test(str);
}
var NodeWalker = (
  /** @class */
  (function() {
    function NodeWalker2(root) {
      this.current = root;
      this.root = root;
      this.entering = true;
    }
    NodeWalker2.prototype.next = function() {
      var cur = this.current;
      var entering = this.entering;
      if (cur === null) {
        return null;
      }
      var container = isContainer$1(cur);
      if (entering && container) {
        if (cur.firstChild) {
          this.current = cur.firstChild;
          this.entering = true;
        } else {
          this.entering = false;
        }
      } else if (cur === this.root) {
        this.current = null;
      } else if (cur.next === null) {
        this.current = cur.parent;
        this.entering = false;
      } else {
        this.current = cur.next;
        this.entering = true;
      }
      return { entering, node: cur };
    };
    NodeWalker2.prototype.resumeAt = function(node4, entering) {
      this.current = node4;
      this.entering = entering === true;
    };
    return NodeWalker2;
  })()
);
function isContainer$1(node4) {
  switch (node4.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return true;
    default:
      return false;
  }
}
var lastNodeId = 1;
var nodeMap = {};
function getNodeById(id) {
  return nodeMap[id];
}
function removeNodeById(id) {
  delete nodeMap[id];
}
function removeAllNode() {
  nodeMap = {};
}
var Node$1 = (
  /** @class */
  (function() {
    function Node4(nodeType2, sourcepos) {
      this.parent = null;
      this.prev = null;
      this.next = null;
      this.firstChild = null;
      this.lastChild = null;
      this.literal = null;
      if (nodeType2 === "document") {
        this.id = -1;
      } else {
        this.id = lastNodeId++;
      }
      this.type = nodeType2;
      this.sourcepos = sourcepos;
      nodeMap[this.id] = this;
    }
    Node4.prototype.isContainer = function() {
      return isContainer$1(this);
    };
    Node4.prototype.unlink = function() {
      if (this.prev) {
        this.prev.next = this.next;
      } else if (this.parent) {
        this.parent.firstChild = this.next;
      }
      if (this.next) {
        this.next.prev = this.prev;
      } else if (this.parent) {
        this.parent.lastChild = this.prev;
      }
      this.parent = null;
      this.next = null;
      this.prev = null;
    };
    Node4.prototype.replaceWith = function(node4) {
      this.insertBefore(node4);
      this.unlink();
    };
    Node4.prototype.insertAfter = function(sibling) {
      sibling.unlink();
      sibling.next = this.next;
      if (sibling.next) {
        sibling.next.prev = sibling;
      }
      sibling.prev = this;
      this.next = sibling;
      if (this.parent) {
        sibling.parent = this.parent;
        if (!sibling.next) {
          sibling.parent.lastChild = sibling;
        }
      }
    };
    Node4.prototype.insertBefore = function(sibling) {
      sibling.unlink();
      sibling.prev = this.prev;
      if (sibling.prev) {
        sibling.prev.next = sibling;
      }
      sibling.next = this;
      this.prev = sibling;
      sibling.parent = this.parent;
      if (!sibling.prev) {
        sibling.parent.firstChild = sibling;
      }
    };
    Node4.prototype.appendChild = function(child3) {
      child3.unlink();
      child3.parent = this;
      if (this.lastChild) {
        this.lastChild.next = child3;
        child3.prev = this.lastChild;
        this.lastChild = child3;
      } else {
        this.firstChild = child3;
        this.lastChild = child3;
      }
    };
    Node4.prototype.prependChild = function(child3) {
      child3.unlink();
      child3.parent = this;
      if (this.firstChild) {
        this.firstChild.prev = child3;
        child3.next = this.firstChild;
        this.firstChild = child3;
      } else {
        this.firstChild = child3;
        this.lastChild = child3;
      }
    };
    Node4.prototype.walker = function() {
      return new NodeWalker(this);
    };
    return Node4;
  })()
);
var BlockNode = (
  /** @class */
  (function(_super) {
    __extends(BlockNode2, _super);
    function BlockNode2(nodeType2, sourcepos) {
      var _this = _super.call(this, nodeType2, sourcepos) || this;
      _this.open = true;
      _this.lineOffsets = null;
      _this.stringContent = null;
      _this.lastLineBlank = false;
      _this.lastLineChecked = false;
      _this.type = nodeType2;
      return _this;
    }
    return BlockNode2;
  })(Node$1)
);
var ListNode = (
  /** @class */
  (function(_super) {
    __extends(ListNode2, _super);
    function ListNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.listData = null;
      return _this;
    }
    return ListNode2;
  })(BlockNode)
);
var HeadingNode = (
  /** @class */
  (function(_super) {
    __extends(HeadingNode2, _super);
    function HeadingNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.level = 0;
      _this.headingType = "atx";
      return _this;
    }
    return HeadingNode2;
  })(BlockNode)
);
var CodeBlockNode = (
  /** @class */
  (function(_super) {
    __extends(CodeBlockNode2, _super);
    function CodeBlockNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isFenced = false;
      _this.fenceChar = null;
      _this.fenceLength = 0;
      _this.fenceOffset = -1;
      _this.info = null;
      _this.infoPadding = 0;
      return _this;
    }
    return CodeBlockNode2;
  })(BlockNode)
);
var TableNode = (
  /** @class */
  (function(_super) {
    __extends(TableNode2, _super);
    function TableNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.columns = [];
      return _this;
    }
    return TableNode2;
  })(BlockNode)
);
var TableCellNode = (
  /** @class */
  (function(_super) {
    __extends(TableCellNode2, _super);
    function TableCellNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.startIdx = 0;
      _this.endIdx = 0;
      _this.paddingLeft = 0;
      _this.paddingRight = 0;
      _this.ignored = false;
      return _this;
    }
    return TableCellNode2;
  })(BlockNode)
);
var RefDefNode = (
  /** @class */
  (function(_super) {
    __extends(RefDefNode2, _super);
    function RefDefNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.title = "";
      _this.dest = "";
      _this.label = "";
      return _this;
    }
    return RefDefNode2;
  })(BlockNode)
);
var CustomBlockNode = (
  /** @class */
  (function(_super) {
    __extends(CustomBlockNode2, _super);
    function CustomBlockNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.syntaxLength = 0;
      _this.offset = -1;
      _this.info = "";
      return _this;
    }
    return CustomBlockNode2;
  })(BlockNode)
);
var HtmlBlockNode = (
  /** @class */
  (function(_super) {
    __extends(HtmlBlockNode2, _super);
    function HtmlBlockNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.htmlBlockType = -1;
      return _this;
    }
    return HtmlBlockNode2;
  })(BlockNode)
);
var LinkNode = (
  /** @class */
  (function(_super) {
    __extends(LinkNode2, _super);
    function LinkNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.destination = null;
      _this.title = null;
      _this.extendedAutolink = false;
      return _this;
    }
    return LinkNode2;
  })(Node$1)
);
var CodeNode = (
  /** @class */
  (function(_super) {
    __extends(CodeNode2, _super);
    function CodeNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.tickCount = 0;
      return _this;
    }
    return CodeNode2;
  })(Node$1)
);
var CustomInlineNode = (
  /** @class */
  (function(_super) {
    __extends(CustomInlineNode2, _super);
    function CustomInlineNode2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.info = "";
      return _this;
    }
    return CustomInlineNode2;
  })(Node$1)
);
function createNode$1(type, sourcepos) {
  switch (type) {
    case "heading":
      return new HeadingNode(type, sourcepos);
    case "list":
    case "item":
      return new ListNode(type, sourcepos);
    case "link":
    case "image":
      return new LinkNode(type, sourcepos);
    case "codeBlock":
      return new CodeBlockNode(type, sourcepos);
    case "htmlBlock":
      return new HtmlBlockNode(type, sourcepos);
    case "table":
      return new TableNode(type, sourcepos);
    case "tableCell":
      return new TableCellNode(type, sourcepos);
    case "document":
    case "paragraph":
    case "blockQuote":
    case "thematicBreak":
    case "tableRow":
    case "tableBody":
    case "tableHead":
    case "frontMatter":
      return new BlockNode(type, sourcepos);
    case "code":
      return new CodeNode(type, sourcepos);
    case "refDef":
      return new RefDefNode(type, sourcepos);
    case "customBlock":
      return new CustomBlockNode(type, sourcepos);
    case "customInline":
      return new CustomInlineNode(type, sourcepos);
    default:
      return new Node$1(type, sourcepos);
  }
}
function isCodeBlock(node4) {
  return node4.type === "codeBlock";
}
function isHtmlBlock(node4) {
  return node4.type === "htmlBlock";
}
function isHeading(node4) {
  return node4.type === "heading";
}
function isList(node4) {
  return node4.type === "list";
}
function isTable(node4) {
  return node4.type === "table";
}
function isRefDef(node4) {
  return node4.type === "refDef";
}
function isCustomBlock(node4) {
  return node4.type === "customBlock";
}
function isCustomInline(node4) {
  return node4.type === "customInline";
}
function text$1(s, sourcepos) {
  var node4 = createNode$1("text", sourcepos);
  node4.literal = s;
  return node4;
}
var TAGNAME = "[A-Za-z][A-Za-z0-9-]*";
var ATTRIBUTENAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var UNQUOTEDVALUE = "[^\"'=<>`\\x00-\\x20]+";
var SINGLEQUOTEDVALUE = "'[^']*'";
var DOUBLEQUOTEDVALUE = '"[^"]*"';
var ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")";
var ATTRIBUTEVALUESPEC = "(?:\\s*=\\s*" + ATTRIBUTEVALUE + ")";
var ATTRIBUTE = "(?:\\s+" + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)";
var OPENTAG = "<" + TAGNAME + ATTRIBUTE + "*\\s*/?>";
var CLOSETAG = "</" + TAGNAME + "\\s*[>]";
var HTMLCOMMENT = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var PROCESSINGINSTRUCTION = "[<][?].*?[?][>]";
var DECLARATION = "<![A-Z]+\\s+[^>]*>";
var CDATA = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" + PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")";
var reHtmlTag = new RegExp("^" + HTMLTAG, "i");
var fromCodePoint;
if (String.fromCodePoint) {
  fromCodePoint = function(_) {
    try {
      return String.fromCodePoint(_);
    } catch (e) {
      if (e instanceof RangeError) {
        return String.fromCharCode(65533);
      }
      throw e;
    }
  };
} else {
  stringFromCharCode_1 = String.fromCharCode;
  floor_1 = Math.floor;
  fromCodePoint = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var MAX_SIZE = 16384;
    var codeUnits = [];
    var highSurrogate;
    var lowSurrogate;
    var index3 = -1;
    var length = args.length;
    if (!length) {
      return "";
    }
    var result2 = "";
    while (++index3 < length) {
      var codePoint = Number(args[index3]);
      if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
      codePoint < 0 || // not a valid Unicode code point
      codePoint > 1114111 || // not a valid Unicode code point
      floor_1(codePoint) !== codePoint) {
        return String.fromCharCode(65533);
      }
      if (codePoint <= 65535) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 65536;
        highSurrogate = (codePoint >> 10) + 55296;
        lowSurrogate = codePoint % 1024 + 56320;
        codeUnits.push(highSurrogate, lowSurrogate);
      }
      if (index3 + 1 === length || codeUnits.length > MAX_SIZE) {
        result2 += stringFromCharCode_1.apply(void 0, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result2;
  };
}
var stringFromCharCode_1;
var floor_1;
var fromCodePoint$1 = fromCodePoint;
var DOMAIN = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+";
var PATH = "[^<\\s]*[^<?!.,:*_?~\\s]";
var EMAIL = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
function trimUnmatchedTrailingParens(source) {
  var trailingParen = /\)+$/.exec(source);
  if (trailingParen) {
    var count = 0;
    for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
      var ch = source_1[_i];
      if (ch === "(") {
        if (count < 0) {
          count = 1;
        } else {
          count += 1;
        }
      } else if (ch === ")") {
        count -= 1;
      }
    }
    if (count < 0) {
      var trimCount = Math.min(-count, trailingParen[0].length);
      return source.substring(0, source.length - trimCount);
    }
  }
  return source;
}
function trimTrailingEntity(source) {
  return source.replace(/&[A-Za-z0-9]+;$/, "");
}
function parseEmailLink(source) {
  var reEmailLink = new RegExp(EMAIL, "g");
  var result2 = [];
  var m;
  while (m = reEmailLink.exec(source)) {
    var text_1 = m[0];
    if (!/[_-]+$/.test(text_1)) {
      result2.push({
        text: text_1,
        range: [m.index, m.index + text_1.length - 1],
        url: "mailto:" + text_1
      });
    }
  }
  return result2;
}
function parseUrlLink(source) {
  var reWwwAutolink = new RegExp("(www|https?://)." + DOMAIN + PATH, "g");
  var result2 = [];
  var m;
  while (m = reWwwAutolink.exec(source)) {
    var text_2 = trimTrailingEntity(trimUnmatchedTrailingParens(m[0]));
    var scheme = m[1] === "www" ? "http://" : "";
    result2.push({
      text: text_2,
      range: [m.index, m.index + text_2.length - 1],
      url: "" + scheme + text_2
    });
  }
  return result2;
}
function baseAutolinkParser(source) {
  return __spreadArray(__spreadArray([], parseUrlLink(source)), parseEmailLink(source)).sort(function(a, b) {
    return a.range[0] - b.range[0];
  });
}
function convertExtAutoLinks(walker, autolinkParser) {
  if (typeof autolinkParser === "boolean") {
    autolinkParser = baseAutolinkParser;
  }
  var event;
  var _loop_1 = function() {
    var entering = event.entering, node4 = event.node;
    if (entering && node4.type === "text" && node4.parent.type !== "link") {
      var literal = node4.literal;
      var linkInfos = autolinkParser(literal);
      if (!linkInfos || !linkInfos.length) {
        return "continue";
      }
      var lastIdx = 0;
      var _a = node4.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];
      var sourcepos = function(startIdx, endIdx) {
        return [
          [lineNum_1, chPos_1 + startIdx],
          [lineNum_1, chPos_1 + endIdx]
        ];
      };
      var newNodes = [];
      for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {
        var _b = linkInfos_1[_i], range2 = _b.range, url = _b.url, linkText = _b.text;
        if (range2[0] > lastIdx) {
          newNodes.push(text$1(literal.substring(lastIdx, range2[0]), sourcepos(lastIdx, range2[0] - 1)));
        }
        var linkNode = createNode$1("link", sourcepos.apply(void 0, range2));
        linkNode.appendChild(text$1(linkText, sourcepos.apply(void 0, range2)));
        linkNode.destination = url;
        linkNode.extendedAutolink = true;
        newNodes.push(linkNode);
        lastIdx = range2[1] + 1;
      }
      if (lastIdx < literal.length) {
        newNodes.push(text$1(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));
      }
      for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {
        var newNode = newNodes_1[_c];
        node4.insertBefore(newNode);
      }
      node4.unlink();
    }
  };
  while (event = walker.next()) {
    _loop_1();
  }
}
function last(arr) {
  return arr[arr.length - 1];
}
function normalizeReference(str) {
  return str.slice(1, str.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
}
function iterateObject(obj, iteratee) {
  Object.keys(obj).forEach(function(key) {
    iteratee(key, obj[key]);
  });
}
function omit(obj) {
  var propNames = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    propNames[_i - 1] = arguments[_i];
  }
  var resultMap = __assign2({}, obj);
  propNames.forEach(function(key) {
    delete resultMap[key];
  });
  return resultMap;
}
function isEmptyObj(obj) {
  return !Object.keys(obj).length;
}
function clearObj(obj) {
  Object.keys(obj).forEach(function(key) {
    delete obj[key];
  });
}
var C_NEWLINE = 10;
var C_ASTERISK = 42;
var C_UNDERSCORE = 95;
var C_BACKTICK = 96;
var C_OPEN_BRACKET$1 = 91;
var C_CLOSE_BRACKET = 93;
var C_TILDE = 126;
var C_LESSTHAN$1 = 60;
var C_BANG = 33;
var C_BACKSLASH = 92;
var C_AMPERSAND = 38;
var C_OPEN_PAREN = 40;
var C_CLOSE_PAREN = 41;
var C_COLON = 58;
var C_SINGLEQUOTE = 39;
var C_DOUBLEQUOTE = 34;
var C_DOLLAR = 36;
var ESCAPED_CHAR = "\\\\" + ESCAPABLE;
var rePunctuation = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/);
var reLinkTitle = new RegExp('^(?:"(' + ESCAPED_CHAR + '|[^"\\x00])*"|' + ("'(" + ESCAPED_CHAR + "|[^'\\x00])*'") + "|" + ("\\((" + ESCAPED_CHAR + "|[^()\\x00])*\\))"));
var reLinkDestinationBraces = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/;
var reEscapable = new RegExp("^" + ESCAPABLE);
var reEntityHere = new RegExp("^" + ENTITY, "i");
var reTicks = /`+/;
var reTicksHere = /^`+/;
var reEllipses = /\.\.\./g;
var reDash = /--+/g;
var reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i;
var reSpnl = /^ *(?:\n *)?/;
var reWhitespaceChar = /^[ \t\n\x0b\x0c\x0d]/;
var reUnicodeWhitespaceChar = /^\s/;
var reFinalSpace = / *$/;
var reInitialSpace = /^ */;
var reSpaceAtEndOfLine = /^ *(?:\n|$)/;
var reLinkLabel = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/;
var reMain = /^[^\n`\[\]\\!<&*_'"~$]+/m;
var InlineParser = (
  /** @class */
  (function() {
    function InlineParser2(options) {
      this.subject = "";
      this.delimiters = null;
      this.brackets = null;
      this.pos = 0;
      this.lineStartNum = 0;
      this.lineIdx = 0;
      this.lineOffsets = [0];
      this.linePosOffset = 0;
      this.refMap = {};
      this.refLinkCandidateMap = {};
      this.refDefCandidateMap = {};
      this.options = options;
    }
    InlineParser2.prototype.sourcepos = function(start3, end2) {
      var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];
      var lineNum = this.lineStartNum + this.lineIdx;
      var startpos = [lineNum, start3 + linePosOffset];
      if (typeof end2 === "number") {
        return [startpos, [lineNum, end2 + linePosOffset]];
      }
      return startpos;
    };
    InlineParser2.prototype.nextLine = function() {
      this.lineIdx += 1;
      this.linePosOffset = -this.pos;
    };
    InlineParser2.prototype.match = function(re) {
      var m = re.exec(this.subject.slice(this.pos));
      if (m === null) {
        return null;
      }
      this.pos += m.index + m[0].length;
      return m[0];
    };
    InlineParser2.prototype.peek = function() {
      if (this.pos < this.subject.length) {
        return this.subject.charCodeAt(this.pos);
      }
      return -1;
    };
    InlineParser2.prototype.spnl = function() {
      this.match(reSpnl);
      return true;
    };
    InlineParser2.prototype.parseBackticks = function(block2) {
      var startpos = this.pos + 1;
      var ticks = this.match(reTicksHere);
      if (ticks === null) {
        return false;
      }
      var afterOpenTicks = this.pos;
      var matched;
      while ((matched = this.match(reTicks)) !== null) {
        if (matched === ticks) {
          var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);
          var sourcepos = this.sourcepos(startpos, this.pos);
          var lines = contents.split("\n");
          if (lines.length > 1) {
            var lastLine = last(lines);
            this.lineIdx += lines.length - 1;
            this.linePosOffset = -(this.pos - lastLine.length - ticks.length);
            sourcepos[1] = this.sourcepos(this.pos);
            contents = lines.join(" ");
          }
          var node4 = createNode$1("code", sourcepos);
          if (contents.length > 0 && contents.match(/[^ ]/) !== null && contents[0] == " " && contents[contents.length - 1] == " ") {
            node4.literal = contents.slice(1, contents.length - 1);
          } else {
            node4.literal = contents;
          }
          node4.tickCount = ticks.length;
          block2.appendChild(node4);
          return true;
        }
      }
      this.pos = afterOpenTicks;
      block2.appendChild(text$1(ticks, this.sourcepos(startpos, this.pos - 1)));
      return true;
    };
    InlineParser2.prototype.parseBackslash = function(block2) {
      var subj = this.subject;
      var node4;
      this.pos += 1;
      var startpos = this.pos;
      if (this.peek() === C_NEWLINE) {
        this.pos += 1;
        node4 = createNode$1("linebreak", this.sourcepos(this.pos - 1, this.pos));
        block2.appendChild(node4);
        this.nextLine();
      } else if (reEscapable.test(subj.charAt(this.pos))) {
        block2.appendChild(text$1(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));
        this.pos += 1;
      } else {
        block2.appendChild(text$1("\\", this.sourcepos(startpos, startpos)));
      }
      return true;
    };
    InlineParser2.prototype.parseAutolink = function(block2) {
      var m;
      var dest;
      var node4;
      var startpos = this.pos + 1;
      if (m = this.match(reEmailAutolink)) {
        dest = m.slice(1, m.length - 1);
        node4 = createNode$1("link", this.sourcepos(startpos, this.pos));
        node4.destination = normalizeURI("mailto:" + dest);
        node4.title = "";
        node4.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));
        block2.appendChild(node4);
        return true;
      }
      if (m = this.match(reAutolink)) {
        dest = m.slice(1, m.length - 1);
        node4 = createNode$1("link", this.sourcepos(startpos, this.pos));
        node4.destination = normalizeURI(dest);
        node4.title = "";
        node4.appendChild(text$1(dest, this.sourcepos(startpos + 1, this.pos - 1)));
        block2.appendChild(node4);
        return true;
      }
      return false;
    };
    InlineParser2.prototype.parseHtmlTag = function(block2) {
      var startpos = this.pos + 1;
      var m = this.match(reHtmlTag);
      if (m === null) {
        return false;
      }
      var node4 = createNode$1("htmlInline", this.sourcepos(startpos, this.pos));
      node4.literal = m;
      block2.appendChild(node4);
      return true;
    };
    InlineParser2.prototype.scanDelims = function(cc) {
      var numdelims = 0;
      var startpos = this.pos;
      if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
        numdelims++;
        this.pos++;
      } else {
        while (this.peek() === cc) {
          numdelims++;
          this.pos++;
        }
      }
      if (numdelims === 0 || numdelims < 2 && (cc === C_TILDE || cc === C_DOLLAR)) {
        this.pos = startpos;
        return null;
      }
      var charBefore = startpos === 0 ? "\n" : this.subject.charAt(startpos - 1);
      var ccAfter = this.peek();
      var charAfter;
      if (ccAfter === -1) {
        charAfter = "\n";
      } else {
        charAfter = fromCodePoint$1(ccAfter);
      }
      var afterIsWhitespace = reUnicodeWhitespaceChar.test(charAfter);
      var afterIsPunctuation = rePunctuation.test(charAfter);
      var beforeIsWhitespace = reUnicodeWhitespaceChar.test(charBefore);
      var beforeIsPunctuation = rePunctuation.test(charBefore);
      var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);
      var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);
      var canOpen;
      var canClose;
      if (cc === C_UNDERSCORE) {
        canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);
        canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);
      } else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
        canOpen = leftFlanking && !rightFlanking;
        canClose = rightFlanking;
      } else if (cc === C_DOLLAR) {
        canOpen = !afterIsWhitespace;
        canClose = !beforeIsWhitespace;
      } else {
        canOpen = leftFlanking;
        canClose = rightFlanking;
      }
      this.pos = startpos;
      return { numdelims, canOpen, canClose };
    };
    InlineParser2.prototype.handleDelim = function(cc, block2) {
      var res = this.scanDelims(cc);
      if (!res) {
        return false;
      }
      var numdelims = res.numdelims;
      var startpos = this.pos + 1;
      var contents;
      this.pos += numdelims;
      if (cc === C_SINGLEQUOTE) {
        contents = "’";
      } else if (cc === C_DOUBLEQUOTE) {
        contents = "“";
      } else {
        contents = this.subject.slice(startpos - 1, this.pos);
      }
      var node4 = text$1(contents, this.sourcepos(startpos, this.pos));
      block2.appendChild(node4);
      if ((res.canOpen || res.canClose) && (this.options.smart || cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE)) {
        this.delimiters = {
          cc,
          numdelims,
          origdelims: numdelims,
          node: node4,
          previous: this.delimiters,
          next: null,
          canOpen: res.canOpen,
          canClose: res.canClose
        };
        if (this.delimiters.previous) {
          this.delimiters.previous.next = this.delimiters;
        }
      }
      return true;
    };
    InlineParser2.prototype.removeDelimiter = function(delim) {
      if (delim.previous !== null) {
        delim.previous.next = delim.next;
      }
      if (delim.next === null) {
        this.delimiters = delim.previous;
      } else {
        delim.next.previous = delim.previous;
      }
    };
    InlineParser2.prototype.removeDelimitersBetween = function(bottom2, top2) {
      if (bottom2.next !== top2) {
        bottom2.next = top2;
        top2.previous = bottom2;
      }
    };
    InlineParser2.prototype.processEmphasis = function(stackBottom) {
      var _a;
      var opener;
      var closer;
      var oldCloser;
      var openerInl, closerInl;
      var openerFound;
      var oddMatch = false;
      var openersBottom = (_a = {}, _a[C_UNDERSCORE] = [stackBottom, stackBottom, stackBottom], _a[C_ASTERISK] = [stackBottom, stackBottom, stackBottom], _a[C_SINGLEQUOTE] = [stackBottom], _a[C_DOUBLEQUOTE] = [stackBottom], _a[C_TILDE] = [stackBottom], _a[C_DOLLAR] = [stackBottom], _a);
      closer = this.delimiters;
      while (closer !== null && closer.previous !== stackBottom) {
        closer = closer.previous;
      }
      while (closer !== null) {
        var closercc = closer.cc;
        var closerEmph = closercc === C_UNDERSCORE || closercc === C_ASTERISK;
        if (!closer.canClose) {
          closer = closer.next;
        } else {
          opener = closer.previous;
          openerFound = false;
          while (opener !== null && opener !== stackBottom && opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {
            oddMatch = closerEmph && (closer.canOpen || opener.canClose) && closer.origdelims % 3 !== 0 && (opener.origdelims + closer.origdelims) % 3 === 0;
            if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {
              openerFound = true;
              break;
            }
            opener = opener.previous;
          }
          oldCloser = closer;
          if (closerEmph || closercc === C_TILDE || closercc === C_DOLLAR) {
            if (!openerFound) {
              closer = closer.next;
            } else if (opener) {
              var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;
              var emptyDelims = closerEmph ? 0 : 1;
              openerInl = opener.node;
              closerInl = closer.node;
              var nodeType2 = closerEmph ? useDelims === 1 ? "emph" : "strong" : "strike";
              if (closercc === C_DOLLAR) {
                nodeType2 = "customInline";
              }
              var newNode = createNode$1(nodeType2);
              var openerEndPos = openerInl.sourcepos[1];
              var closerStartPos = closerInl.sourcepos[0];
              newNode.sourcepos = [
                [openerEndPos[0], openerEndPos[1] - useDelims + 1],
                [closerStartPos[0], closerStartPos[1] + useDelims - 1]
              ];
              openerInl.sourcepos[1][1] -= useDelims;
              closerInl.sourcepos[0][1] += useDelims;
              openerInl.literal = openerInl.literal.slice(useDelims);
              closerInl.literal = closerInl.literal.slice(useDelims);
              opener.numdelims -= useDelims;
              closer.numdelims -= useDelims;
              var tmp = openerInl.next;
              var next = void 0;
              while (tmp && tmp !== closerInl) {
                next = tmp.next;
                tmp.unlink();
                newNode.appendChild(tmp);
                tmp = next;
              }
              if (closercc === C_DOLLAR) {
                var textNode = newNode.firstChild;
                var literal = textNode.literal || "";
                var info = literal.split(/\s/)[0];
                newNode.info = info;
                if (literal.length <= info.length) {
                  textNode.unlink();
                } else {
                  textNode.sourcepos[0][1] += info.length;
                  textNode.literal = literal.replace(info + " ", "");
                }
              }
              openerInl.insertAfter(newNode);
              this.removeDelimitersBetween(opener, closer);
              if (opener.numdelims <= emptyDelims) {
                if (opener.numdelims === 0) {
                  openerInl.unlink();
                }
                this.removeDelimiter(opener);
              }
              if (closer.numdelims <= emptyDelims) {
                if (closer.numdelims === 0) {
                  closerInl.unlink();
                }
                var tempstack = closer.next;
                this.removeDelimiter(closer);
                closer = tempstack;
              }
            }
          } else if (closercc === C_SINGLEQUOTE) {
            closer.node.literal = "’";
            if (openerFound) {
              opener.node.literal = "‘";
            }
            closer = closer.next;
          } else if (closercc === C_DOUBLEQUOTE) {
            closer.node.literal = "”";
            if (openerFound) {
              opener.node.literal = "“";
            }
            closer = closer.next;
          }
          if (!openerFound) {
            openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;
            if (!oldCloser.canOpen) {
              this.removeDelimiter(oldCloser);
            }
          }
        }
      }
      while (this.delimiters !== null && this.delimiters !== stackBottom) {
        this.removeDelimiter(this.delimiters);
      }
    };
    InlineParser2.prototype.parseLinkTitle = function() {
      var title = this.match(reLinkTitle);
      if (title === null) {
        return null;
      }
      return unescapeString(title.substr(1, title.length - 2));
    };
    InlineParser2.prototype.parseLinkDestination = function() {
      var res = this.match(reLinkDestinationBraces);
      if (res === null) {
        if (this.peek() === C_LESSTHAN$1) {
          return null;
        }
        var savepos = this.pos;
        var openparens = 0;
        var c = void 0;
        while ((c = this.peek()) !== -1) {
          if (c === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1))) {
            this.pos += 1;
            if (this.peek() !== -1) {
              this.pos += 1;
            }
          } else if (c === C_OPEN_PAREN) {
            this.pos += 1;
            openparens += 1;
          } else if (c === C_CLOSE_PAREN) {
            if (openparens < 1) {
              break;
            } else {
              this.pos += 1;
              openparens -= 1;
            }
          } else if (reWhitespaceChar.exec(fromCodePoint$1(c)) !== null) {
            break;
          } else {
            this.pos += 1;
          }
        }
        if (this.pos === savepos && c !== C_CLOSE_PAREN) {
          return null;
        }
        if (openparens !== 0) {
          return null;
        }
        res = this.subject.substr(savepos, this.pos - savepos);
        return normalizeURI(unescapeString(res));
      }
      return normalizeURI(unescapeString(res.substr(1, res.length - 2)));
    };
    InlineParser2.prototype.parseLinkLabel = function() {
      var m = this.match(reLinkLabel);
      if (m === null || m.length > 1001) {
        return 0;
      }
      return m.length;
    };
    InlineParser2.prototype.parseOpenBracket = function(block2) {
      var startpos = this.pos;
      this.pos += 1;
      var node4 = text$1("[", this.sourcepos(this.pos, this.pos));
      block2.appendChild(node4);
      this.addBracket(node4, startpos, false);
      return true;
    };
    InlineParser2.prototype.parseBang = function(block2) {
      var startpos = this.pos;
      this.pos += 1;
      if (this.peek() === C_OPEN_BRACKET$1) {
        this.pos += 1;
        var node4 = text$1("![", this.sourcepos(this.pos - 1, this.pos));
        block2.appendChild(node4);
        this.addBracket(node4, startpos + 1, true);
      } else {
        var node4 = text$1("!", this.sourcepos(this.pos, this.pos));
        block2.appendChild(node4);
      }
      return true;
    };
    InlineParser2.prototype.parseCloseBracket = function(block2) {
      var dest = null;
      var title = null;
      var matched = false;
      this.pos += 1;
      var startpos = this.pos;
      var opener = this.brackets;
      if (opener === null) {
        block2.appendChild(text$1("]", this.sourcepos(startpos, startpos)));
        return true;
      }
      if (!opener.active) {
        block2.appendChild(text$1("]", this.sourcepos(startpos, startpos)));
        this.removeBracket();
        return true;
      }
      var isImage = opener.image;
      var savepos = this.pos;
      if (this.peek() === C_OPEN_PAREN) {
        this.pos++;
        if (this.spnl() && (dest = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
        (reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) && (title = this.parseLinkTitle()) || true) && this.spnl() && this.peek() === C_CLOSE_PAREN) {
          this.pos += 1;
          matched = true;
        } else {
          this.pos = savepos;
        }
      }
      var refLabel = "";
      if (!matched) {
        var beforelabel = this.pos;
        var n = this.parseLinkLabel();
        if (n > 2) {
          refLabel = this.subject.slice(beforelabel, beforelabel + n);
        } else if (!opener.bracketAfter) {
          refLabel = this.subject.slice(opener.index, startpos);
        }
        if (n === 0) {
          this.pos = savepos;
        }
        if (refLabel) {
          refLabel = normalizeReference(refLabel);
          var link2 = this.refMap[refLabel];
          if (link2) {
            dest = link2.destination;
            title = link2.title;
            matched = true;
          }
        }
      }
      if (matched) {
        var node4 = createNode$1(isImage ? "image" : "link");
        node4.destination = dest;
        node4.title = title || "";
        node4.sourcepos = [opener.startpos, this.sourcepos(this.pos)];
        var tmp = opener.node.next;
        var next = void 0;
        while (tmp) {
          next = tmp.next;
          tmp.unlink();
          node4.appendChild(tmp);
          tmp = next;
        }
        block2.appendChild(node4);
        this.processEmphasis(opener.previousDelimiter);
        this.removeBracket();
        opener.node.unlink();
        if (!isImage) {
          opener = this.brackets;
          while (opener !== null) {
            if (!opener.image) {
              opener.active = false;
            }
            opener = opener.previous;
          }
        }
        if (this.options.referenceDefinition) {
          this.refLinkCandidateMap[block2.id] = { node: block2, refLabel };
        }
        return true;
      }
      this.removeBracket();
      this.pos = startpos;
      block2.appendChild(text$1("]", this.sourcepos(startpos, startpos)));
      if (this.options.referenceDefinition) {
        this.refLinkCandidateMap[block2.id] = { node: block2, refLabel };
      }
      return true;
    };
    InlineParser2.prototype.addBracket = function(node4, index3, image2) {
      if (this.brackets !== null) {
        this.brackets.bracketAfter = true;
      }
      this.brackets = {
        node: node4,
        startpos: this.sourcepos(index3 + (image2 ? 0 : 1)),
        previous: this.brackets,
        previousDelimiter: this.delimiters,
        index: index3,
        image: image2,
        active: true
      };
    };
    InlineParser2.prototype.removeBracket = function() {
      if (this.brackets) {
        this.brackets = this.brackets.previous;
      }
    };
    InlineParser2.prototype.parseEntity = function(block2) {
      var m;
      var startpos = this.pos + 1;
      if (m = this.match(reEntityHere)) {
        block2.appendChild(text$1(lib.decodeHTML(m), this.sourcepos(startpos, this.pos)));
        return true;
      }
      return false;
    };
    InlineParser2.prototype.parseString = function(block2) {
      var m;
      var startpos = this.pos + 1;
      if (m = this.match(reMain)) {
        if (this.options.smart) {
          var lit = m.replace(reEllipses, "…").replace(reDash, function(chars) {
            var enCount = 0;
            var emCount = 0;
            if (chars.length % 3 === 0) {
              emCount = chars.length / 3;
            } else if (chars.length % 2 === 0) {
              enCount = chars.length / 2;
            } else if (chars.length % 3 === 2) {
              enCount = 1;
              emCount = (chars.length - 2) / 3;
            } else {
              enCount = 2;
              emCount = (chars.length - 4) / 3;
            }
            return repeat("—", emCount) + repeat("–", enCount);
          });
          block2.appendChild(text$1(lit, this.sourcepos(startpos, this.pos)));
        } else {
          var node4 = text$1(m, this.sourcepos(startpos, this.pos));
          block2.appendChild(node4);
        }
        return true;
      }
      return false;
    };
    InlineParser2.prototype.parseNewline = function(block2) {
      this.pos += 1;
      var lastc = block2.lastChild;
      if (lastc && lastc.type === "text" && lastc.literal[lastc.literal.length - 1] === " ") {
        var hardbreak = lastc.literal[lastc.literal.length - 2] === " ";
        var litLen = lastc.literal.length;
        lastc.literal = lastc.literal.replace(reFinalSpace, "");
        var finalSpaceLen = litLen - lastc.literal.length;
        lastc.sourcepos[1][1] -= finalSpaceLen;
        block2.appendChild(createNode$1(hardbreak ? "linebreak" : "softbreak", this.sourcepos(this.pos - finalSpaceLen, this.pos)));
      } else {
        block2.appendChild(createNode$1("softbreak", this.sourcepos(this.pos, this.pos)));
      }
      this.nextLine();
      this.match(reInitialSpace);
      return true;
    };
    InlineParser2.prototype.parseReference = function(block2, refMap) {
      if (!this.options.referenceDefinition) {
        return 0;
      }
      this.subject = block2.stringContent;
      this.pos = 0;
      var title = null;
      var startpos = this.pos;
      var matchChars = this.parseLinkLabel();
      if (matchChars === 0) {
        return 0;
      }
      var rawlabel = this.subject.substr(0, matchChars);
      if (this.peek() === C_COLON) {
        this.pos++;
      } else {
        this.pos = startpos;
        return 0;
      }
      this.spnl();
      var dest = this.parseLinkDestination();
      if (dest === null) {
        this.pos = startpos;
        return 0;
      }
      var beforetitle = this.pos;
      this.spnl();
      if (this.pos !== beforetitle) {
        title = this.parseLinkTitle();
      }
      if (title === null) {
        title = "";
        this.pos = beforetitle;
      }
      var atLineEnd = true;
      if (this.match(reSpaceAtEndOfLine) === null) {
        if (title === "") {
          atLineEnd = false;
        } else {
          title = "";
          this.pos = beforetitle;
          atLineEnd = this.match(reSpaceAtEndOfLine) !== null;
        }
      }
      if (!atLineEnd) {
        this.pos = startpos;
        return 0;
      }
      var normalLabel = normalizeReference(rawlabel);
      if (normalLabel === "") {
        this.pos = startpos;
        return 0;
      }
      var sourcepos = this.getReferenceDefSourcepos(block2);
      block2.sourcepos[0][0] = sourcepos[1][0] + 1;
      var node4 = createNode$1("refDef", sourcepos);
      node4.title = title;
      node4.dest = dest;
      node4.label = normalLabel;
      block2.insertBefore(node4);
      if (!refMap[normalLabel]) {
        refMap[normalLabel] = createRefDefState(node4);
      } else {
        this.refDefCandidateMap[node4.id] = node4;
      }
      return this.pos - startpos;
    };
    InlineParser2.prototype.mergeTextNodes = function(walker) {
      var event;
      var textNodes = [];
      while (event = walker.next()) {
        var entering = event.entering, node4 = event.node;
        if (entering && node4.type === "text") {
          textNodes.push(node4);
        } else if (textNodes.length === 1) {
          textNodes = [];
        } else if (textNodes.length > 1) {
          var firstNode = textNodes[0];
          var lastNode = textNodes[textNodes.length - 1];
          if (firstNode.sourcepos && lastNode.sourcepos) {
            firstNode.sourcepos[1] = lastNode.sourcepos[1];
          }
          firstNode.next = lastNode.next;
          if (firstNode.next) {
            firstNode.next.prev = firstNode;
          }
          for (var i = 1; i < textNodes.length; i += 1) {
            firstNode.literal += textNodes[i].literal;
            textNodes[i].unlink();
          }
          textNodes = [];
        }
      }
    };
    InlineParser2.prototype.getReferenceDefSourcepos = function(block2) {
      var lines = block2.stringContent.split(/\n|\r\n/);
      var passedUrlLine = false;
      var quotationCount = 0;
      var lastLineOffset = { line: 0, ch: 0 };
      for (var i = 0; i < lines.length; i += 1) {
        var line = lines[i];
        if (reWhitespaceChar.test(line)) {
          break;
        }
        if (/\:/.test(line) && quotationCount === 0) {
          if (passedUrlLine) {
            break;
          }
          var lineOffset = line.indexOf(":") === line.length - 1 ? i + 1 : i;
          lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };
          passedUrlLine = true;
        }
        var matched = line.match(/'|"/g);
        if (matched) {
          quotationCount += matched.length;
        }
        if (quotationCount === 2) {
          lastLineOffset = { line: i, ch: line.length };
          break;
        }
      }
      return [
        [block2.sourcepos[0][0], block2.sourcepos[0][1]],
        [block2.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch]
      ];
    };
    InlineParser2.prototype.parseInline = function(block2) {
      var _a;
      var res = false;
      var c = this.peek();
      if (c === -1) {
        return false;
      }
      switch (c) {
        case C_NEWLINE:
          res = this.parseNewline(block2);
          break;
        case C_BACKSLASH:
          res = this.parseBackslash(block2);
          break;
        case C_BACKTICK:
          res = this.parseBackticks(block2);
          break;
        case C_ASTERISK:
        case C_UNDERSCORE:
        case C_TILDE:
        case C_DOLLAR:
          res = this.handleDelim(c, block2);
          break;
        case C_SINGLEQUOTE:
        case C_DOUBLEQUOTE:
          res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block2);
          break;
        case C_OPEN_BRACKET$1:
          res = this.parseOpenBracket(block2);
          break;
        case C_BANG:
          res = this.parseBang(block2);
          break;
        case C_CLOSE_BRACKET:
          res = this.parseCloseBracket(block2);
          break;
        case C_LESSTHAN$1:
          res = this.parseAutolink(block2) || this.parseHtmlTag(block2);
          break;
        case C_AMPERSAND:
          if (!block2.disabledEntityParse) {
            res = this.parseEntity(block2);
          }
          break;
        default:
          res = this.parseString(block2);
          break;
      }
      if (!res) {
        this.pos += 1;
        block2.appendChild(text$1(fromCodePoint$1(c), this.sourcepos(this.pos, this.pos + 1)));
      }
      return true;
    };
    InlineParser2.prototype.parse = function(block2) {
      this.subject = block2.stringContent.trim();
      this.pos = 0;
      this.delimiters = null;
      this.brackets = null;
      this.lineOffsets = block2.lineOffsets || [0];
      this.lineIdx = 0;
      this.linePosOffset = 0;
      this.lineStartNum = block2.sourcepos[0][0];
      if (isHeading(block2)) {
        this.lineOffsets[0] += block2.level + 1;
      }
      while (this.parseInline(block2)) {
      }
      block2.stringContent = null;
      this.processEmphasis(null);
      this.mergeTextNodes(block2.walker());
      var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;
      if (extendedAutolinks) {
        convertExtAutoLinks(block2.walker(), extendedAutolinks);
      }
      if (customParser && block2.firstChild) {
        var event_1;
        var walker = block2.firstChild.walker();
        while (event_1 = walker.next()) {
          var node4 = event_1.node, entering = event_1.entering;
          if (customParser[node4.type]) {
            customParser[node4.type](node4, { entering, options: this.options });
          }
        }
      }
    };
    return InlineParser2;
  })()
);
var reTaskListItemMarker = /^\[([ \txX])\][ \t]+/;
function taskListItemFinalize(_, block2) {
  if (block2.firstChild && block2.firstChild.type === "paragraph") {
    var p = block2.firstChild;
    var m = p.stringContent.match(reTaskListItemMarker);
    if (m) {
      var mLen = m[0].length;
      p.stringContent = p.stringContent.substring(mLen - 1);
      p.sourcepos[0][1] += mLen;
      p.lineOffsets[0] += mLen;
      block2.listData.task = true;
      block2.listData.checked = /[xX]/.test(m[1]);
    }
  }
}
var table = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableHead" || t === "tableBody";
  },
  acceptsLines: false
};
var tableBody$1 = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableRow";
  },
  acceptsLines: false
};
var tableHead$1 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableRow" || t === "tableDelimRow";
  },
  acceptsLines: false
};
var tableDelimRow = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableDelimCell";
  },
  acceptsLines: false
};
var tableDelimCell = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return false;
  },
  acceptsLines: false
};
var tableRow = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t === "tableCell";
  },
  acceptsLines: false
};
var tableCell = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return false;
  },
  acceptsLines: false
};
var CODE_INDENT = 4;
var C_TAB = 9;
var C_GREATERTHAN = 62;
var C_LESSTHAN = 60;
var C_SPACE = 32;
var C_OPEN_BRACKET = 91;
var reNonSpace = /[^ \t\f\v\r\n]/;
var reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;
function endsWithBlankLine(block2) {
  var curBlock = block2;
  while (curBlock) {
    if (curBlock.lastLineBlank) {
      return true;
    }
    var t = curBlock.type;
    if (!curBlock.lastLineChecked && (t === "list" || t === "item")) {
      curBlock.lastLineChecked = true;
      curBlock = curBlock.lastChild;
    } else {
      curBlock.lastLineChecked = true;
      break;
    }
  }
  return false;
}
function peek(ln, pos) {
  if (pos < ln.length) {
    return ln.charCodeAt(pos);
  }
  return -1;
}
function isBlank(s) {
  return !reNonSpace.test(s);
}
function isSpaceOrTab(c) {
  return c === C_SPACE || c === C_TAB;
}
var reClosingCustomBlock = /^\$\$$/;
var customBlock$1 = {
  continue: function(parser, container) {
    var line = parser.currentLine;
    var match = line.match(reClosingCustomBlock);
    if (match) {
      parser.lastLineLength = match[0].length;
      parser.finalize(container, parser.lineNumber);
      return 2;
    }
    var i = container.offset;
    while (i > 0 && isSpaceOrTab(peek(line, parser.offset))) {
      parser.advanceOffset(1, true);
      i--;
    }
    return 0;
  },
  finalize: function(_, block2) {
    if (block2.stringContent === null) {
      return;
    }
    var content2 = block2.stringContent;
    var newlinePos = content2.indexOf("\n");
    var firstLine = content2.slice(0, newlinePos);
    var rest = content2.slice(newlinePos + 1);
    var infoString = firstLine.match(/^(\s*)(.*)/);
    block2.info = unescapeString(infoString[2].trim());
    block2.literal = rest;
    block2.stringContent = null;
  },
  canContain: function() {
    return false;
  },
  acceptsLines: true
};
var noop = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return false;
  },
  acceptsLines: true
};
var document$1 = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t !== "item";
  },
  acceptsLines: false
};
var list = {
  continue: function() {
    return 0;
  },
  finalize: function(_, block2) {
    var item2 = block2.firstChild;
    while (item2) {
      if (endsWithBlankLine(item2) && item2.next) {
        block2.listData.tight = false;
        break;
      }
      var subitem = item2.firstChild;
      while (subitem) {
        if (endsWithBlankLine(subitem) && (item2.next || subitem.next)) {
          block2.listData.tight = false;
          break;
        }
        subitem = subitem.next;
      }
      item2 = item2.next;
    }
  },
  canContain: function(t) {
    return t === "item";
  },
  acceptsLines: false
};
var blockQuote$1 = {
  continue: function(parser) {
    var ln = parser.currentLine;
    if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {
      parser.advanceNextNonspace();
      parser.advanceOffset(1, false);
      if (isSpaceOrTab(peek(ln, parser.offset))) {
        parser.advanceOffset(1, true);
      }
    } else {
      return 1;
    }
    return 0;
  },
  finalize: function() {
  },
  canContain: function(t) {
    return t !== "item";
  },
  acceptsLines: false
};
var item = {
  continue: function(parser, container) {
    if (parser.blank) {
      if (container.firstChild === null) {
        return 1;
      }
      parser.advanceNextNonspace();
    } else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {
      parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);
    } else {
      return 1;
    }
    return 0;
  },
  finalize: taskListItemFinalize,
  canContain: function(t) {
    return t !== "item";
  },
  acceptsLines: false
};
var heading = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return false;
  },
  acceptsLines: false
};
var thematicBreak$1 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return false;
  },
  acceptsLines: false
};
var codeBlock = {
  continue: function(parser, container) {
    var ln = parser.currentLine;
    var indent2 = parser.indent;
    if (container.isFenced) {
      var match = indent2 <= 3 && ln.charAt(parser.nextNonspace) === container.fenceChar && ln.slice(parser.nextNonspace).match(reClosingCodeFence);
      if (match && match[0].length >= container.fenceLength) {
        parser.lastLineLength = parser.offset + indent2 + match[0].length;
        parser.finalize(container, parser.lineNumber);
        return 2;
      }
      var i = container.fenceOffset;
      while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {
        parser.advanceOffset(1, true);
        i--;
      }
    } else {
      if (indent2 >= CODE_INDENT) {
        parser.advanceOffset(CODE_INDENT, true);
      } else if (parser.blank) {
        parser.advanceNextNonspace();
      } else {
        return 1;
      }
    }
    return 0;
  },
  finalize: function(_, block2) {
    var _a;
    if (block2.stringContent === null) {
      return;
    }
    if (block2.isFenced) {
      var content2 = block2.stringContent;
      var newlinePos = content2.indexOf("\n");
      var firstLine = content2.slice(0, newlinePos);
      var rest = content2.slice(newlinePos + 1);
      var infoString = firstLine.match(/^(\s*)(.*)/);
      block2.infoPadding = infoString[1].length;
      block2.info = unescapeString(infoString[2].trim());
      block2.literal = rest;
    } else {
      block2.literal = (_a = block2.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\n *)+$/, "\n");
    }
    block2.stringContent = null;
  },
  canContain: function() {
    return false;
  },
  acceptsLines: true
};
var htmlBlock$1 = {
  continue: function(parser, container) {
    return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7) ? 1 : 0;
  },
  finalize: function(_, block2) {
    var _a;
    block2.literal = ((_a = block2.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\n *)+$/, "")) || null;
    block2.stringContent = null;
  },
  canContain: function() {
    return false;
  },
  acceptsLines: true
};
var paragraph = {
  continue: function(parser) {
    return parser.blank ? 1 : 0;
  },
  finalize: function(parser, block2) {
    if (block2.stringContent === null) {
      return;
    }
    var pos;
    var hasReferenceDefs = false;
    while (peek(block2.stringContent, 0) === C_OPEN_BRACKET && (pos = parser.inlineParser.parseReference(block2, parser.refMap))) {
      block2.stringContent = block2.stringContent.slice(pos);
      hasReferenceDefs = true;
    }
    if (hasReferenceDefs && isBlank(block2.stringContent)) {
      block2.unlink();
    }
  },
  canContain: function() {
    return false;
  },
  acceptsLines: true
};
var refDef = noop;
var frontMatter$2 = noop;
var blockHandlers = {
  document: document$1,
  list,
  blockQuote: blockQuote$1,
  item,
  heading,
  thematicBreak: thematicBreak$1,
  codeBlock,
  htmlBlock: htmlBlock$1,
  paragraph,
  table,
  tableBody: tableBody$1,
  tableHead: tableHead$1,
  tableRow,
  tableCell,
  tableDelimRow,
  tableDelimCell,
  refDef,
  customBlock: customBlock$1,
  frontMatter: frontMatter$2
};
function parseRowContent(content2) {
  var startIdx = 0;
  var offset2 = 0;
  var cells = [];
  for (var i = 0; i < content2.length; i += 1) {
    if (content2[i] === "|" && content2[i - 1] !== "\\") {
      var cell = content2.substring(startIdx, i);
      if (startIdx === 0 && isEmpty(cell)) {
        offset2 = i + 1;
      } else {
        cells.push(cell);
      }
      startIdx = i + 1;
    }
  }
  if (startIdx < content2.length) {
    var cell = content2.substring(startIdx, content2.length);
    if (!isEmpty(cell)) {
      cells.push(cell);
    }
  }
  return [offset2, cells];
}
function generateTableCells(cellType, contents, lineNum, chPos) {
  var cells = [];
  for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {
    var content2 = contents_1[_i];
    var preSpaces = content2.match(/^[ \t]+/);
    var paddingLeft = preSpaces ? preSpaces[0].length : 0;
    var paddingRight = void 0, trimmed = void 0;
    if (paddingLeft === content2.length) {
      paddingLeft = 0;
      paddingRight = 0;
      trimmed = "";
    } else {
      var postSpaces = content2.match(/[ \t]+$/);
      paddingRight = postSpaces ? postSpaces[0].length : 0;
      trimmed = content2.slice(paddingLeft, content2.length - paddingRight);
    }
    var chPosStart = chPos + paddingLeft;
    var tableCell2 = createNode$1(cellType, [
      [lineNum, chPos],
      [lineNum, chPos + content2.length - 1]
    ]);
    tableCell2.stringContent = trimmed.replace(/\\\|/g, "|");
    tableCell2.startIdx = cells.length;
    tableCell2.endIdx = cells.length;
    tableCell2.lineOffsets = [chPosStart - 1];
    tableCell2.paddingLeft = paddingLeft;
    tableCell2.paddingRight = paddingRight;
    cells.push(tableCell2);
    chPos += content2.length + 1;
  }
  return cells;
}
function getColumnFromDelimCell(cellNode) {
  var align = null;
  var content2 = cellNode.stringContent;
  var firstCh = content2[0];
  var lastCh = content2[content2.length - 1];
  if (lastCh === ":") {
    align = firstCh === ":" ? "center" : "right";
  } else if (firstCh === ":") {
    align = "left";
  }
  return { align };
}
var tableHead = function(parser, container) {
  var stringContent = container.stringContent;
  if (container.type === "paragraph" && !parser.indented && !parser.blank) {
    var lastNewLineIdx = stringContent.length - 1;
    var lastLineStartIdx = stringContent.lastIndexOf("\n", lastNewLineIdx - 1) + 1;
    var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);
    var delimContent = parser.currentLine.slice(parser.nextNonspace);
    var _a = parseRowContent(headerContent), headerOffset = _a[0], headerCells = _a[1];
    var _b = parseRowContent(delimContent), delimOffset = _b[0], delimCells = _b[1];
    var reValidDelimCell_1 = /^[ \t]*:?-+:?[ \t]*$/;
    if (
      // not checking if the number of header cells and delimiter cells are the same
      // to consider the case of merged-column (via plugin)
      !headerCells.length || !delimCells.length || delimCells.some(function(cell) {
        return !reValidDelimCell_1.test(cell);
      }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
      delimCells.length === 1 && delimContent.indexOf("|") !== 0
    ) {
      return 0;
    }
    var lineOffsets = container.lineOffsets;
    var firstLineNum = parser.lineNumber - 1;
    var firstLineStart = last(lineOffsets) + 1;
    var table2 = createNode$1("table", [
      [firstLineNum, firstLineStart],
      [parser.lineNumber, parser.offset]
    ]);
    table2.columns = delimCells.map(function() {
      return { align: null };
    });
    container.insertAfter(table2);
    if (lineOffsets.length === 1) {
      container.unlink();
    } else {
      container.stringContent = stringContent.slice(0, lastLineStartIdx);
      var paraLastLineStartIdx = stringContent.lastIndexOf("\n", lastLineStartIdx - 2) + 1;
      var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;
      parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;
      parser.finalize(container, firstLineNum - 1);
    }
    parser.advanceOffset(parser.currentLine.length - parser.offset, false);
    var tableHead_1 = createNode$1("tableHead", [
      [firstLineNum, firstLineStart],
      [parser.lineNumber, parser.offset]
    ]);
    table2.appendChild(tableHead_1);
    var tableHeadRow_1 = createNode$1("tableRow", [
      [firstLineNum, firstLineStart],
      [firstLineNum, firstLineStart + headerContent.length - 1]
    ]);
    var tableDelimRow_1 = createNode$1("tableDelimRow", [
      [parser.lineNumber, parser.nextNonspace + 1],
      [parser.lineNumber, parser.offset]
    ]);
    tableHead_1.appendChild(tableHeadRow_1);
    tableHead_1.appendChild(tableDelimRow_1);
    generateTableCells("tableCell", headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function(cellNode) {
      tableHeadRow_1.appendChild(cellNode);
    });
    var delimCellNodes = generateTableCells("tableDelimCell", delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);
    delimCellNodes.forEach(function(cellNode) {
      tableDelimRow_1.appendChild(cellNode);
    });
    table2.columns = delimCellNodes.map(getColumnFromDelimCell);
    parser.tip = table2;
    return 2;
  }
  return 0;
};
var tableBody = function(parser, container) {
  if (container.type !== "table" && container.type !== "tableBody" || !parser.blank && parser.currentLine.indexOf("|") === -1) {
    return 0;
  }
  parser.advanceOffset(parser.currentLine.length - parser.offset, false);
  if (parser.blank) {
    var table_1 = container;
    if (container.type === "tableBody") {
      table_1 = container.parent;
      parser.finalize(container, parser.lineNumber - 1);
    }
    parser.finalize(table_1, parser.lineNumber - 1);
    return 0;
  }
  var tableBody2 = container;
  if (container.type === "table") {
    tableBody2 = parser.addChild("tableBody", parser.nextNonspace);
    tableBody2.stringContent = null;
  }
  var tableRow2 = createNode$1("tableRow", [
    [parser.lineNumber, parser.nextNonspace + 1],
    [parser.lineNumber, parser.currentLine.length]
  ]);
  tableBody2.appendChild(tableRow2);
  var table2 = tableBody2.parent;
  var content2 = parser.currentLine.slice(parser.nextNonspace);
  var _a = parseRowContent(content2), offset2 = _a[0], cellContents = _a[1];
  generateTableCells("tableCell", cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset2).forEach(function(cellNode, idx) {
    if (idx >= table2.columns.length) {
      cellNode.ignored = true;
    }
    tableRow2.appendChild(cellNode);
  });
  return 2;
};
var reCustomBlock = /^(\$\$)(\s*[a-zA-Z])+/;
var reCanBeCustomInline = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/;
var customBlock = function(parser) {
  var match;
  if (!parser.indented && !reCanBeCustomInline.test(parser.currentLine) && (match = parser.currentLine.match(reCustomBlock))) {
    var syntaxLength = match[1].length;
    parser.closeUnmatchedBlocks();
    var container = parser.addChild("customBlock", parser.nextNonspace);
    container.syntaxLength = syntaxLength;
    container.offset = parser.indent;
    parser.advanceNextNonspace();
    parser.advanceOffset(syntaxLength, false);
    return 2;
  }
  return 0;
};
var reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;
var reHtmlBlockOpen = [
  /./,
  /^<(?:script|pre|style)(?:\s|>|$)/i,
  /^<!--/,
  /^<[?]/,
  /^<![A-Z]/,
  /^<!\[CDATA\[/,
  /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
  new RegExp("^(?:" + OPENTAG + "|" + CLOSETAG + ")\\s*$", "i")
];
var reSetextHeadingLine = /^(?:=+|-+)[ \t]*$/;
var reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/;
var reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/;
var reBulletListMarker = /^[*+-]/;
var reOrderedListMarker = /^(\d{1,9})([.)])/;
function parseListMarker(parser, container) {
  var rest = parser.currentLine.slice(parser.nextNonspace);
  var match;
  var nextc;
  var data = {
    type: "bullet",
    tight: true,
    bulletChar: "",
    start: 0,
    delimiter: "",
    padding: 0,
    markerOffset: parser.indent,
    // GFM: Task List Item
    task: false,
    checked: false
  };
  if (parser.indent >= 4) {
    return null;
  }
  if (match = rest.match(reBulletListMarker)) {
    data.type = "bullet";
    data.bulletChar = match[0][0];
  } else if ((match = rest.match(reOrderedListMarker)) && (container.type !== "paragraph" || match[1] === "1")) {
    data.type = "ordered";
    data.start = parseInt(match[1], 10);
    data.delimiter = match[2];
  } else {
    return null;
  }
  nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);
  if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {
    return null;
  }
  if (container.type === "paragraph" && !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {
    return null;
  }
  parser.advanceNextNonspace();
  parser.advanceOffset(match[0].length, true);
  var spacesStartCol = parser.column;
  var spacesStartOffset = parser.offset;
  do {
    parser.advanceOffset(1, true);
    nextc = peek(parser.currentLine, parser.offset);
  } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));
  var blankItem = peek(parser.currentLine, parser.offset) === -1;
  var spacesAfterMarker = parser.column - spacesStartCol;
  if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {
    data.padding = match[0].length + 1;
    parser.column = spacesStartCol;
    parser.offset = spacesStartOffset;
    if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
      parser.advanceOffset(1, true);
    }
  } else {
    data.padding = match[0].length + spacesAfterMarker;
  }
  return data;
}
function listsMatch(listData, itemData) {
  return listData.type === itemData.type && listData.delimiter === itemData.delimiter && listData.bulletChar === itemData.bulletChar;
}
function isDisallowedDeepHeading(parser, node4) {
  return parser.options.disallowDeepHeading && (node4.type === "blockQuote" || node4.type === "item");
}
var blockQuote = function(parser) {
  if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {
    parser.advanceNextNonspace();
    parser.advanceOffset(1, false);
    if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
      parser.advanceOffset(1, true);
    }
    parser.closeUnmatchedBlocks();
    parser.addChild("blockQuote", parser.nextNonspace);
    return 1;
  }
  return 0;
};
var atxHeading = function(parser, container) {
  var match;
  if (!parser.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !isDisallowedDeepHeading(parser, container) && (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {
    parser.advanceNextNonspace();
    parser.advanceOffset(match[0].length, false);
    parser.closeUnmatchedBlocks();
    var heading2 = parser.addChild("heading", parser.nextNonspace);
    heading2.level = match[0].trim().length;
    heading2.headingType = "atx";
    heading2.stringContent = parser.currentLine.slice(parser.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, "");
    parser.advanceOffset(parser.currentLine.length - parser.offset);
    return 2;
  }
  return 0;
};
var fencedCodeBlock = function(parser) {
  var match;
  if (!parser.indented && (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {
    var fenceLength = match[0].length;
    parser.closeUnmatchedBlocks();
    var container = parser.addChild("codeBlock", parser.nextNonspace);
    container.isFenced = true;
    container.fenceLength = fenceLength;
    container.fenceChar = match[0][0];
    container.fenceOffset = parser.indent;
    parser.advanceNextNonspace();
    parser.advanceOffset(fenceLength, false);
    return 2;
  }
  return 0;
};
var htmlBlock = function(parser, container) {
  if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {
    var s = parser.currentLine.slice(parser.nextNonspace);
    var disallowedTags2 = parser.options.disallowedHtmlBlockTags;
    var blockType = void 0;
    for (blockType = 1; blockType <= 7; blockType++) {
      var matched = s.match(reHtmlBlockOpen[blockType]);
      if (matched) {
        if (blockType === 7) {
          if (container.type === "paragraph") {
            return 0;
          }
          if (disallowedTags2.length > 0) {
            var reDisallowedTags = new RegExp("</?(?:" + disallowedTags2.join("|") + ")", "i");
            if (reDisallowedTags.test(matched[0])) {
              return 0;
            }
          }
        }
        parser.closeUnmatchedBlocks();
        var b = parser.addChild("htmlBlock", parser.offset);
        b.htmlBlockType = blockType;
        return 2;
      }
    }
  }
  return 0;
};
var seTextHeading = function(parser, container) {
  var match;
  if (container.stringContent !== null && !parser.indented && container.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !isDisallowedDeepHeading(parser, container.parent) && (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {
    parser.closeUnmatchedBlocks();
    var pos = void 0;
    while (peek(container.stringContent, 0) === C_OPEN_BRACKET && (pos = parser.inlineParser.parseReference(container, parser.refMap))) {
      container.stringContent = container.stringContent.slice(pos);
    }
    if (container.stringContent.length > 0) {
      var heading2 = createNode$1("heading", container.sourcepos);
      heading2.level = match[0][0] === "=" ? 1 : 2;
      heading2.headingType = "setext";
      heading2.stringContent = container.stringContent;
      container.insertAfter(heading2);
      container.unlink();
      parser.tip = heading2;
      parser.advanceOffset(parser.currentLine.length - parser.offset, false);
      return 2;
    }
    return 0;
  }
  return 0;
};
var thematicBreak = function(parser) {
  if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {
    parser.closeUnmatchedBlocks();
    parser.addChild("thematicBreak", parser.nextNonspace);
    parser.advanceOffset(parser.currentLine.length - parser.offset, false);
    return 2;
  }
  return 0;
};
var listItem = function(parser, container) {
  var data;
  var currNode = container;
  if ((!parser.indented || container.type === "list") && (data = parseListMarker(parser, currNode))) {
    parser.closeUnmatchedBlocks();
    if (parser.tip.type !== "list" || !listsMatch(currNode.listData, data)) {
      currNode = parser.addChild("list", parser.nextNonspace);
      currNode.listData = data;
    }
    currNode = parser.addChild("item", parser.nextNonspace);
    currNode.listData = data;
    return 1;
  }
  return 0;
};
var indentedCodeBlock = function(parser) {
  if (parser.indented && parser.tip.type !== "paragraph" && !parser.blank) {
    parser.advanceOffset(CODE_INDENT, true);
    parser.closeUnmatchedBlocks();
    parser.addChild("codeBlock", parser.offset);
    return 2;
  }
  return 0;
};
var blockStarts = [
  blockQuote,
  atxHeading,
  fencedCodeBlock,
  htmlBlock,
  seTextHeading,
  thematicBreak,
  listItem,
  indentedCodeBlock,
  tableHead,
  tableBody,
  customBlock
];
var reFrontMatter = /^(-{3}|\+{3}|;{3})$/;
var frontMatter$1 = function(parser, container) {
  var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;
  if (lineNumber === 1 && !indented && container.type === "document" && reFrontMatter.test(currentLine)) {
    parser.closeUnmatchedBlocks();
    var frontMatter_1 = parser.addChild("frontMatter", parser.nextNonspace);
    frontMatter_1.stringContent = currentLine;
    parser.advanceNextNonspace();
    parser.advanceOffset(currentLine.length, false);
    return 2;
  }
  return 0;
};
var frontMatter = {
  continue: function(parser, container) {
    var line = parser.currentLine;
    var match = line.match(reFrontMatter);
    if (container.type === "frontMatter" && match) {
      container.stringContent += line;
      parser.lastLineLength = match[0].length;
      parser.finalize(container, parser.lineNumber);
      return 2;
    }
    return 0;
  },
  finalize: function(_, block2) {
    if (block2.stringContent === null) {
      return;
    }
    block2.literal = block2.stringContent;
    block2.stringContent = null;
  },
  canContain: function() {
    return false;
  },
  acceptsLines: true
};
var reHtmlBlockClose = [
  /./,
  /<\/(?:script|pre|style)>/i,
  /-->/,
  /\?>/,
  />/,
  /\]\]>/
];
var reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/;
var reLineEnding$1 = /\r\n|\n|\r/;
function document$2() {
  return createNode$1("document", [
    [1, 1],
    [0, 0]
  ]);
}
var defaultOptions$1 = {
  smart: false,
  tagFilter: false,
  extendedAutolinks: false,
  disallowedHtmlBlockTags: [],
  referenceDefinition: false,
  disallowDeepHeading: false,
  customParser: null,
  frontMatter: false
};
var Parser = (
  /** @class */
  (function() {
    function Parser2(options) {
      this.options = __assign2(__assign2({}, defaultOptions$1), options);
      this.doc = document$2();
      this.tip = this.doc;
      this.oldtip = this.doc;
      this.lineNumber = 0;
      this.offset = 0;
      this.column = 0;
      this.nextNonspace = 0;
      this.nextNonspaceColumn = 0;
      this.indent = 0;
      this.currentLine = "";
      this.indented = false;
      this.blank = false;
      this.partiallyConsumedTab = false;
      this.allClosed = true;
      this.lastMatchedContainer = this.doc;
      this.refMap = {};
      this.refLinkCandidateMap = {};
      this.refDefCandidateMap = {};
      this.lastLineLength = 0;
      this.lines = [];
      if (this.options.frontMatter) {
        blockHandlers.frontMatter = frontMatter;
        blockStarts.unshift(frontMatter$1);
      }
      this.inlineParser = new InlineParser(this.options);
    }
    Parser2.prototype.advanceOffset = function(count, columns) {
      if (columns === void 0) {
        columns = false;
      }
      var currentLine = this.currentLine;
      var charsToTab, charsToAdvance;
      var c;
      while (count > 0 && (c = currentLine[this.offset])) {
        if (c === "	") {
          charsToTab = 4 - this.column % 4;
          if (columns) {
            this.partiallyConsumedTab = charsToTab > count;
            charsToAdvance = charsToTab > count ? count : charsToTab;
            this.column += charsToAdvance;
            this.offset += this.partiallyConsumedTab ? 0 : 1;
            count -= charsToAdvance;
          } else {
            this.partiallyConsumedTab = false;
            this.column += charsToTab;
            this.offset += 1;
            count -= 1;
          }
        } else {
          this.partiallyConsumedTab = false;
          this.offset += 1;
          this.column += 1;
          count -= 1;
        }
      }
    };
    Parser2.prototype.advanceNextNonspace = function() {
      this.offset = this.nextNonspace;
      this.column = this.nextNonspaceColumn;
      this.partiallyConsumedTab = false;
    };
    Parser2.prototype.findNextNonspace = function() {
      var currentLine = this.currentLine;
      var i = this.offset;
      var cols = this.column;
      var c;
      while ((c = currentLine.charAt(i)) !== "") {
        if (c === " ") {
          i++;
          cols++;
        } else if (c === "	") {
          i++;
          cols += 4 - cols % 4;
        } else {
          break;
        }
      }
      this.blank = c === "\n" || c === "\r" || c === "";
      this.nextNonspace = i;
      this.nextNonspaceColumn = cols;
      this.indent = this.nextNonspaceColumn - this.column;
      this.indented = this.indent >= CODE_INDENT;
    };
    Parser2.prototype.addLine = function() {
      if (this.partiallyConsumedTab) {
        this.offset += 1;
        var charsToTab = 4 - this.column % 4;
        this.tip.stringContent += repeat(" ", charsToTab);
      }
      if (this.tip.lineOffsets) {
        this.tip.lineOffsets.push(this.offset);
      } else {
        this.tip.lineOffsets = [this.offset];
      }
      this.tip.stringContent += this.currentLine.slice(this.offset) + "\n";
    };
    Parser2.prototype.addChild = function(tag, offset2) {
      while (!blockHandlers[this.tip.type].canContain(tag)) {
        this.finalize(this.tip, this.lineNumber - 1);
      }
      var columnNumber = offset2 + 1;
      var newBlock = createNode$1(tag, [
        [this.lineNumber, columnNumber],
        [0, 0]
      ]);
      newBlock.stringContent = "";
      this.tip.appendChild(newBlock);
      this.tip = newBlock;
      return newBlock;
    };
    Parser2.prototype.closeUnmatchedBlocks = function() {
      if (!this.allClosed) {
        while (this.oldtip !== this.lastMatchedContainer) {
          var parent_1 = this.oldtip.parent;
          this.finalize(this.oldtip, this.lineNumber - 1);
          this.oldtip = parent_1;
        }
        this.allClosed = true;
      }
    };
    Parser2.prototype.finalize = function(block2, lineNumber) {
      var above = block2.parent;
      block2.open = false;
      block2.sourcepos[1] = [lineNumber, this.lastLineLength];
      blockHandlers[block2.type].finalize(this, block2);
      this.tip = above;
    };
    Parser2.prototype.processInlines = function(block2) {
      var event;
      var customParser = this.options.customParser;
      var walker = block2.walker();
      this.inlineParser.refMap = this.refMap;
      this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;
      this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;
      this.inlineParser.options = this.options;
      while (event = walker.next()) {
        var node4 = event.node, entering = event.entering;
        var t = node4.type;
        if (customParser && customParser[t]) {
          customParser[t](node4, { entering, options: this.options });
        }
        if (!entering && (t === "paragraph" || t === "heading" || t === "tableCell" && !node4.ignored)) {
          this.inlineParser.parse(node4);
        }
      }
    };
    Parser2.prototype.incorporateLine = function(ln) {
      var container = this.doc;
      this.oldtip = this.tip;
      this.offset = 0;
      this.column = 0;
      this.blank = false;
      this.partiallyConsumedTab = false;
      this.lineNumber += 1;
      if (ln.indexOf("\0") !== -1) {
        ln = ln.replace(/\0/g, "�");
      }
      this.currentLine = ln;
      var allMatched = true;
      var lastChild;
      while ((lastChild = container.lastChild) && lastChild.open) {
        container = lastChild;
        this.findNextNonspace();
        switch (blockHandlers[container.type]["continue"](this, container)) {
          case 0:
            break;
          case 1:
            allMatched = false;
            break;
          case 2:
            this.lastLineLength = ln.length;
            return;
          default:
            throw new Error("continue returned illegal value, must be 0, 1, or 2");
        }
        if (!allMatched) {
          container = container.parent;
          break;
        }
      }
      this.allClosed = container === this.oldtip;
      this.lastMatchedContainer = container;
      var matchedLeaf = container.type !== "paragraph" && blockHandlers[container.type].acceptsLines;
      var blockStartsLen = blockStarts.length;
      while (!matchedLeaf) {
        this.findNextNonspace();
        if (container.type !== "table" && container.type !== "tableBody" && container.type !== "paragraph" && !this.indented && !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {
          this.advanceNextNonspace();
          break;
        }
        var i = 0;
        while (i < blockStartsLen) {
          var res = blockStarts[i](this, container);
          if (res === 1) {
            container = this.tip;
            break;
          } else if (res === 2) {
            container = this.tip;
            matchedLeaf = true;
            break;
          } else {
            i++;
          }
        }
        if (i === blockStartsLen) {
          this.advanceNextNonspace();
          break;
        }
      }
      if (!this.allClosed && !this.blank && this.tip.type === "paragraph") {
        this.addLine();
      } else {
        this.closeUnmatchedBlocks();
        if (this.blank && container.lastChild) {
          container.lastChild.lastLineBlank = true;
        }
        var t = container.type;
        var lastLineBlank = this.blank && !(t === "blockQuote" || isCodeBlock(container) && container.isFenced || t === "item" && !container.firstChild && container.sourcepos[0][0] === this.lineNumber);
        var cont = container;
        while (cont) {
          cont.lastLineBlank = lastLineBlank;
          cont = cont.parent;
        }
        if (blockHandlers[t].acceptsLines) {
          this.addLine();
          if (isHtmlBlock(container) && container.htmlBlockType >= 1 && container.htmlBlockType <= 5 && reHtmlBlockClose[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {
            this.lastLineLength = ln.length;
            this.finalize(container, this.lineNumber);
          }
        } else if (this.offset < ln.length && !this.blank) {
          container = this.addChild("paragraph", this.offset);
          this.advanceNextNonspace();
          this.addLine();
        }
      }
      this.lastLineLength = ln.length;
    };
    Parser2.prototype.parse = function(input, lineTexts) {
      this.doc = document$2();
      this.tip = this.doc;
      this.lineNumber = 0;
      this.lastLineLength = 0;
      this.offset = 0;
      this.column = 0;
      this.lastMatchedContainer = this.doc;
      this.currentLine = "";
      var lines = input.split(reLineEnding$1);
      var len = lines.length;
      this.lines = lineTexts ? lineTexts : lines;
      if (this.options.referenceDefinition) {
        this.clearRefMaps();
      }
      if (input.charCodeAt(input.length - 1) === C_NEWLINE) {
        len -= 1;
      }
      for (var i = 0; i < len; i++) {
        this.incorporateLine(lines[i]);
      }
      while (this.tip) {
        this.finalize(this.tip, len);
      }
      this.processInlines(this.doc);
      return this.doc;
    };
    Parser2.prototype.partialParseStart = function(lineNumber, lines) {
      this.doc = document$2();
      this.tip = this.doc;
      this.lineNumber = lineNumber - 1;
      this.lastLineLength = 0;
      this.offset = 0;
      this.column = 0;
      this.lastMatchedContainer = this.doc;
      this.currentLine = "";
      var len = lines.length;
      for (var i = 0; i < len; i++) {
        this.incorporateLine(lines[i]);
      }
      return this.doc;
    };
    Parser2.prototype.partialParseExtends = function(lines) {
      for (var i = 0; i < lines.length; i++) {
        this.incorporateLine(lines[i]);
      }
    };
    Parser2.prototype.partialParseFinish = function() {
      while (this.tip) {
        this.finalize(this.tip, this.lineNumber);
      }
      this.processInlines(this.doc);
    };
    Parser2.prototype.setRefMaps = function(refMap, refLinkCandidateMap, refDefCandidateMap) {
      this.refMap = refMap;
      this.refLinkCandidateMap = refLinkCandidateMap;
      this.refDefCandidateMap = refDefCandidateMap;
    };
    Parser2.prototype.clearRefMaps = function() {
      [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(map14) {
        clearObj(map14);
      });
    };
    return Parser2;
  })()
);
function comparePos(p1, p2) {
  if (p1[0] < p2[0]) {
    return 1;
  }
  if (p1[0] > p2[0]) {
    return -1;
  }
  if (p1[1] < p2[1]) {
    return 1;
  }
  if (p1[1] > p2[1]) {
    return -1;
  }
  return 0;
}
function compareRangeAndPos(_a, pos) {
  var startPos = _a[0], endPos = _a[1];
  if (comparePos(endPos, pos) === 1) {
    return 1;
  }
  if (comparePos(startPos, pos) === -1) {
    return -1;
  }
  return 0;
}
function removeNextUntil(node4, last2) {
  if (node4.parent !== last2.parent || node4 === last2) {
    return;
  }
  var next = node4.next;
  while (next && next !== last2) {
    var temp = next.next;
    for (var _i = 0, _a = ["parent", "prev", "next"]; _i < _a.length; _i++) {
      var type = _a[_i];
      if (next[type]) {
        removeNodeById(next[type].id);
        next[type] = null;
      }
    }
    next = temp;
  }
  node4.next = last2.next;
  if (last2.next) {
    last2.next.prev = node4;
  } else {
    node4.parent.lastChild = node4;
  }
}
function getChildNodes(parent) {
  var nodes = [];
  var curr = parent.firstChild;
  while (curr) {
    nodes.push(curr);
    curr = curr.next;
  }
  return nodes;
}
function insertNodesBefore(target2, nodes) {
  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var node4 = nodes_1[_i];
    target2.insertBefore(node4);
  }
}
function prependChildNodes(parent, nodes) {
  for (var i = nodes.length - 1; i >= 0; i -= 1) {
    parent.prependChild(nodes[i]);
  }
}
function updateNextLineNumbers(base2, diff2) {
  if (!base2 || !base2.parent || diff2 === 0) {
    return;
  }
  var walker = base2.parent.walker();
  walker.resumeAt(base2, true);
  var event;
  while (event = walker.next()) {
    var node4 = event.node, entering = event.entering;
    if (entering) {
      node4.sourcepos[0][0] += diff2;
      node4.sourcepos[1][0] += diff2;
    }
  }
}
function compareRangeAndLine(_a, line) {
  var startPos = _a[0], endPos = _a[1];
  if (endPos[0] < line) {
    return 1;
  }
  if (startPos[0] > line) {
    return -1;
  }
  return 0;
}
function findChildNodeAtLine(parent, line) {
  var node4 = parent.firstChild;
  while (node4) {
    var comp2 = compareRangeAndLine(node4.sourcepos, line);
    if (comp2 === 0) {
      return node4;
    }
    if (comp2 === -1) {
      return node4.prev || node4;
    }
    node4 = node4.next;
  }
  return parent.lastChild;
}
function lastLeafNode(node4) {
  while (node4.lastChild) {
    node4 = node4.lastChild;
  }
  return node4;
}
function sameLineTopAncestor(node4) {
  while (node4.parent && node4.parent.type !== "document" && node4.parent.sourcepos[0][0] === node4.sourcepos[0][0]) {
    node4 = node4.parent;
  }
  return node4;
}
function findFirstNodeAtLine(parent, line) {
  var node4 = parent.firstChild;
  var prev = null;
  while (node4) {
    var comp2 = compareRangeAndLine(node4.sourcepos, line);
    if (comp2 === 0) {
      if (node4.sourcepos[0][0] === line || !node4.firstChild) {
        return node4;
      }
      prev = node4;
      node4 = node4.firstChild;
    } else if (comp2 === -1) {
      break;
    } else {
      prev = node4;
      node4 = node4.next;
    }
  }
  if (prev) {
    return sameLineTopAncestor(lastLeafNode(prev));
  }
  return null;
}
function findNodeAtPosition(parent, pos) {
  var node4 = parent;
  var prev = null;
  while (node4) {
    var comp2 = compareRangeAndPos(node4.sourcepos, pos);
    if (comp2 === 0) {
      if (node4.firstChild) {
        prev = node4;
        node4 = node4.firstChild;
      } else {
        return node4;
      }
    } else if (comp2 === -1) {
      return prev;
    } else if (node4.next) {
      node4 = node4.next;
    } else {
      return prev;
    }
  }
  return node4;
}
function findNodeById(id) {
  return getNodeById(id) || null;
}
function invokeNextUntil(callback, start3, end2) {
  if (end2 === void 0) {
    end2 = null;
  }
  if (start3) {
    var walker = start3.walker();
    while (start3 && start3 !== end2) {
      callback(start3);
      var next = walker.next();
      if (next) {
        start3 = next.node;
      } else {
        break;
      }
    }
  }
}
function isUnlinked(id) {
  var node4 = findNodeById(id);
  if (!node4) {
    return true;
  }
  while (node4 && node4.type !== "document") {
    if (!node4.parent && !node4.prev && !node4.next) {
      return true;
    }
    node4 = node4.parent;
  }
  return false;
}
var reLineEnding = /\r\n|\n|\r/;
function canBeContinuedListItem(lineText) {
  var spaceMatch = lineText.match(/^[ \t]+/);
  if (spaceMatch && (spaceMatch[0].length >= 2 || /\t/.test(spaceMatch[0]))) {
    return true;
  }
  var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;
  return reBulletListMarker.test(leftTrimmed) || reOrderedListMarker.test(leftTrimmed);
}
function canBeContinuedTableBody(lineText) {
  return !isBlank(lineText) && lineText.indexOf("|") !== -1;
}
function createRefDefState(node4) {
  var id = node4.id, title = node4.title, sourcepos = node4.sourcepos, dest = node4.dest;
  return {
    id,
    title,
    sourcepos,
    unlinked: false,
    destination: dest
  };
}
var ToastMark = (
  /** @class */
  (function() {
    function ToastMark2(contents, options) {
      this.refMap = {};
      this.refLinkCandidateMap = {};
      this.refDefCandidateMap = {};
      this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);
      this.parser = new Parser(options);
      this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);
      this.eventHandlerMap = { change: [] };
      contents = contents || "";
      this.lineTexts = contents.split(reLineEnding);
      this.root = this.parser.parse(contents, this.lineTexts);
    }
    ToastMark2.prototype.updateLineTexts = function(startPos, endPos, newText) {
      var _a;
      var startLine = startPos[0], startCol = startPos[1];
      var endLine = endPos[0], endCol = endPos[1];
      var newLines = newText.split(reLineEnding);
      var newLineLen = newLines.length;
      var startLineText = this.lineTexts[startLine - 1];
      var endLineText = this.lineTexts[endLine - 1];
      newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];
      newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);
      var removedLineLen = endLine - startLine + 1;
      (_a = this.lineTexts).splice.apply(_a, __spreadArray([startLine - 1, removedLineLen], newLines));
      return newLineLen - removedLineLen;
    };
    ToastMark2.prototype.updateRootNodeState = function() {
      if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
        this.root.lastLineBlank = true;
        this.root.sourcepos = [
          [1, 1],
          [1, 0]
        ];
        return;
      }
      if (this.root.lastChild) {
        this.root.lastLineBlank = this.root.lastChild.lastLineBlank;
      }
      var lineTexts = this.lineTexts;
      var idx = lineTexts.length - 1;
      while (lineTexts[idx] === "") {
        idx -= 1;
      }
      if (lineTexts.length - 2 > idx) {
        idx += 1;
      }
      this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];
    };
    ToastMark2.prototype.replaceRangeNodes = function(startNode, endNode, newNodes) {
      if (!startNode) {
        if (endNode) {
          insertNodesBefore(endNode, newNodes);
          removeNodeById(endNode.id);
          endNode.unlink();
        } else {
          prependChildNodes(this.root, newNodes);
        }
      } else {
        insertNodesBefore(startNode, newNodes);
        removeNextUntil(startNode, endNode);
        [startNode.id, endNode.id].forEach(function(id) {
          return removeNodeById(id);
        });
        startNode.unlink();
      }
    };
    ToastMark2.prototype.getNodeRange = function(startPos, endPos) {
      var startNode = findChildNodeAtLine(this.root, startPos[0]);
      var endNode = findChildNodeAtLine(this.root, endPos[0]);
      if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {
        endNode = endNode.next;
      }
      return [startNode, endNode];
    };
    ToastMark2.prototype.trigger = function(eventName, param) {
      this.eventHandlerMap[eventName].forEach(function(handler) {
        handler(param);
      });
    };
    ToastMark2.prototype.extendEndLine = function(line) {
      while (this.lineTexts[line] === "") {
        line += 1;
      }
      return line;
    };
    ToastMark2.prototype.parseRange = function(startNode, endNode, startLine, endLine) {
      if (startNode && startNode.prev && (isList(startNode.prev) && canBeContinuedListItem(this.lineTexts[startLine - 1]) || isTable(startNode.prev) && canBeContinuedTableBody(this.lineTexts[startLine - 1]))) {
        startNode = startNode.prev;
        startLine = startNode.sourcepos[0][0];
      }
      var editedLines = this.lineTexts.slice(startLine - 1, endLine);
      var root = this.parser.partialParseStart(startLine, editedLines);
      var nextNode = endNode ? endNode.next : this.root.firstChild;
      var lastChild = root.lastChild;
      var isOpenedLastChildCodeBlock = lastChild && isCodeBlock(lastChild) && lastChild.open;
      var isOpenedLastChildCustomBlock = lastChild && isCustomBlock(lastChild) && lastChild.open;
      var isLastChildList = lastChild && isList(lastChild);
      while ((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode || isLastChildList && nextNode && (nextNode.type === "list" || nextNode.sourcepos[0][1] >= 2)) {
        var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);
        this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));
        if (!startNode) {
          startNode = endNode;
        }
        endNode = nextNode;
        endLine = newEndLine;
        nextNode = nextNode.next;
      }
      this.parser.partialParseFinish();
      var newNodes = getChildNodes(root);
      return { newNodes, extStartNode: startNode, extEndNode: endNode };
    };
    ToastMark2.prototype.getRemovedNodeRange = function(extStartNode, extEndNode) {
      if (!extStartNode || extStartNode && isRefDef(extStartNode) || extEndNode && isRefDef(extEndNode)) {
        return null;
      }
      return {
        id: [extStartNode.id, extEndNode.id],
        line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1]
      };
    };
    ToastMark2.prototype.markDeletedRefMap = function(extStartNode, extEndNode) {
      var _this = this;
      if (!isEmptyObj(this.refMap)) {
        var markDeleted = function(node4) {
          if (isRefDef(node4)) {
            var refDefState = _this.refMap[node4.label];
            if (refDefState && node4.id === refDefState.id) {
              refDefState.unlinked = true;
            }
          }
        };
        if (extStartNode) {
          invokeNextUntil(markDeleted, extStartNode.parent, extEndNode);
        }
        if (extEndNode) {
          invokeNextUntil(markDeleted, extEndNode);
        }
      }
    };
    ToastMark2.prototype.replaceWithNewRefDefState = function(nodes) {
      var _this = this;
      if (!isEmptyObj(this.refMap)) {
        var replaceWith_1 = function(node4) {
          if (isRefDef(node4)) {
            var label = node4.label;
            var refDefState = _this.refMap[label];
            if (!refDefState || refDefState.unlinked) {
              _this.refMap[label] = createRefDefState(node4);
            }
          }
        };
        nodes.forEach(function(node4) {
          invokeNextUntil(replaceWith_1, node4);
        });
      }
    };
    ToastMark2.prototype.replaceWithRefDefCandidate = function() {
      var _this = this;
      if (!isEmptyObj(this.refDefCandidateMap)) {
        iterateObject(this.refDefCandidateMap, function(_, candidate) {
          var label = candidate.label, sourcepos = candidate.sourcepos;
          var refDefState = _this.refMap[label];
          if (!refDefState || refDefState.unlinked || refDefState.sourcepos[0][0] > sourcepos[0][0]) {
            _this.refMap[label] = createRefDefState(candidate);
          }
        });
      }
    };
    ToastMark2.prototype.getRangeWithRefDef = function(startLine, endLine, startNode, endNode, lineDiff) {
      if (this.referenceDefinition && !isEmptyObj(this.refMap)) {
        var prevNode = findChildNodeAtLine(this.root, startLine - 1);
        var nextNode = findChildNodeAtLine(this.root, endLine + 1);
        if (prevNode && isRefDef(prevNode) && prevNode !== startNode && prevNode !== endNode) {
          startNode = prevNode;
          startLine = startNode.sourcepos[0][0];
        }
        if (nextNode && isRefDef(nextNode) && nextNode !== startNode && nextNode !== endNode) {
          endNode = nextNode;
          endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);
        }
      }
      return [startNode, endNode, startLine, endLine];
    };
    ToastMark2.prototype.parse = function(startPos, endPos, lineDiff) {
      if (lineDiff === void 0) {
        lineDiff = 0;
      }
      var range2 = this.getNodeRange(startPos, endPos);
      var startNode = range2[0], endNode = range2[1];
      var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];
      var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);
      var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));
      var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;
      var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);
      var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;
      if (this.referenceDefinition) {
        this.markDeletedRefMap(extStartNode, extEndNode);
        this.replaceRangeNodes(extStartNode, extEndNode, newNodes);
        this.replaceWithNewRefDefState(newNodes);
      } else {
        this.replaceRangeNodes(extStartNode, extEndNode, newNodes);
      }
      return { nodes: newNodes, removedNodeRange, nextNode };
    };
    ToastMark2.prototype.parseRefLink = function() {
      var _this = this;
      var result2 = [];
      if (!isEmptyObj(this.refMap)) {
        iterateObject(this.refMap, function(label, value) {
          if (value.unlinked) {
            delete _this.refMap[label];
          }
          iterateObject(_this.refLinkCandidateMap, function(_, candidate) {
            var node4 = candidate.node, refLabel = candidate.refLabel;
            if (refLabel === label) {
              result2.push(_this.parse(node4.sourcepos[0], node4.sourcepos[1]));
            }
          });
        });
      }
      return result2;
    };
    ToastMark2.prototype.removeUnlinkedCandidate = function() {
      if (!isEmptyObj(this.refDefCandidateMap)) {
        [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(candidateMap) {
          iterateObject(candidateMap, function(id) {
            if (isUnlinked(id)) {
              delete candidateMap[id];
            }
          });
        });
      }
    };
    ToastMark2.prototype.editMarkdown = function(startPos, endPos, newText) {
      var lineDiff = this.updateLineTexts(startPos, endPos, newText);
      var parseResult = this.parse(startPos, endPos, lineDiff);
      var editResult = omit(parseResult, "nextNode");
      updateNextLineNumbers(parseResult.nextNode, lineDiff);
      this.updateRootNodeState();
      var result2 = [editResult];
      if (this.referenceDefinition) {
        this.removeUnlinkedCandidate();
        this.replaceWithRefDefCandidate();
        result2 = result2.concat(this.parseRefLink());
      }
      this.trigger("change", result2);
      return result2;
    };
    ToastMark2.prototype.getLineTexts = function() {
      return this.lineTexts;
    };
    ToastMark2.prototype.getRootNode = function() {
      return this.root;
    };
    ToastMark2.prototype.findNodeAtPosition = function(pos) {
      var node4 = findNodeAtPosition(this.root, pos);
      if (!node4 || node4 === this.root) {
        return null;
      }
      return node4;
    };
    ToastMark2.prototype.findFirstNodeAtLine = function(line) {
      return findFirstNodeAtLine(this.root, line);
    };
    ToastMark2.prototype.on = function(eventName, callback) {
      this.eventHandlerMap[eventName].push(callback);
    };
    ToastMark2.prototype.off = function(eventName, callback) {
      var handlers2 = this.eventHandlerMap[eventName];
      var idx = handlers2.indexOf(callback);
      handlers2.splice(idx, 1);
    };
    ToastMark2.prototype.findNodeById = function(id) {
      return findNodeById(id);
    };
    ToastMark2.prototype.removeAllNode = function() {
      removeAllNode();
    };
    return ToastMark2;
  })()
);
var disallowedTags = [
  "title",
  "textarea",
  "style",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "script",
  "plaintext"
];
var reDisallowedTag = new RegExp("<(/?(?:" + disallowedTags.join("|") + ")[^>]*>)", "ig");
function filterDisallowedTags(str) {
  if (reDisallowedTag.test(str)) {
    return str.replace(reDisallowedTag, function(_, group) {
      return "&lt;" + group;
    });
  }
  return str;
}
var baseConvertors$1 = {
  heading: function(node4, _a) {
    var entering = _a.entering;
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "h" + node4.level,
      outerNewLine: true
    };
  },
  text: function(node4) {
    return {
      type: "text",
      content: node4.literal
    };
  },
  softbreak: function(_, _a) {
    var options = _a.options;
    return {
      type: "html",
      content: options.softbreak
    };
  },
  linebreak: function() {
    return {
      type: "html",
      content: "<br />\n"
    };
  },
  emph: function(_, _a) {
    var entering = _a.entering;
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "em"
    };
  },
  strong: function(_, _a) {
    var entering = _a.entering;
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "strong"
    };
  },
  paragraph: function(node4, _a) {
    var _b;
    var entering = _a.entering;
    var grandparent = (_b = node4.parent) === null || _b === void 0 ? void 0 : _b.parent;
    if (grandparent && grandparent.type === "list") {
      if (grandparent.listData.tight) {
        return null;
      }
    }
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "p",
      outerNewLine: true
    };
  },
  thematicBreak: function() {
    return {
      type: "openTag",
      tagName: "hr",
      outerNewLine: true,
      selfClose: true
    };
  },
  blockQuote: function(_, _a) {
    var entering = _a.entering;
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "blockquote",
      outerNewLine: true,
      innerNewLine: true
    };
  },
  list: function(node4, _a) {
    var entering = _a.entering;
    var _b = node4.listData, type = _b.type, start3 = _b.start;
    var tagName = type === "bullet" ? "ul" : "ol";
    var attributes = {};
    if (tagName === "ol" && start3 !== null && start3 !== 1) {
      attributes.start = start3.toString();
    }
    return {
      type: entering ? "openTag" : "closeTag",
      tagName,
      attributes,
      outerNewLine: true
    };
  },
  item: function(_, _a) {
    var entering = _a.entering;
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "li",
      outerNewLine: true
    };
  },
  htmlInline: function(node4, _a) {
    var options = _a.options;
    var content2 = options.tagFilter ? filterDisallowedTags(node4.literal) : node4.literal;
    return { type: "html", content: content2 };
  },
  htmlBlock: function(node4, _a) {
    var options = _a.options;
    var content2 = options.tagFilter ? filterDisallowedTags(node4.literal) : node4.literal;
    if (options.nodeId) {
      return [
        { type: "openTag", tagName: "div", outerNewLine: true },
        { type: "html", content: content2 },
        { type: "closeTag", tagName: "div", outerNewLine: true }
      ];
    }
    return { type: "html", content: content2, outerNewLine: true };
  },
  code: function(node4) {
    return [
      { type: "openTag", tagName: "code" },
      { type: "text", content: node4.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(node4) {
    var infoStr = node4.info;
    var infoWords = infoStr ? infoStr.split(/\s+/) : [];
    var codeClassNames = [];
    if (infoWords.length > 0 && infoWords[0].length > 0) {
      codeClassNames.push("language-" + escapeXml(infoWords[0]));
    }
    return [
      { type: "openTag", tagName: "pre", outerNewLine: true },
      { type: "openTag", tagName: "code", classNames: codeClassNames },
      { type: "text", content: node4.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre", outerNewLine: true }
    ];
  },
  link: function(node4, _a) {
    var entering = _a.entering;
    if (entering) {
      var _b = node4, title = _b.title, destination = _b.destination;
      return {
        type: "openTag",
        tagName: "a",
        attributes: __assign2({ href: escapeXml(destination) }, title && { title: escapeXml(title) })
      };
    }
    return { type: "closeTag", tagName: "a" };
  },
  image: function(node4, _a) {
    var getChildrenText2 = _a.getChildrenText, skipChildren = _a.skipChildren;
    var _b = node4, title = _b.title, destination = _b.destination;
    skipChildren();
    return {
      type: "openTag",
      tagName: "img",
      selfClose: true,
      attributes: __assign2({ src: escapeXml(destination), alt: getChildrenText2(node4) }, title && { title: escapeXml(title) })
    };
  },
  customBlock: function(node4, context, convertors2) {
    var info = node4.info.trim().toLowerCase();
    var customConvertor = convertors2[info];
    if (customConvertor) {
      try {
        return customConvertor(node4, context);
      } catch (e) {
        console.warn("[@toast-ui/editor] - The error occurred when " + info + " block node was parsed in markdown renderer: " + e);
      }
    }
    return [
      { type: "openTag", tagName: "div", outerNewLine: true },
      { type: "text", content: node4.literal },
      { type: "closeTag", tagName: "div", outerNewLine: true }
    ];
  },
  frontMatter: function(node4) {
    return [
      {
        type: "openTag",
        tagName: "div",
        outerNewLine: true,
        // Because front matter is metadata, it should not be render.
        attributes: { style: "white-space: pre; display: none;" }
      },
      { type: "text", content: node4.literal },
      { type: "closeTag", tagName: "div", outerNewLine: true }
    ];
  },
  customInline: function(node4, context, convertors2) {
    var _a = node4, info = _a.info, firstChild = _a.firstChild;
    var nomalizedInfo = info.trim().toLowerCase();
    var customConvertor = convertors2[nomalizedInfo];
    var entering = context.entering;
    if (customConvertor) {
      try {
        return customConvertor(node4, context);
      } catch (e) {
        console.warn("[@toast-ui/editor] - The error occurred when " + nomalizedInfo + " inline node was parsed in markdown renderer: " + e);
      }
    }
    return entering ? [
      { type: "openTag", tagName: "span" },
      { type: "text", content: "$$" + info + (firstChild ? " " : "") }
    ] : [
      { type: "text", content: "$$" },
      { type: "closeTag", tagName: "span" }
    ];
  }
};
var gfmConvertors = {
  strike: function(_, _a) {
    var entering = _a.entering;
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "del"
    };
  },
  item: function(node4, _a) {
    var entering = _a.entering;
    var _b = node4.listData, checked = _b.checked, task2 = _b.task;
    if (entering) {
      var itemTag = {
        type: "openTag",
        tagName: "li",
        outerNewLine: true
      };
      if (task2) {
        return [
          itemTag,
          {
            type: "openTag",
            tagName: "input",
            selfClose: true,
            attributes: __assign2(__assign2({}, checked && { checked: "" }), { disabled: "", type: "checkbox" })
          },
          {
            type: "text",
            content: " "
          }
        ];
      }
      return itemTag;
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: true
    };
  },
  table: function(_, _a) {
    var entering = _a.entering;
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "table",
      outerNewLine: true
    };
  },
  tableHead: function(_, _a) {
    var entering = _a.entering;
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "thead",
      outerNewLine: true
    };
  },
  tableBody: function(_, _a) {
    var entering = _a.entering;
    return {
      type: entering ? "openTag" : "closeTag",
      tagName: "tbody",
      outerNewLine: true
    };
  },
  tableRow: function(node4, _a) {
    var entering = _a.entering;
    if (entering) {
      return {
        type: "openTag",
        tagName: "tr",
        outerNewLine: true
      };
    }
    var result2 = [];
    if (node4.lastChild) {
      var columnLen = node4.parent.parent.columns.length;
      var lastColIdx = node4.lastChild.endIdx;
      for (var i = lastColIdx + 1; i < columnLen; i += 1) {
        result2.push({
          type: "openTag",
          tagName: "td",
          outerNewLine: true
        }, {
          type: "closeTag",
          tagName: "td",
          outerNewLine: true
        });
      }
    }
    result2.push({
      type: "closeTag",
      tagName: "tr",
      outerNewLine: true
    });
    return result2;
  },
  tableCell: function(node4, _a) {
    var entering = _a.entering;
    if (node4.ignored) {
      return {
        type: "text",
        content: ""
      };
    }
    var tablePart = node4.parent.parent;
    var tagName = tablePart.type === "tableHead" ? "th" : "td";
    var table2 = tablePart.parent;
    var columnInfo = table2.columns[node4.startIdx];
    var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;
    if (entering) {
      return __assign2({ type: "openTag", tagName, outerNewLine: true }, attributes && { attributes });
    }
    return {
      type: "closeTag",
      tagName,
      outerNewLine: true
    };
  }
};
var defaultOptions = {
  softbreak: "\n",
  gfm: false,
  tagFilter: false,
  nodeId: false
};
function getChildrenText(node4) {
  var buffer = [];
  var walker = node4.walker();
  var event = null;
  while (event = walker.next()) {
    var node_1 = event.node;
    if (node_1.type === "text") {
      buffer.push(node_1.literal);
    }
  }
  return buffer.join("");
}
var Renderer = (
  /** @class */
  (function() {
    function Renderer2(customOptions) {
      this.buffer = [];
      this.options = __assign2(__assign2({}, defaultOptions), customOptions);
      this.convertors = this.createConvertors();
      delete this.options.convertors;
    }
    Renderer2.prototype.createConvertors = function() {
      var convertors2 = __assign2({}, baseConvertors$1);
      if (this.options.gfm) {
        convertors2 = __assign2(__assign2({}, convertors2), gfmConvertors);
      }
      if (this.options.convertors) {
        var customConvertors_1 = this.options.convertors;
        var nodeTypes = Object.keys(customConvertors_1);
        var defaultConvertors_1 = __assign2(__assign2({}, baseConvertors$1), gfmConvertors);
        nodeTypes.forEach(function(nodeType2) {
          var orgConvertor = convertors2[nodeType2];
          var convertor = customConvertors_1[nodeType2];
          var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType2) === -1 ? nodeType2.toLowerCase() : nodeType2;
          if (orgConvertor) {
            convertors2[convertorType] = function(node4, context, convertors3) {
              context.origin = function() {
                return orgConvertor(node4, context, convertors3);
              };
              return convertor(node4, context);
            };
          } else {
            convertors2[convertorType] = convertor;
          }
        });
      }
      return convertors2;
    };
    Renderer2.prototype.getConvertors = function() {
      return this.convertors;
    };
    Renderer2.prototype.getOptions = function() {
      return this.options;
    };
    Renderer2.prototype.render = function(rootNode) {
      var _this = this;
      this.buffer = [];
      var walker = rootNode.walker();
      var event = null;
      var _loop_1 = function() {
        var node4 = event.node, entering = event.entering;
        var convertor = this_1.convertors[node4.type];
        if (!convertor) {
          return "continue";
        }
        var skipped = false;
        var context = {
          entering,
          leaf: !isContainer$1(node4),
          options: this_1.options,
          getChildrenText,
          skipChildren: function() {
            skipped = true;
          }
        };
        var converted = isCustomBlock(node4) || isCustomInline(node4) ? convertor(node4, context, this_1.convertors) : convertor(node4, context);
        if (converted) {
          var htmlNodes = Array.isArray(converted) ? converted : [converted];
          htmlNodes.forEach(function(htmlNode, index3) {
            if (htmlNode.type === "openTag" && _this.options.nodeId && index3 === 0) {
              if (!htmlNode.attributes) {
                htmlNode.attributes = {};
              }
              htmlNode.attributes["data-nodeid"] = String(node4.id);
            }
            _this.renderHTMLNode(htmlNode);
          });
          if (skipped) {
            walker.resumeAt(node4, false);
            walker.next();
          }
        }
      };
      var this_1 = this;
      while (event = walker.next()) {
        _loop_1();
      }
      this.addNewLine();
      return this.buffer.join("");
    };
    Renderer2.prototype.renderHTMLNode = function(node4) {
      switch (node4.type) {
        case "openTag":
        case "closeTag":
          this.renderElementNode(node4);
          break;
        case "text":
          this.renderTextNode(node4);
          break;
        case "html":
          this.renderRawHtmlNode(node4);
          break;
      }
    };
    Renderer2.prototype.generateOpenTagString = function(node4) {
      var _this = this;
      var tagName = node4.tagName, classNames = node4.classNames, attributes = node4.attributes;
      this.buffer.push("<" + tagName);
      if (classNames && classNames.length > 0) {
        this.buffer.push(' class="' + classNames.join(" ") + '"');
      }
      if (attributes) {
        Object.keys(attributes).forEach(function(attrName) {
          var attrValue = attributes[attrName];
          _this.buffer.push(" " + attrName + '="' + attrValue + '"');
        });
      }
      if (node4.selfClose) {
        this.buffer.push(" /");
      }
      this.buffer.push(">");
    };
    Renderer2.prototype.generateCloseTagString = function(_a) {
      var tagName = _a.tagName;
      this.buffer.push("</" + tagName + ">");
    };
    Renderer2.prototype.addNewLine = function() {
      if (this.buffer.length && last(last(this.buffer)) !== "\n") {
        this.buffer.push("\n");
      }
    };
    Renderer2.prototype.addOuterNewLine = function(node4) {
      if (node4.outerNewLine) {
        this.addNewLine();
      }
    };
    Renderer2.prototype.addInnerNewLine = function(node4) {
      if (node4.innerNewLine) {
        this.addNewLine();
      }
    };
    Renderer2.prototype.renderTextNode = function(node4) {
      this.buffer.push(escapeXml(node4.content));
    };
    Renderer2.prototype.renderRawHtmlNode = function(node4) {
      this.addOuterNewLine(node4);
      this.buffer.push(node4.content);
      this.addOuterNewLine(node4);
    };
    Renderer2.prototype.renderElementNode = function(node4) {
      if (node4.type === "openTag") {
        this.addOuterNewLine(node4);
        this.generateOpenTagString(node4);
        if (node4.selfClose) {
          this.addOuterNewLine(node4);
        } else {
          this.addInnerNewLine(node4);
        }
      } else {
        this.addInnerNewLine(node4);
        this.generateCloseTagString(node4);
        this.addOuterNewLine(node4);
      }
    };
    return Renderer2;
  })()
);
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var hasOwnProperty = Object.hasOwnProperty;
var setPrototypeOf = Object.setPrototypeOf;
var isFrozen = Object.isFrozen;
var getPrototypeOf = Object.getPrototypeOf;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze;
var seal = Object.seal;
var create5 = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect;
var apply8 = _ref.apply;
var construct = _ref.construct;
if (!apply8) {
  apply8 = function apply9(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply8(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet2(set2, array) {
  if (setPrototypeOf) {
    setPrototypeOf(set2, null);
  }
  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === "string") {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function clone(object) {
  var newObject = create5(null);
  var property = void 0;
  for (property in object) {
    if (apply8(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }
  return newObject;
}
function lookupGetter(object, prop2) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop2);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html$2 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text2 = freeze(["#text"]);
var html$1$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
function _toConsumableArray$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root) {
    return createDOMPurify(root);
  };
  DOMPurify.version = "2.3.3";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node4 = window2.Node, Element2 = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, Text2 = window2.Text, Comment = window2.Comment, DOMParser3 = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element2.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes2 = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode2 = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone(document2).documentMode ? document2.documentMode : {};
  } catch (_) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode2 === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet2({}, [].concat(_toConsumableArray$1(html$2), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text2)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet2({}, [].concat(_toConsumableArray$1(html$1$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_DOM_IMPORT = true;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet2({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet2({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet2({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var PARSER_MEDIA_TYPE = void 0;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc = void 0;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet2({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet2({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet2(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet2(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet2({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet2({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet2({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x) {
      return x;
    } : stringToLowerCase;
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet2({}, [].concat(_toConsumableArray$1(text2)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet2(ALLOWED_TAGS, html$2);
        addToSet2(ALLOWED_ATTR, html$1$1);
      }
      if (USE_PROFILES.svg === true) {
        addToSet2(ALLOWED_TAGS, svg);
        addToSet2(ALLOWED_ATTR, svg$1);
        addToSet2(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet2(ALLOWED_TAGS, svgFilters);
        addToSet2(ALLOWED_ATTR, svg$1);
        addToSet2(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet2(ALLOWED_TAGS, mathMl);
        addToSet2(ALLOWED_ATTR, mathMl$1);
        addToSet2(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet2(ALLOWED_TAGS, cfg.ADD_TAGS);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet2(ALLOWED_ATTR, cfg.ADD_ATTR);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet2(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet2(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet2(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet2(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet2({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet2({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var ALL_SVG_TAGS = addToSet2({}, svg);
  addToSet2(ALL_SVG_TAGS, svgFilters);
  addToSet2(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet2({}, mathMl);
  addToSet2(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode2(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      var commonSvgAndHTMLElements = addToSet2({}, ["title", "style", "font", "a", "script"]);
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node4) {
    arrayPush(DOMPurify.removed, { element: node4 });
    try {
      node4.parentNode.removeChild(node4);
    } catch (_) {
      try {
        node4.outerHTML = emptyHTML;
      } catch (_2) {
        node4.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node4) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node4.getAttributeNode(name),
        from: node4
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node4
      });
    }
    node4.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node4);
        } catch (_) {
        }
      } else {
        try {
          node4.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc2 = void 0;
    var leadingWhitespace = void 0;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches4 = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches4 && matches4[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc2 = new DOMParser3().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {
      }
    }
    if (!doc2 || !doc2.documentElement) {
      doc2 = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc2.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
      } catch (_) {
      }
    }
    var body = doc2.body || doc2.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc2, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc2.documentElement : body;
  };
  var _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };
  var _isClobbered = function _isClobbered2(elm) {
    if (elm instanceof Text2 || elm instanceof Comment) {
      return false;
    }
    if (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function") {
      return true;
    }
    return false;
  };
  var _isNode = function _isNode2(object) {
    return (typeof Node4 === "undefined" ? "undefined" : _typeof(Node4)) === "object" ? object instanceof Node4 : object && (typeof object === "undefined" ? "undefined" : _typeof(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content2 = void 0;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode2 = getParentNode2(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes2(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode2) {
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode2.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content2 = currentNode.textContent;
      content2 = stringReplace(content2, MUSTACHE_EXPR$$1, " ");
      content2 = stringReplace(content2, ERB_EXPR$$1, " ");
      if (currentNode.textContent !== content2) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content2;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      return false;
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
    else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ""))) ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ""))) ;
    else if (!value) ;
    else {
      return false;
    }
    return true;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    while (l--) {
      attr = attributes[l];
      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value = stringTrim(attr.value);
      lcName = transformCaseFunc(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, " ");
        value = stringReplace(value, ERB_EXPR$$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) ;
    else if (dirty instanceof Node4) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : emptyHTML;
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (RETURN_DOM_IMPORT) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
var CAN_BE_WHITE_TAG_LIST = ["iframe", "embed"];
var whiteTagList = [];
function registerTagWhitelistIfPossible2(tagName) {
  if (includes2(CAN_BE_WHITE_TAG_LIST, tagName)) {
    whiteTagList.push(tagName.toLowerCase());
  }
}
function sanitizeHTML(html2, options) {
  return purify.sanitize(html2, __assign$1({ ADD_TAGS: whiteTagList, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
    "input",
    "script",
    "textarea",
    "form",
    "button",
    "select",
    "meta",
    "style",
    "link",
    "title",
    "object",
    "base"
  ] }, options));
}
function getChildrenHTML(node4, typeName) {
  return node4.literal.replace(new RegExp("(<\\s*" + typeName + "[^>]*>)|(</" + typeName + "\\s*[>])", "ig"), "").trim();
}
function getHTMLAttrsByHTMLString(html2) {
  html2 = html2.match(reHTMLTag)[0];
  var attrs = html2.match(new RegExp(ATTRIBUTE$1, "g"));
  return attrs ? attrs.reduce(function(acc, attr) {
    var _a = attr.trim().split("="), name = _a[0], values = _a.slice(1);
    if (values.length) {
      acc[name] = values.join("=").replace(/'|"/g, "").trim();
    }
    return acc;
  }, {}) : {};
}
function getHTMLAttrs(dom) {
  return toArray_1(dom.attributes).reduce(function(acc, attr) {
    acc[attr.nodeName] = attr.nodeValue;
    return acc;
  }, {});
}
function sanitizeDOM(node4, typeName, sanitizer, wwToDOMAdaptor) {
  var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node4);
  var html2 = sanitizer(dom.outerHTML);
  var container = document.createElement("div");
  container.innerHTML = html2;
  dom = container.firstChild;
  var htmlAttrs = getHTMLAttrs(dom);
  return { dom, htmlAttrs };
}
var schemaFactory = {
  htmlBlock: function(typeName, sanitizeHTML2, wwToDOMAdaptor) {
    return {
      atom: true,
      content: "block+",
      group: "block",
      attrs: {
        htmlAttrs: { default: {} },
        childrenHTML: { default: "" },
        htmlBlock: { default: true }
      },
      parseDOM: [
        {
          tag: typeName,
          getAttrs: function(dom) {
            return {
              htmlAttrs: getHTMLAttrs(dom),
              childrenHTML: dom.innerHTML
            };
          }
        }
      ],
      toDOM: function(node4) {
        var _a = sanitizeDOM(node4, typeName, sanitizeHTML2, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;
        htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + " html-block" : "html-block";
        return __spreadArray$1([typeName, htmlAttrs], toArray_1(dom.childNodes));
      }
    };
  },
  htmlInline: function(typeName, sanitizeHTML2, wwToDOMAdaptor) {
    return {
      attrs: {
        htmlAttrs: { default: {} },
        htmlInline: { default: true }
      },
      parseDOM: [
        {
          tag: typeName,
          getAttrs: function(dom) {
            return {
              htmlAttrs: getHTMLAttrs(dom)
            };
          }
        }
      ],
      toDOM: function(node4) {
        var htmlAttrs = sanitizeDOM(node4, typeName, sanitizeHTML2, wwToDOMAdaptor).htmlAttrs;
        return [typeName, htmlAttrs, 0];
      }
    };
  }
};
function createHTMLSchemaMap(convertorMap, sanitizeHTML2, wwToDOMAdaptor) {
  var htmlSchemaMap = { nodes: {}, marks: {} };
  ["htmlBlock", "htmlInline"].forEach(function(htmlType) {
    if (convertorMap[htmlType]) {
      Object.keys(convertorMap[htmlType]).forEach(function(type) {
        var targetType = htmlType === "htmlBlock" ? "nodes" : "marks";
        registerTagWhitelistIfPossible2(type);
        htmlSchemaMap[targetType][type] = schemaFactory[htmlType](type, sanitizeHTML2, wwToDOMAdaptor);
      });
    }
  });
  return htmlSchemaMap;
}
var reCloseTag = /^\s*<\s*\//;
var baseConvertors = {
  paragraph: function(_, _a) {
    var entering = _a.entering, origin = _a.origin, options = _a.options;
    if (options.nodeId) {
      return {
        type: entering ? "openTag" : "closeTag",
        outerNewLine: true,
        tagName: "p"
      };
    }
    return origin();
  },
  softbreak: function(node4) {
    var isPrevNodeHTML = node4.prev && node4.prev.type === "htmlInline";
    var isPrevBR = isPrevNodeHTML && /<br ?\/?>/.test(node4.prev.literal);
    var content2 = isPrevBR ? "\n" : "<br>\n";
    return { type: "html", content: content2 };
  },
  item: function(node4, _a) {
    var entering = _a.entering;
    if (entering) {
      var attributes = {};
      var classNames = [];
      if (node4.listData.task) {
        attributes["data-task"] = "";
        classNames.push("task-list-item");
        if (node4.listData.checked) {
          classNames.push("checked");
          attributes["data-task-checked"] = "";
        }
      }
      return {
        type: "openTag",
        tagName: "li",
        classNames,
        attributes,
        outerNewLine: true
      };
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: true
    };
  },
  code: function(node4) {
    var attributes = { "data-backticks": String(node4.tickCount) };
    return [
      { type: "openTag", tagName: "code", attributes },
      { type: "text", content: node4.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(node4) {
    var _a = node4, fenceLength = _a.fenceLength, info = _a.info;
    var infoWords = info ? info.split(/\s+/) : [];
    var preClasses = [];
    var codeAttrs = {};
    if (fenceLength > 3) {
      codeAttrs["data-backticks"] = fenceLength;
    }
    if (infoWords.length > 0 && infoWords[0].length > 0) {
      var lang2 = infoWords[0];
      preClasses.push("lang-" + lang2);
      codeAttrs["data-language"] = lang2;
    }
    return [
      { type: "openTag", tagName: "pre", classNames: preClasses },
      { type: "openTag", tagName: "code", attributes: codeAttrs },
      { type: "text", content: node4.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre" }
    ];
  },
  customInline: function(node4, _a) {
    var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;
    var info = node4.info;
    if (info.indexOf("widget") !== -1 && entering) {
      skipChildren();
      var content2 = getWidgetContent(node4);
      var htmlInline = widgetToDOM(info, content2).outerHTML;
      return [
        { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
        { type: "html", content: htmlInline },
        { type: "closeTag", tagName: "span" }
      ];
    }
    return origin();
  }
};
function getHTMLRenderConvertors(linkAttributes, customConvertors) {
  var convertors2 = __assign$1({}, baseConvertors);
  if (linkAttributes) {
    convertors2.link = function(_, _a) {
      var entering = _a.entering, origin = _a.origin;
      var result2 = origin();
      if (entering) {
        result2.attributes = __assign$1(__assign$1({}, result2.attributes), linkAttributes);
      }
      return result2;
    };
  }
  if (customConvertors) {
    Object.keys(customConvertors).forEach(function(nodeType2) {
      var orgConvertor = convertors2[nodeType2];
      var customConvertor = customConvertors[nodeType2];
      if (orgConvertor && isFunction_1(customConvertor)) {
        convertors2[nodeType2] = function(node4, context) {
          var newContext = __assign$1({}, context);
          newContext.origin = function() {
            return orgConvertor(node4, context);
          };
          return customConvertor(node4, newContext);
        };
      } else if (includes2(["htmlBlock", "htmlInline"], nodeType2) && !isFunction_1(customConvertor)) {
        convertors2[nodeType2] = function(node4, context) {
          var matched = node4.literal.match(reHTMLTag);
          if (matched) {
            var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];
            var typeName = (openTagName || closeTagName).toLowerCase();
            var htmlConvertor = customConvertor[typeName];
            var childrenHTML = getChildrenHTML(node4, typeName);
            if (htmlConvertor) {
              var newNode = __assign$1({}, node4);
              newNode.attrs = getHTMLAttrsByHTMLString(rootHTML);
              newNode.childrenHTML = childrenHTML;
              newNode.type = typeName;
              context.entering = !reCloseTag.test(node4.literal);
              return htmlConvertor(newNode, context);
            }
          }
          return context.origin();
        };
      } else {
        convertors2[nodeType2] = customConvertor;
      }
    });
  }
  return convertors2;
}
var nestableTypes = ["list", "item", "blockQuote"];
var nestableTagNames = ["UL", "OL", "BLOCKQUOTE"];
function isBlankLine(doc2, index3) {
  var _a;
  var pmNode = doc2.child(index3);
  return !pmNode.childCount || pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim());
}
function getEditorRangeHeightInfo(doc2, mdNode, children) {
  var start3 = getMdStartLine2(mdNode) - 1;
  var end2 = getMdEndLine2(mdNode) - 1;
  var rect2 = children[start3].getBoundingClientRect();
  var height = children[end2].offsetTop - children[start3].offsetTop + children[end2].clientHeight;
  return {
    height: height <= 0 ? children[start3].clientHeight : height + getBlankLinesHeight(doc2, children, Math.min(end2 + 1, doc2.childCount - 1)),
    rect: rect2
  };
}
function getBlankLinesHeight(doc2, children, start3) {
  var end2 = doc2.childCount - 1;
  var height = 0;
  while (start3 <= end2 && isBlankLine(doc2, start3)) {
    height += children[start3].clientHeight;
    start3 += 1;
  }
  return height;
}
function findAncestorHavingId(el2, root) {
  while (!el2.getAttribute("data-nodeid") && el2.parentElement !== root) {
    el2 = el2.parentElement;
  }
  return el2;
}
function getTotalOffsetTop2(el2, root) {
  var offsetTop = 0;
  while (el2 && el2 !== root) {
    if (!includes2(nestableTagNames, el2.tagName)) {
      offsetTop += el2.offsetTop;
    }
    if (el2.offsetParent === root.offsetParent) {
      break;
    }
    el2 = el2.parentElement;
  }
  return offsetTop;
}
function findAdjacentElementToScrollTop(scrollTop, root) {
  var el2 = root;
  var prev = null;
  while (el2) {
    var firstElementChild = el2.firstElementChild;
    if (!firstElementChild) {
      break;
    }
    var lastSibling = findLastSiblingElementToScrollTop(firstElementChild, scrollTop, getTotalOffsetTop2(el2, root));
    prev = el2;
    el2 = lastSibling;
  }
  var adjacentEl = el2 || prev;
  return adjacentEl === root ? null : adjacentEl;
}
function findLastSiblingElementToScrollTop(el2, scrollTop, offsetTop) {
  if (el2 && scrollTop > offsetTop + el2.offsetTop) {
    return findLastSiblingElementToScrollTop(el2.nextElementSibling, scrollTop, offsetTop) || el2;
  }
  return null;
}
function getAdditionalPos(scrollTop, offsetTop, height, targetNodeHeight) {
  var ratio2 = Math.min((scrollTop - offsetTop) / height, 1);
  return ratio2 * targetNodeHeight;
}
function getParentNodeObj(previewContent, mdNode) {
  var el2 = previewContent.querySelector('[data-nodeid="' + mdNode.id + '"]');
  while (!el2 || isStyledInlineNode2(mdNode)) {
    mdNode = mdNode.parent;
    el2 = previewContent.querySelector('[data-nodeid="' + mdNode.id + '"]');
  }
  return getNonNestableNodeObj({ mdNode, el: el2 });
}
function getNonNestableNodeObj(_a) {
  var mdNode = _a.mdNode, el2 = _a.el;
  while ((includes2(nestableTypes, mdNode.type) || mdNode.type === "table") && mdNode.firstChild) {
    mdNode = mdNode.firstChild;
    el2 = el2.firstElementChild;
  }
  return { mdNode, el: el2 };
}
var offsetInfoMap = {};
function setHeight(id, height) {
  offsetInfoMap[id] = offsetInfoMap[id] || {};
  offsetInfoMap[id].height = height;
}
function setOffsetTop(id, offsetTop) {
  offsetInfoMap[id] = offsetInfoMap[id] || {};
  offsetInfoMap[id].offsetTop = offsetTop;
}
function getHeight(id) {
  return offsetInfoMap[id] && offsetInfoMap[id].height;
}
function getOffsetTop(id) {
  return offsetInfoMap[id] && offsetInfoMap[id].offsetTop;
}
function removeOffsetInfoByNode(node4) {
  if (node4) {
    delete offsetInfoMap[Number(node4.getAttribute("data-nodeid"))];
    toArray_1(node4.children).forEach(function(child3) {
      removeOffsetInfoByNode(child3);
    });
  }
}
function getAndSaveOffsetInfo(node4, root, mdNodeId) {
  var cachedHeight = getHeight(mdNodeId);
  var cachedTop = getOffsetTop(mdNodeId);
  var nodeHeight = cachedHeight || node4.clientHeight;
  var offsetTop = cachedTop || getTotalOffsetTop2(node4, root) || node4.offsetTop;
  if (!cachedHeight) {
    setHeight(mdNodeId, nodeHeight);
  }
  if (!cachedTop) {
    setOffsetTop(mdNodeId, offsetTop);
  }
  return { nodeHeight, offsetTop };
}
var CLASS_HIGHLIGHT = cls("md-preview-highlight");
function findTableCell(tableRow2, chOffset) {
  var cell = tableRow2.firstChild;
  while (cell && cell.next) {
    if (getMdStartCh(cell.next) > chOffset + 1) {
      break;
    }
    cell = cell.next;
  }
  return cell;
}
var MarkdownPreview = (
  /** @class */
  (function() {
    function MarkdownPreview2(eventEmitter, options) {
      var el2 = document.createElement("div");
      this.el = el2;
      this.eventEmitter = eventEmitter;
      this.isViewer = !!options.isViewer;
      this.el.className = cls("md-preview");
      var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;
      this.renderer = new Renderer({
        gfm: true,
        nodeId: true,
        convertors: getHTMLRenderConvertors(linkAttributes, customHTMLRenderer)
      });
      this.cursorNodeId = null;
      this.sanitizer = sanitizer;
      this.initEvent(highlight);
      this.initContentSection();
      if (this.isViewer) {
        this.previewContent.style.overflowWrap = "break-word";
      }
    }
    MarkdownPreview2.prototype.initContentSection = function() {
      this.previewContent = createElementWith('<div class="' + cls("contents") + '"></div>');
      if (!this.isViewer) {
        this.el.appendChild(this.previewContent);
      }
    };
    MarkdownPreview2.prototype.toggleActive = function(active) {
      toggleClass(this.el, "active", active);
    };
    MarkdownPreview2.prototype.initEvent = function(highlight) {
      var _this = this;
      this.eventEmitter.listen("updatePreview", this.update.bind(this));
      if (this.isViewer) {
        return;
      }
      if (highlight) {
        this.eventEmitter.listen("changeToolbarState", function(_a) {
          var mdNode = _a.mdNode, cursorPos = _a.cursorPos;
          _this.updateCursorNode(mdNode, cursorPos);
        });
        this.eventEmitter.listen("blur", function() {
          _this.removeHighlight();
        });
      }
      on_1(this.el, "scroll", function(event) {
        _this.eventEmitter.emit("scroll", "preview", findAdjacentElementToScrollTop(event.target.scrollTop, _this.previewContent));
      });
      this.eventEmitter.listen("changePreviewTabPreview", function() {
        return _this.toggleActive(true);
      });
      this.eventEmitter.listen("changePreviewTabWrite", function() {
        return _this.toggleActive(false);
      });
    };
    MarkdownPreview2.prototype.removeHighlight = function() {
      if (this.cursorNodeId) {
        var currentEl = this.getElementByNodeId(this.cursorNodeId);
        if (currentEl) {
          removeClass_1(currentEl, CLASS_HIGHLIGHT);
        }
      }
    };
    MarkdownPreview2.prototype.updateCursorNode = function(cursorNode, cursorPos) {
      if (cursorNode) {
        cursorNode = findClosestNode(cursorNode, function(mdNode) {
          return !isInlineNode$1(mdNode);
        });
        if (cursorNode.type === "tableRow") {
          cursorNode = findTableCell(cursorNode, cursorPos[1]);
        } else if (cursorNode.type === "tableBody") {
          cursorNode = null;
        }
      }
      var cursorNodeId = cursorNode ? cursorNode.id : null;
      if (this.cursorNodeId === cursorNodeId) {
        return;
      }
      var oldEL = this.getElementByNodeId(this.cursorNodeId);
      var newEL = this.getElementByNodeId(cursorNodeId);
      if (oldEL) {
        removeClass_1(oldEL, CLASS_HIGHLIGHT);
      }
      if (newEL) {
        addClass_1(newEL, CLASS_HIGHLIGHT);
      }
      this.cursorNodeId = cursorNodeId;
    };
    MarkdownPreview2.prototype.getElementByNodeId = function(nodeId) {
      return nodeId ? this.previewContent.querySelector('[data-nodeid="' + nodeId + '"]') : null;
    };
    MarkdownPreview2.prototype.update = function(changed) {
      var _this = this;
      changed.forEach(function(editResult) {
        return _this.replaceRangeNodes(editResult);
      });
      this.eventEmitter.emit("afterPreviewRender", this);
    };
    MarkdownPreview2.prototype.replaceRangeNodes = function(editResult) {
      var _this = this;
      var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;
      var contentEl = this.previewContent;
      var newHtml = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(nodes.map(function(node4) {
        return _this.renderer.render(node4);
      }).join("")));
      if (!removedNodeRange) {
        contentEl.insertAdjacentHTML("afterbegin", newHtml);
      } else {
        var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];
        var startEl = this.getElementByNodeId(startNodeId);
        var endEl = this.getElementByNodeId(endNodeId);
        if (startEl) {
          startEl.insertAdjacentHTML("beforebegin", newHtml);
          var el2 = startEl;
          while (el2 && el2 !== endEl) {
            var nextEl = el2.nextElementSibling;
            removeNode$1(el2);
            removeOffsetInfoByNode(el2);
            el2 = nextEl;
          }
          if (el2 === null || el2 === void 0 ? void 0 : el2.parentNode) {
            removeNode$1(el2);
            removeOffsetInfoByNode(el2);
          }
        }
      }
    };
    MarkdownPreview2.prototype.getRenderer = function() {
      return this.renderer;
    };
    MarkdownPreview2.prototype.destroy = function() {
      off_1(this.el, "scroll");
      this.el = null;
    };
    MarkdownPreview2.prototype.getElement = function() {
      return this.el;
    };
    MarkdownPreview2.prototype.getHTML = function() {
      return this.previewContent.innerHTML;
    };
    MarkdownPreview2.prototype.setHTML = function(html2) {
      this.previewContent.innerHTML = html2;
    };
    MarkdownPreview2.prototype.setHeight = function(height) {
      css_1(this.el, { height: height + "px" });
    };
    MarkdownPreview2.prototype.setMinHeight = function(minHeight) {
      css_1(this.el, { minHeight: minHeight + "px" });
    };
    return MarkdownPreview2;
  })()
);
function findNodeBy(pos, condition) {
  var depth = pos.depth;
  while (depth) {
    var node4 = pos.node(depth);
    if (condition(node4, depth)) {
      return {
        node: node4,
        depth,
        offset: depth > 0 ? pos.before(depth) : 0
      };
    }
    depth -= 1;
  }
  return null;
}
function isInListNode(pos) {
  return !!findNodeBy(pos, function(_a) {
    var type = _a.type;
    return type.name === "listItem" || type.name === "bulletList" || type.name === "orderedList";
  });
}
function isInTableNode(pos) {
  return !!findNodeBy(pos, function(_a) {
    var type = _a.type;
    return type.name === "tableHeadCell" || type.name === "tableBodyCell";
  });
}
function findListItem(pos) {
  return findNodeBy(pos, function(_a) {
    var type = _a.type;
    return type.name === "listItem";
  });
}
function createDOMInfoParsedRawHTML(tag) {
  return {
    tag,
    getAttrs: function(dom) {
      var rawHTML = dom.getAttribute("data-raw-html");
      return __assign$1({}, rawHTML && { rawHTML });
    }
  };
}
function createCellAttrs(attrs) {
  return Object.keys(attrs).reduce(function(acc, attrName) {
    if (attrName !== "rawHTML" && attrs[attrName]) {
      attrName = attrName === "className" ? "class" : attrName;
      acc[attrName] = attrs[attrName];
    }
    return acc;
  }, {});
}
function createParsedCellDOM(tag) {
  return {
    tag,
    getAttrs: function(dom) {
      return ["rawHTML", "colspan", "rowspan", "extended"].reduce(function(acc, attrName) {
        var attrNameInDOM = attrName === "rawHTML" ? "data-raw-html" : attrName;
        var attrValue = dom.getAttribute(attrNameInDOM);
        if (attrValue) {
          acc[attrName] = includes2(["rawHTML", "extended"], attrName) ? attrValue : Number(attrValue);
        }
        return acc;
      }, {});
    }
  };
}
function getDefaultCustomAttrs() {
  return {
    htmlAttrs: { default: null },
    classNames: { default: null }
  };
}
function getCustomAttrs(attrs) {
  var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;
  return __assign$1(__assign$1({}, htmlAttrs), { class: classNames ? classNames.join(" ") : null });
}
function findWrappingOutside2(range2, type) {
  var parent = range2.parent, startIndex = range2.startIndex, endIndex = range2.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (around) {
    var outer = around.length ? around[0] : type;
    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
  }
  return null;
}
function findWrappingInside2(range2, type) {
  var parent = range2.parent, startIndex = range2.startIndex, endIndex = range2.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (inside) {
    var lastType = inside.length ? inside[inside.length - 1] : type;
    var innerMatch = lastType.contentMatch;
    for (var i = startIndex; innerMatch && i < endIndex; i += 1) {
      innerMatch = innerMatch.matchType(parent.child(i).type);
    }
    if (innerMatch && innerMatch.validEnd) {
      return inside;
    }
  }
  return null;
}
function findWrappers(range2, innerRange, nodeType2, attrs) {
  var around = findWrappingOutside2(range2, nodeType2);
  var inner = findWrappingInside2(innerRange, nodeType2);
  if (around && inner) {
    var aroundNodes = around.map(function(type) {
      return { type };
    });
    var innerNodes = inner.map(function(type) {
      return { type, attrs };
    });
    return aroundNodes.concat({ type: nodeType2 }).concat(innerNodes);
  }
  return null;
}
function wrapInList(tr, _a, wrappers, joinBefore, list2) {
  var start3 = _a.start, end2 = _a.end, startIndex = _a.startIndex, endIndex = _a.endIndex, parent = _a.parent;
  var content2 = Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i -= 1) {
    content2 = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content2));
  }
  tr.step(new ReplaceAroundStep(start3 - (joinBefore ? 2 : 0), end2, start3, end2, new Slice(content2, 0, 0), wrappers.length, true));
  var foundListIndex = 0;
  for (var i = 0; i < wrappers.length; i += 1) {
    if (wrappers[i].type === list2) {
      foundListIndex = i + 1;
      break;
    }
  }
  var splitDepth = wrappers.length - foundListIndex;
  var splitPos = start3 + wrappers.length - (joinBefore ? 2 : 0);
  for (var i = startIndex, len = endIndex; i < len; i += 1) {
    var first = i === startIndex;
    if (!first && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += splitDepth * 2;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr;
}
function changeToList(tr, range2, list2, attrs) {
  var $from = range2.$from, $to = range2.$to, depth = range2.depth;
  var outerRange = range2;
  var joinBefore = false;
  if (depth >= 2 && $from.node(depth - 1).type.compatibleContent(list2) && range2.startIndex === 0 && $from.index(depth - 1)) {
    var start3 = tr.doc.resolve(range2.start - 2);
    outerRange = new NodeRange(start3, start3, depth);
    if (range2.endIndex < range2.parent.childCount) {
      range2 = new NodeRange($from, tr.doc.resolve($to.end(depth)), depth);
    }
    joinBefore = true;
  }
  var wrappers = findWrappers(outerRange, range2, list2, attrs);
  if (wrappers) {
    return wrapInList(tr, range2, wrappers, joinBefore, list2);
  }
  return tr;
}
function getBeforeLineListItem(doc2, offset2) {
  var endListItemPos = doc2.resolve(offset2);
  while (endListItemPos.node().type.name !== "paragraph") {
    offset2 -= 2;
    endListItemPos = doc2.resolve(offset2);
  }
  return findListItem(endListItemPos);
}
function toggleTaskListItems(tr, _a) {
  var $from = _a.$from, $to = _a.$to;
  var startListItem = findListItem($from);
  var endListItem = findListItem($to);
  if (startListItem && endListItem) {
    while (endListItem) {
      var offset2 = endListItem.offset, node4 = endListItem.node;
      var attrs = { task: !node4.attrs.task, checked: false };
      tr.setNodeMarkup(offset2, null, attrs);
      if (offset2 === startListItem.offset) {
        break;
      }
      endListItem = getBeforeLineListItem(tr.doc, offset2);
    }
  }
  return tr;
}
function changeListType(tr, _a, list2) {
  var $from = _a.$from, $to = _a.$to;
  var startListItem = findListItem($from);
  var endListItem = findListItem($to);
  if (startListItem && endListItem) {
    while (endListItem) {
      var offset2 = endListItem.offset, node4 = endListItem.node, depth = endListItem.depth;
      if (node4.attrs.task) {
        tr.setNodeMarkup(offset2, null, { task: false, checked: false });
      }
      var resolvedPos = tr.doc.resolve(offset2);
      if (resolvedPos.parent.type !== list2) {
        var parentOffset = resolvedPos.before(depth - 1);
        tr.setNodeMarkup(parentOffset, list2);
      }
      if (offset2 === startListItem.offset) {
        break;
      }
      endListItem = getBeforeLineListItem(tr.doc, offset2);
    }
  }
  return tr;
}
function changeList(list2) {
  return function(_a, dispatch2) {
    var selection = _a.selection, tr = _a.tr;
    var $from = selection.$from, $to = selection.$to;
    var range2 = $from.blockRange($to);
    if (range2) {
      var newTr = isInListNode($from) ? changeListType(tr, range2, list2) : changeToList(tr, range2, list2);
      dispatch2(newTr);
      return true;
    }
    return false;
  };
}
function toggleTask() {
  return function(_a, dispatch2) {
    var selection = _a.selection, tr = _a.tr, schema = _a.schema;
    var $from = selection.$from, $to = selection.$to;
    var range2 = $from.blockRange($to);
    if (range2) {
      var newTr = isInListNode($from) ? toggleTaskListItems(tr, range2) : changeToList(tr, range2, schema.nodes.bulletList, { task: true });
      dispatch2(newTr);
      return true;
    }
    return false;
  };
}
function sinkListItem(listItem2) {
  return function(_a, dispatch2) {
    var tr = _a.tr, selection = _a.selection;
    var $from = selection.$from, $to = selection.$to;
    var range2 = $from.blockRange($to, function(_a2) {
      var childCount = _a2.childCount, firstChild = _a2.firstChild;
      return !!childCount && firstChild.type === listItem2;
    });
    if (range2 && range2.startIndex > 0) {
      var parent_1 = range2.parent;
      var nodeBefore = parent_1.child(range2.startIndex - 1);
      if (nodeBefore.type !== listItem2) {
        return false;
      }
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type === parent_1.type;
      var inner = nestedBefore ? Fragment.from(listItem2.create()) : null;
      var slice4 = new Slice(Fragment.from(listItem2.create(null, Fragment.from(parent_1.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      var before2 = range2.start;
      var after2 = range2.end;
      tr.step(new ReplaceAroundStep(before2 - (nestedBefore ? 3 : 1), after2, before2, after2, slice4, 1, true));
      dispatch2(tr);
      return true;
    }
    return false;
  };
}
function liftToOuterList(tr, range2, listItem2) {
  var $from = range2.$from, $to = range2.$to, end2 = range2.end, depth = range2.depth, parent = range2.parent;
  var endOfList = $to.end(depth);
  if (end2 < endOfList) {
    tr.step(new ReplaceAroundStep(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(listItem2.create(null, parent.copy())), 1, 0), 1, true));
    range2 = new NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), depth);
  }
  tr.lift(range2, liftTarget(range2));
  return tr;
}
function liftOutOfList(tr, range2) {
  var list2 = range2.parent;
  var pos = range2.end;
  for (var i = range2.endIndex - 1, len = range2.startIndex; i > len; i -= 1) {
    pos -= list2.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  var startPos = tr.doc.resolve(range2.start);
  var listItem2 = startPos.nodeAfter;
  var atStart2 = range2.startIndex === 0;
  var atEnd2 = range2.endIndex === list2.childCount;
  var parent = startPos.node(-1);
  var indexBefore = startPos.index(-1);
  var canReplaceParent = parent.canReplace(indexBefore + (atStart2 ? 0 : 1), indexBefore + 1, listItem2 === null || listItem2 === void 0 ? void 0 : listItem2.content.append(atEnd2 ? Fragment.empty : Fragment.from(list2)));
  if (listItem2 && canReplaceParent) {
    var start3 = startPos.pos;
    var end2 = start3 + listItem2.nodeSize;
    tr.step(new ReplaceAroundStep(start3 - (atStart2 ? 1 : 0), end2 + (atEnd2 ? 1 : 0), start3 + 1, end2 - 1, new Slice((atStart2 ? Fragment.empty : Fragment.from(list2.copy(Fragment.empty))).append(atEnd2 ? Fragment.empty : Fragment.from(list2.copy(Fragment.empty))), atStart2 ? 0 : 1, atEnd2 ? 0 : 1), atStart2 ? 0 : 1));
  }
  return tr;
}
function liftListItem(listItem2) {
  return function(_a, dispatch2) {
    var tr = _a.tr, selection = _a.selection;
    var $from = selection.$from, $to = selection.$to;
    var range2 = $from.blockRange($to, function(_a2) {
      var childCount = _a2.childCount, firstChild = _a2.firstChild;
      return !!childCount && firstChild.type === listItem2;
    });
    if (range2) {
      var topListItem = $from.node(range2.depth - 1).type === listItem2;
      var newTr = topListItem ? liftToOuterList(tr, range2, listItem2) : liftOutOfList(tr, range2);
      dispatch2(newTr);
      return true;
    }
    return false;
  };
}
function splitListItem(listItem2) {
  return function(_a, dispatch2) {
    var tr = _a.tr, selection = _a.selection;
    var $from = selection.$from, $to = selection.$to;
    if ($from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    var grandParent = $from.node(-1);
    if (grandParent.type !== listItem2) {
      return false;
    }
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      if ($from.depth === 2 || $from.node(-3).type !== listItem2 || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      var keepItem = $from.index(-1) > 0;
      var wrapper = Fragment.empty;
      for (var depth = $from.depth - (keepItem ? 1 : 2); depth >= $from.depth - 3; depth -= 1) {
        wrapper = Fragment.from($from.node(depth).copy(wrapper));
      }
      wrapper = wrapper.append(Fragment.from(listItem2.createAndFill()));
      tr.replace(keepItem ? $from.before() : $from.before(-1), $from.after(-3), new Slice(wrapper, keepItem ? 3 : 2, 2));
      tr.setSelection(Selection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));
      dispatch2(tr);
      return true;
    }
    var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var types = nextType && [null, { type: nextType }];
    tr.delete($from.pos, $to.pos);
    if (canSplit(tr.doc, $from.pos, 2, types)) {
      tr.split($from.pos, 2, types);
      dispatch2(tr);
      return true;
    }
    return false;
  };
}
function indent() {
  return function() {
    return function(state, dispatch2) {
      var selection = state.selection, schema = state.schema;
      var $from = selection.$from, $to = selection.$to;
      var range2 = $from.blockRange($to);
      if (range2 && isInListNode($from)) {
        return sinkListItem(schema.nodes.listItem)(state, dispatch2);
      }
      return false;
    };
  };
}
function outdent() {
  return function() {
    return function(state, dispatch2) {
      var selection = state.selection, schema = state.schema;
      var $from = selection.$from, $to = selection.$to;
      var range2 = $from.blockRange($to);
      if (range2 && isInListNode($from)) {
        return liftListItem(schema.nodes.listItem)(state, dispatch2);
      }
      return false;
    };
  };
}
function getWwCommands() {
  return {
    indent: indent(),
    outdent: outdent()
  };
}
var cache = /* @__PURE__ */ new Map();
var TableOffsetMap = (
  /** @class */
  (function() {
    function TableOffsetMap2(table2, tableRows, tableStartPos, rowInfo) {
      this.table = table2;
      this.tableRows = tableRows;
      this.tableStartPos = tableStartPos;
      this.rowInfo = rowInfo;
    }
    TableOffsetMap2.create = function(cellPos) {
      var table2 = findNodeBy(cellPos, function(_a) {
        var type = _a.type;
        return type.name === "table";
      });
      if (table2) {
        var node4 = table2.node, depth = table2.depth, offset2 = table2.offset;
        var cached = cache.get(node4);
        if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset2 + 1) {
          return cached;
        }
        var rows_1 = [];
        var tablePos = cellPos.start(depth);
        var thead = node4.child(0);
        var tbody = node4.child(1);
        var theadCellInfo = createOffsetMap(thead, tablePos);
        var tbodyCellInfo = createOffsetMap(tbody, tablePos + thead.nodeSize);
        thead.forEach(function(row) {
          return rows_1.push(row);
        });
        tbody.forEach(function(row) {
          return rows_1.push(row);
        });
        var map14 = new TableOffsetMap2(node4, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));
        cache.set(node4, map14);
        return map14;
      }
      return null;
    };
    Object.defineProperty(TableOffsetMap2.prototype, "totalRowCount", {
      get: function() {
        return this.rowInfo.length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TableOffsetMap2.prototype, "totalColumnCount", {
      get: function() {
        return this.rowInfo[0].length;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TableOffsetMap2.prototype, "tableStartOffset", {
      get: function() {
        return this.tableStartPos;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TableOffsetMap2.prototype, "tableEndOffset", {
      get: function() {
        return this.tableStartPos + this.table.nodeSize - 1;
      },
      enumerable: false,
      configurable: true
    });
    TableOffsetMap2.prototype.getCellInfo = function(rowIdx, colIdx) {
      return this.rowInfo[rowIdx][colIdx];
    };
    TableOffsetMap2.prototype.posAt = function(rowIdx, colIdx) {
      for (var i = 0, rowStart = this.tableStartPos; ; i += 1) {
        var rowEnd = rowStart + this.tableRows[i].nodeSize;
        if (i === rowIdx) {
          var index3 = colIdx;
          while (index3 < this.totalColumnCount && this.rowInfo[i][index3].offset < rowStart) {
            index3 += 1;
          }
          return index3 === this.totalColumnCount ? rowEnd : this.rowInfo[i][index3].offset;
        }
        rowStart = rowEnd;
      }
    };
    TableOffsetMap2.prototype.getNodeAndPos = function(rowIdx, colIdx) {
      var cellInfo = this.rowInfo[rowIdx][colIdx];
      return {
        node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),
        pos: cellInfo.offset
      };
    };
    TableOffsetMap2.prototype.extendedRowspan = function(rowIdx, colIdx) {
      return false;
    };
    TableOffsetMap2.prototype.extendedColspan = function(rowIdx, colIdx) {
      return false;
    };
    TableOffsetMap2.prototype.getRowspanCount = function(rowIdx, colIdx) {
      return 0;
    };
    TableOffsetMap2.prototype.getColspanCount = function(rowIdx, colIdx) {
      return 0;
    };
    TableOffsetMap2.prototype.decreaseColspanCount = function(rowIdx, colIdx) {
      return 0;
    };
    TableOffsetMap2.prototype.decreaseRowspanCount = function(rowIdx, colIdx) {
      return 0;
    };
    TableOffsetMap2.prototype.getColspanStartInfo = function(rowIdx, colIdx) {
      return null;
    };
    TableOffsetMap2.prototype.getRowspanStartInfo = function(rowIdx, colIdx) {
      return null;
    };
    TableOffsetMap2.prototype.getCellStartOffset = function(rowIdx, colIdx) {
      var offset2 = this.rowInfo[rowIdx][colIdx].offset;
      return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset2;
    };
    TableOffsetMap2.prototype.getCellEndOffset = function(rowIdx, colIdx) {
      var _a = this.rowInfo[rowIdx][colIdx], offset2 = _a.offset, nodeSize2 = _a.nodeSize;
      return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset2 + nodeSize2;
    };
    TableOffsetMap2.prototype.getCellIndex = function(cellPos) {
      for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {
        var rowInfo = this.rowInfo[rowIdx];
        for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {
          if (rowInfo[colIdx].offset + 1 > cellPos.pos) {
            return [rowIdx, colIdx];
          }
        }
      }
      return [0, 0];
    };
    TableOffsetMap2.prototype.getRectOffsets = function(startCellPos, endCellPos) {
      var _a, _b, _c;
      if (endCellPos === void 0) {
        endCellPos = startCellPos;
      }
      if (startCellPos.pos > endCellPos.pos) {
        _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];
      }
      var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];
      var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];
      _b = getSortedNumPair(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];
      _c = getSortedNumPair(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];
      return this.getSpannedOffsets({ startRowIdx, startColIdx, endRowIdx, endColIdx });
    };
    TableOffsetMap2.prototype.getSpannedOffsets = function(selectionInfo) {
      return selectionInfo;
    };
    return TableOffsetMap2;
  })()
);
var createOffsetMap = function(headOrBody, startOffset) {
  var cellInfoMatrix = [];
  headOrBody.forEach(function(row, rowOffset) {
    var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };
    row.forEach(function(_a, cellOffset) {
      var nodeSize2 = _a.nodeSize;
      var colIdx = 0;
      while (rowInfo[colIdx]) {
        colIdx += 1;
      }
      rowInfo[colIdx] = {
        // 2 is the sum of the front and back positions of the tag
        offset: startOffset + rowOffset + cellOffset + 2,
        nodeSize: nodeSize2
      };
      rowInfo.length += 1;
    });
    cellInfoMatrix.push(rowInfo);
  });
  return cellInfoMatrix;
};
function mixinTableOffsetMapPrototype(offsetMapMixin, createOffsetMapMixin) {
  assign(TableOffsetMap.prototype, offsetMapMixin);
  createOffsetMap = createOffsetMapMixin;
  return TableOffsetMap;
}
function getSelectionRanges(doc2, map14, _a) {
  var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;
  var ranges = [];
  for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {
    for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
      var _b = map14.getCellInfo(rowIdx, colIdx), offset2 = _b.offset, nodeSize2 = _b.nodeSize;
      ranges.push(new SelectionRange(doc2.resolve(offset2 + 1), doc2.resolve(offset2 + nodeSize2 - 1)));
    }
  }
  return ranges;
}
function createTableFragment(tableHead2, tableBody2) {
  var fragment = [];
  if (tableHead2.childCount) {
    fragment.push(tableHead2);
  }
  if (tableBody2.childCount) {
    fragment.push(tableBody2);
  }
  return Fragment.from(fragment);
}
var CellSelection = (
  /** @class */
  (function(_super) {
    __extends$1(CellSelection2, _super);
    function CellSelection2(startCellPos, endCellPos) {
      if (endCellPos === void 0) {
        endCellPos = startCellPos;
      }
      var _this = this;
      var doc2 = startCellPos.node(0);
      var map14 = TableOffsetMap.create(startCellPos);
      var selectionInfo = map14.getRectOffsets(startCellPos, endCellPos);
      var ranges = getSelectionRanges(doc2, map14, selectionInfo);
      _this = _super.call(this, ranges[0].$from, ranges[0].$to, ranges) || this;
      _this.startCell = startCellPos;
      _this.endCell = endCellPos;
      _this.offsetMap = map14;
      _this.isCellSelection = true;
      _this.visible = false;
      return _this;
    }
    CellSelection2.prototype.map = function(doc2, mapping) {
      var startPos = this.startCell.pos;
      var endPos = this.endCell.pos;
      var startCell = doc2.resolve(mapping.map(startPos));
      var endCell = doc2.resolve(mapping.map(endPos));
      var map14 = TableOffsetMap.create(startCell);
      if (this.offsetMap.totalColumnCount > map14.totalColumnCount || this.offsetMap.totalRowCount > map14.totalRowCount) {
        var depthMap = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 };
        var depthFromTable = depthMap[endCell.parent.type.name];
        var tableEndPos = endCell.end(endCell.depth - depthFromTable);
        var from4 = Math.min(tableEndPos - 4, endCell.pos);
        return TextSelection.create(doc2, from4);
      }
      return new CellSelection2(startCell, endCell);
    };
    CellSelection2.prototype.eq = function(cell) {
      return cell instanceof CellSelection2 && cell.startCell.pos === this.startCell.pos && cell.endCell.pos === this.endCell.pos;
    };
    CellSelection2.prototype.content = function() {
      var table2 = this.startCell.node(-2);
      var tableOffset = this.startCell.start(-2);
      var row = table2.child(1).firstChild;
      var tableHead2 = table2.child(0).type.create();
      var tableBody2 = table2.child(1).type.create();
      var map14 = TableOffsetMap.create(this.startCell);
      var selectionInfo = map14.getRectOffsets(this.startCell, this.endCell);
      var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;
      var isTableHeadCell = false;
      for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {
        var cells = [];
        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
          var offset2 = map14.getCellInfo(rowIdx, colIdx).offset;
          var cell = table2.nodeAt(offset2 - tableOffset);
          if (cell) {
            isTableHeadCell = cell.type.name === "tableHeadCell";
            if (map14.extendedRowspan(rowIdx, colIdx) || map14.extendedColspan(rowIdx, colIdx)) {
              cells.push(cell.type.create({ extended: true }));
            } else {
              cells.push(cell.copy(cell.content));
            }
          }
        }
        var copiedRow = row.copy(Fragment.from(cells));
        var targetNode = isTableHeadCell ? tableHead2 : tableBody2;
        targetNode.content = targetNode.content.append(Fragment.from(copiedRow));
      }
      return new Slice(createTableFragment(tableHead2, tableBody2), 1, 1);
    };
    return CellSelection2;
  })(Selection)
);
function createTableHeadRow(columnCount, schema, data) {
  var _a = schema.nodes, tableRow2 = _a.tableRow, tableHeadCell = _a.tableHeadCell, paragraph2 = _a.paragraph;
  var cells = [];
  for (var index3 = 0; index3 < columnCount; index3 += 1) {
    var text3 = data && data[index3];
    var para2 = paragraph2.create(null, text3 ? schema.text(text3) : []);
    cells.push(tableHeadCell.create(null, para2));
  }
  return [tableRow2.create(null, cells)];
}
function createTableBodyRows(rowCount, columnCount, schema, data) {
  var _a = schema.nodes, tableRow2 = _a.tableRow, tableBodyCell = _a.tableBodyCell, paragraph2 = _a.paragraph;
  var tableRows = [];
  for (var rowIdx = 0; rowIdx < rowCount; rowIdx += 1) {
    var cells = [];
    for (var colIdx = 0; colIdx < columnCount; colIdx += 1) {
      var text3 = data && data[rowIdx * columnCount + colIdx];
      var para2 = paragraph2.create(null, text3 ? schema.text(text3) : []);
      cells.push(tableBodyCell.create(null, para2));
    }
    tableRows.push(tableRow2.create(null, cells));
  }
  return tableRows;
}
function createDummyCells(columnCount, rowIdx, schema, attrs) {
  if (attrs === void 0) {
    attrs = null;
  }
  var _a = schema.nodes, tableHeadCell = _a.tableHeadCell, tableBodyCell = _a.tableBodyCell, paragraph2 = _a.paragraph;
  var cell = rowIdx === 0 ? tableHeadCell : tableBodyCell;
  var cells = [];
  for (var index3 = 0; index3 < columnCount; index3 += 1) {
    cells.push(cell.create(attrs, paragraph2.create()));
  }
  return cells;
}
function findCellElement(node4, root) {
  while (node4 && node4 !== root) {
    if (node4.nodeName === "TD" || node4.nodeName === "TH") {
      return node4;
    }
    node4 = node4.parentNode;
  }
  return null;
}
function findCell(pos) {
  return findNodeBy(pos, function(_a) {
    var type = _a.type;
    return type.name === "tableHeadCell" || type.name === "tableBodyCell";
  });
}
function getResolvedSelection(selection) {
  if (selection instanceof TextSelection) {
    var $anchor = selection.$anchor;
    var foundCell = findCell($anchor);
    if (foundCell) {
      var anchor = $anchor.node(0).resolve($anchor.before(foundCell.depth));
      return { anchor, head: anchor };
    }
  }
  var _a = selection, startCell = _a.startCell, endCell = _a.endCell;
  return { anchor: startCell, head: endCell };
}
function getTableContentFromSlice(slice4) {
  var _a;
  if (slice4.size) {
    var content2 = slice4.content, openStart = slice4.openStart, openEnd = slice4.openEnd;
    if (content2.childCount !== 1) {
      return null;
    }
    while (content2.childCount === 1 && (openStart > 0 && openEnd > 0 || ((_a = content2.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) === "table")) {
      openStart -= 1;
      openEnd -= 1;
      content2 = content2.firstChild.content;
    }
    if (content2.firstChild.type.name === "tableHead" || content2.firstChild.type.name === "tableBody") {
      return content2;
    }
  }
  return null;
}
function getRowAndColumnCount(_a) {
  var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;
  var rowCount = endRowIdx - startRowIdx + 1;
  var columnCount = endColIdx - startColIdx + 1;
  return { rowCount, columnCount };
}
function setAttrs(cell, attrs) {
  return __assign$1(__assign$1({}, cell.attrs), attrs);
}
var pluginKey = new PluginKey("cellSelection");
var MOUSE_RIGHT_BUTTON = 2;
var TableSelection = (
  /** @class */
  (function() {
    function TableSelection2(view) {
      this.view = view;
      this.handlers = {
        mousedown: this.handleMousedown.bind(this),
        mousemove: this.handleMousemove.bind(this),
        mouseup: this.handleMouseup.bind(this)
      };
      this.startCellPos = null;
      this.init();
    }
    TableSelection2.prototype.init = function() {
      this.view.dom.addEventListener("mousedown", this.handlers.mousedown);
    };
    TableSelection2.prototype.handleMousedown = function(ev) {
      var foundCell = findCellElement(ev.target, this.view.dom);
      if (ev.button === MOUSE_RIGHT_BUTTON) {
        ev.preventDefault();
        return;
      }
      if (foundCell) {
        var startCellPos = this.getCellPos(ev);
        if (startCellPos) {
          this.startCellPos = startCellPos;
        }
        this.bindEvent();
      }
    };
    TableSelection2.prototype.handleMousemove = function(ev) {
      var prevEndCellOffset = pluginKey.getState(this.view.state);
      var endCellPos = this.getCellPos(ev);
      var startCellPos = this.startCellPos;
      var prevEndCellPos;
      if (prevEndCellOffset) {
        prevEndCellPos = this.view.state.doc.resolve(prevEndCellOffset);
      } else if (startCellPos !== endCellPos) {
        prevEndCellPos = startCellPos;
      }
      if (prevEndCellPos && startCellPos && endCellPos) {
        this.setCellSelection(startCellPos, endCellPos);
      }
    };
    TableSelection2.prototype.handleMouseup = function() {
      this.startCellPos = null;
      this.unbindEvent();
      if (pluginKey.getState(this.view.state) !== null) {
        this.view.dispatch(this.view.state.tr.setMeta(pluginKey, -1));
      }
    };
    TableSelection2.prototype.bindEvent = function() {
      var dom = this.view.dom;
      dom.addEventListener("mousemove", this.handlers.mousemove);
      dom.addEventListener("mouseup", this.handlers.mouseup);
    };
    TableSelection2.prototype.unbindEvent = function() {
      var dom = this.view.dom;
      dom.removeEventListener("mousemove", this.handlers.mousemove);
      dom.removeEventListener("mouseup", this.handlers.mouseup);
    };
    TableSelection2.prototype.getCellPos = function(_a) {
      var clientX = _a.clientX, clientY = _a.clientY;
      var mousePos = this.view.posAtCoords({ left: clientX, top: clientY });
      if (mousePos) {
        var doc2 = this.view.state.doc;
        var currentPos = doc2.resolve(mousePos.pos);
        var foundCell = findCell(currentPos);
        if (foundCell) {
          var cellOffset = currentPos.before(foundCell.depth);
          return doc2.resolve(cellOffset);
        }
      }
      return null;
    };
    TableSelection2.prototype.setCellSelection = function(startCellPos, endCellPos) {
      var _a = this.view.state, selection = _a.selection, tr = _a.tr;
      var starting = pluginKey.getState(this.view.state) === null;
      var cellSelection = new CellSelection(startCellPos, endCellPos);
      if (starting || !selection.eq(cellSelection)) {
        var newTr = tr.setSelection(cellSelection);
        if (starting) {
          newTr.setMeta(pluginKey, endCellPos.pos);
        }
        this.view.dispatch(newTr);
      }
    };
    TableSelection2.prototype.destroy = function() {
      this.view.dom.removeEventListener("mousedown", this.handlers.mousedown);
    };
    return TableSelection2;
  })()
);
var SELECTED_CELL_CLASS_NAME = cls("cell-selected");
function drawCellSelection(_a) {
  var selection = _a.selection, doc2 = _a.doc;
  if (selection instanceof CellSelection) {
    var cells_1 = [];
    var ranges = selection.ranges;
    ranges.forEach(function(_a2) {
      var $from = _a2.$from, $to = _a2.$to;
      cells_1.push(Decoration.node($from.pos - 1, $to.pos + 1, { class: SELECTED_CELL_CLASS_NAME }));
    });
    return DecorationSet.create(doc2, cells_1);
  }
  return null;
}
function tableSelection() {
  return new Plugin({
    key: pluginKey,
    state: {
      init: function() {
        return null;
      },
      apply: function(tr, value) {
        var cellOffset = tr.getMeta(pluginKey);
        if (cellOffset) {
          return cellOffset === -1 ? null : cellOffset;
        }
        if (isNull_1(value) || !tr.docChanged) {
          return value;
        }
        var _a = tr.mapping.mapResult(value), deleted = _a.deleted, pos = _a.pos;
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      createSelectionBetween: function(_a) {
        var state = _a.state;
        if (!isNull_1(pluginKey.getState(state))) {
          return state.selection;
        }
        return null;
      }
    },
    view: function(editorView) {
      return new TableSelection(editorView);
    }
  });
}
var Map$1 = (
  /** @class */
  (function() {
    function Map2() {
      this.keys = [];
      this.values = [];
    }
    Map2.prototype.getKeyIndex = function(key) {
      return inArray_1(key, this.keys);
    };
    Map2.prototype.get = function(key) {
      return this.values[this.getKeyIndex(key)];
    };
    Map2.prototype.set = function(key, value) {
      var keyIndex = this.getKeyIndex(key);
      if (keyIndex > -1) {
        this.values[keyIndex] = value;
      } else {
        this.keys.push(key);
        this.values.push(value);
      }
      return this;
    };
    Map2.prototype.has = function(key) {
      return this.getKeyIndex(key) > -1;
    };
    Map2.prototype.delete = function(key) {
      var keyIndex = this.getKeyIndex(key);
      if (keyIndex > -1) {
        this.keys.splice(keyIndex, 1);
        this.values.splice(keyIndex, 1);
        return true;
      }
      return false;
    };
    Map2.prototype.forEach = function(callback, thisArg) {
      var _this = this;
      if (thisArg === void 0) {
        thisArg = this;
      }
      this.values.forEach(function(value, index3) {
        if (value && _this.keys[index3]) {
          callback.call(thisArg, value, _this.keys[index3], _this);
        }
      });
    };
    Map2.prototype.clear = function() {
      this.keys = [];
      this.values = [];
    };
    return Map2;
  })()
);
var DEFAULT_CODE = "en-US";
var I18n = (
  /** @class */
  (function() {
    function I18n2() {
      this.code = DEFAULT_CODE;
      this.langs = new Map$1();
    }
    I18n2.prototype.setCode = function(code2) {
      this.code = code2 || DEFAULT_CODE;
    };
    I18n2.prototype.setLanguage = function(codes, data) {
      var _this = this;
      codes = [].concat(codes);
      codes.forEach(function(code2) {
        if (!_this.langs.has(code2)) {
          _this.langs.set(code2, data);
        } else {
          var langData = _this.langs.get(code2);
          _this.langs.set(code2, extend_1(langData, data));
        }
      });
    };
    I18n2.prototype.get = function(key, code2) {
      if (!code2) {
        code2 = this.code;
      }
      var langSet = this.langs.get(code2);
      if (!langSet) {
        langSet = this.langs.get(DEFAULT_CODE);
      }
      var text3 = langSet[key];
      if (!text3) {
        throw new Error('There is no text key "' + key + '" in ' + code2);
      }
      return text3;
    };
    return I18n2;
  })()
);
var i18n = new I18n();
var contextMenuGroups = [
  [
    {
      action: "Add row to up",
      command: "addRowToUp",
      disableInThead: true,
      className: "add-row-up"
    },
    {
      action: "Add row to down",
      command: "addRowToDown",
      disableInThead: true,
      className: "add-row-down"
    },
    { action: "Remove row", command: "removeRow", disableInThead: true, className: "remove-row" }
  ],
  [
    { action: "Add column to left", command: "addColumnToLeft", className: "add-column-left" },
    { action: "Add column to right", command: "addColumnToRight", className: "add-column-right" },
    { action: "Remove column", command: "removeColumn", className: "remove-column" }
  ],
  [
    {
      action: "Align column to left",
      command: "alignColumn",
      payload: { align: "left" },
      className: "align-column-left"
    },
    {
      action: "Align column to center",
      command: "alignColumn",
      payload: { align: "center" },
      className: "align-column-center"
    },
    {
      action: "Align column to right",
      command: "alignColumn",
      payload: { align: "right" },
      className: "align-column-right"
    }
  ],
  [{ action: "Remove table", command: "removeTable", className: "remove-table" }]
];
function getContextMenuGroups(eventEmitter, inTableHead) {
  return contextMenuGroups.map(function(contextMenuGroup) {
    return contextMenuGroup.map(function(_a) {
      var action = _a.action, command = _a.command, payload = _a.payload, disableInThead = _a.disableInThead, className = _a.className;
      return {
        label: i18n.get(action),
        onClick: function() {
          eventEmitter.emit("command", command, payload);
        },
        disabled: inTableHead && !!disableInThead,
        className
      };
    });
  }).concat();
}
function tableContextMenu(eventEmitter) {
  return new Plugin({
    props: {
      handleDOMEvents: {
        contextmenu: function(view, ev) {
          var tableCell2 = findCellElement(ev.target, view.dom);
          if (tableCell2) {
            ev.preventDefault();
            var _a = ev, clientX = _a.clientX, clientY = _a.clientY;
            var _b = view.dom.parentNode.getBoundingClientRect(), left = _b.left, top_1 = _b.top;
            var inTableHead = tableCell2.nodeName === "TH";
            eventEmitter.emit("contextmenu", {
              pos: { left: clientX - left + 10 + "px", top: clientY - top_1 + 30 + "px" },
              menuGroups: getContextMenuGroups(eventEmitter, inTableHead),
              tableCell: tableCell2
            });
            return true;
          }
          return false;
        }
      }
    }
  });
}
function task() {
  return new Plugin({
    props: {
      handleDOMEvents: {
        mousedown: function(view, ev) {
          var _a = ev, clientX = _a.clientX, clientY = _a.clientY;
          var mousePos = view.posAtCoords({ left: clientX, top: clientY });
          if (mousePos) {
            var _b = view.state, doc2 = _b.doc, tr = _b.tr;
            var currentPos = doc2.resolve(mousePos.pos);
            var listItem2 = findListItem(currentPos);
            var target2 = ev.target;
            var style = getComputedStyle(target2, ":before");
            var _c = ev, offsetX = _c.offsetX, offsetY = _c.offsetY;
            if (!listItem2 || !isPositionInBox(style, offsetX, offsetY)) {
              return false;
            }
            ev.preventDefault();
            var offset2 = currentPos.before(listItem2.depth);
            var attrs = listItem2.node.attrs;
            tr.setNodeMarkup(offset2, null, __assign$1(__assign$1({}, attrs), { checked: !attrs.checked }));
            view.dispatch(tr);
            return true;
          }
          return false;
        }
      }
    }
  });
}
var EXCEPT_TYPES = ["image", "link", "customBlock", "frontMatter"];
var MARK_TYPES = ["strong", "strike", "emph", "code"];
var LIST_TYPES = ["bulletList", "orderedList", "taskList"];
function getToolbarStateType(node4, parentNode2) {
  var type = node4.type.name;
  if (type === "listItem") {
    return node4.attrs.task ? "taskList" : parentNode2.type.name;
  }
  if (type.indexOf("table") !== -1) {
    return "table";
  }
  return type;
}
function setListNodeToolbarState(type, nodeTypeState) {
  nodeTypeState[type] = { active: true };
  LIST_TYPES.filter(function(listName) {
    return listName !== type;
  }).forEach(function(listType) {
    if (nodeTypeState[listType]) {
      delete nodeTypeState[listType];
    }
  });
}
function setMarkTypeStates(from4, to, schema, toolbarState) {
  MARK_TYPES.forEach(function(type) {
    var mark3 = schema.marks[type];
    var marksAtPos = from4.marksAcross(to) || [];
    var foundMark = !!mark3.isInSet(marksAtPos);
    if (foundMark) {
      toolbarState[type] = { active: true };
    }
  });
}
function getToolbarState(selection, doc2, schema) {
  var $from = selection.$from, $to = selection.$to, from4 = selection.from, to = selection.to;
  var toolbarState = {
    indent: { active: false, disabled: true },
    outdent: { active: false, disabled: true }
  };
  doc2.nodesBetween(from4, to, function(node4, _, parentNode2) {
    var type = getToolbarStateType(node4, parentNode2);
    if (includes2(EXCEPT_TYPES, type)) {
      return;
    }
    if (includes2(LIST_TYPES, type)) {
      setListNodeToolbarState(type, toolbarState);
      toolbarState.indent.disabled = false;
      toolbarState.outdent.disabled = false;
    } else if (type === "paragraph" || type === "text") {
      setMarkTypeStates($from, $to, schema, toolbarState);
    } else {
      toolbarState[type] = { active: true };
    }
  });
  return toolbarState;
}
function toolbarStateHighlight(eventEmitter) {
  return new Plugin({
    view: function() {
      return {
        update: function(view) {
          var _a = view.state, selection = _a.selection, doc2 = _a.doc, schema = _a.schema;
          eventEmitter.emit("changeToolbarState", {
            toolbarState: getToolbarState(selection, doc2, schema)
          });
        }
      };
    }
  });
}
var CustomBlockView = (
  /** @class */
  (function() {
    function CustomBlockView2(node4, view, getPos, toDOMAdaptor) {
      var _this = this;
      this.openEditor = function() {
        if (_this.innerEditorView) {
          throw new Error("The editor is already opened.");
        }
        _this.dom.draggable = false;
        _this.wrapper.style.display = "none";
        _this.innerViewContainer.style.display = "block";
        _this.innerEditorView = new EditorView(_this.innerViewContainer, {
          state: EditorState.create({
            doc: _this.node,
            plugins: [
              keymap({
                "Mod-z": function() {
                  return undo(_this.innerEditorView.state, _this.innerEditorView.dispatch);
                },
                "Shift-Mod-z": function() {
                  return redo(_this.innerEditorView.state, _this.innerEditorView.dispatch);
                },
                Tab: function(state, dispatch2) {
                  dispatch2(state.tr.insertText("	"));
                  return true;
                },
                Enter: newlineInCode,
                Escape: function() {
                  _this.cancelEditing();
                  return true;
                },
                "Ctrl-Enter": function() {
                  _this.saveAndFinishEditing();
                  return true;
                }
              }),
              history()
            ]
          }),
          dispatchTransaction: function(tr) {
            return _this.dispatchInner(tr);
          },
          handleDOMEvents: {
            mousedown: function() {
              if (_this.editorView.hasFocus()) {
                _this.innerEditorView.focus();
              }
              return true;
            },
            blur: function() {
              _this.saveAndFinishEditing();
              return true;
            }
          }
        });
        _this.innerEditorView.focus();
      };
      this.node = node4;
      this.editorView = view;
      this.getPos = getPos;
      this.toDOMAdaptor = toDOMAdaptor;
      this.innerEditorView = null;
      this.canceled = false;
      this.dom = document.createElement("div");
      this.dom.className = cls("custom-block");
      this.wrapper = document.createElement("div");
      this.wrapper.className = cls("custom-block-view");
      this.createInnerViewContainer();
      this.renderCustomBlock();
      this.dom.appendChild(this.innerViewContainer);
      this.dom.appendChild(this.wrapper);
    }
    CustomBlockView2.prototype.renderToolArea = function() {
      var _this = this;
      var tool = document.createElement("div");
      var span = document.createElement("span");
      var button = document.createElement("button");
      tool.className = "tool";
      span.textContent = this.node.attrs.info;
      span.className = "info";
      button.type = "button";
      button.addEventListener("click", function() {
        return _this.openEditor();
      });
      tool.appendChild(span);
      tool.appendChild(button);
      this.wrapper.appendChild(tool);
    };
    CustomBlockView2.prototype.renderCustomBlock = function() {
      var toDOMNode = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);
      if (toDOMNode) {
        var node4 = toDOMNode(this.node);
        while (this.wrapper.hasChildNodes()) {
          this.wrapper.removeChild(this.wrapper.lastChild);
        }
        if (node4) {
          this.wrapper.appendChild(node4);
        }
        this.renderToolArea();
      }
    };
    CustomBlockView2.prototype.createInnerViewContainer = function() {
      this.innerViewContainer = document.createElement("div");
      this.innerViewContainer.className = cls("custom-block-editor");
      this.innerViewContainer.style.display = "none";
    };
    CustomBlockView2.prototype.closeEditor = function() {
      if (this.innerEditorView) {
        this.innerEditorView.destroy();
        this.innerEditorView = null;
        this.innerViewContainer.style.display = "none";
      }
      this.wrapper.style.display = "block";
    };
    CustomBlockView2.prototype.saveAndFinishEditing = function() {
      var to = this.editorView.state.selection.to;
      var outerState = this.editorView.state;
      this.editorView.dispatch(outerState.tr.setSelection(createTextSelection(outerState.tr, to)));
      this.editorView.focus();
      this.renderCustomBlock();
      this.closeEditor();
    };
    CustomBlockView2.prototype.cancelEditing = function() {
      var undoableCount = undoDepth(this.innerEditorView.state);
      this.canceled = true;
      while (undoableCount--) {
        undo(this.innerEditorView.state, this.innerEditorView.dispatch);
        undo(this.editorView.state, this.editorView.dispatch);
      }
      this.canceled = false;
      var to = this.editorView.state.selection.to;
      var outerState = this.editorView.state;
      this.editorView.dispatch(outerState.tr.setSelection(TextSelection.create(outerState.doc, to)));
      this.editorView.focus();
      this.closeEditor();
    };
    CustomBlockView2.prototype.dispatchInner = function(tr) {
      var _a = this.innerEditorView.state.applyTransaction(tr), state = _a.state, transactions = _a.transactions;
      this.innerEditorView.updateState(state);
      if (!this.canceled && isFunction_1(this.getPos)) {
        var outerTr = this.editorView.state.tr;
        var offsetMap = StepMap.offset(this.getPos() + 1);
        for (var i = 0; i < transactions.length; i += 1) {
          var steps = transactions[i].steps;
          for (var j = 0; j < steps.length; j += 1) {
            outerTr.step(steps[j].map(offsetMap));
          }
        }
        if (outerTr.docChanged) {
          this.editorView.dispatch(outerTr);
        }
      }
    };
    CustomBlockView2.prototype.update = function(node4) {
      if (!node4.sameMarkup(this.node)) {
        return false;
      }
      this.node = node4;
      if (!this.innerEditorView) {
        this.renderCustomBlock();
      }
      return true;
    };
    CustomBlockView2.prototype.stopEvent = function(event) {
      return !!this.innerEditorView && !!event.target && this.innerEditorView.dom.contains(event.target);
    };
    CustomBlockView2.prototype.ignoreMutation = function() {
      return true;
    };
    CustomBlockView2.prototype.destroy = function() {
      this.dom.removeEventListener("dblclick", this.openEditor);
      this.closeEditor();
    };
    return CustomBlockView2;
  })()
);
var IMAGE_LINK_CLASS_NAME = "image-link";
var ImageView = (
  /** @class */
  (function() {
    function ImageView2(node4, view, getPos, eventEmitter) {
      var _this = this;
      var _a;
      this.handleMousedown = function(ev) {
        ev.preventDefault();
        var target2 = ev.target, offsetX = ev.offsetX, offsetY = ev.offsetY;
        if (_this.imageLink && isFunction_1(_this.getPos) && hasClass_1(target2, IMAGE_LINK_CLASS_NAME)) {
          var style = getComputedStyle(target2, ":before");
          ev.stopPropagation();
          if (isPositionInBox(style, offsetX, offsetY)) {
            var tr = _this.view.state.tr;
            var pos = _this.getPos();
            tr.setSelection(createTextSelection(tr, pos, pos + 1));
            _this.view.dispatch(tr);
            _this.eventEmitter.emit("openPopup", "link", _this.imageLink.attrs);
          }
        }
      };
      this.node = node4;
      this.view = view;
      this.getPos = getPos;
      this.eventEmitter = eventEmitter;
      this.imageLink = (_a = node4.marks.filter(function(_a2) {
        var type = _a2.type;
        return type.name === "link";
      })[0]) !== null && _a !== void 0 ? _a : null;
      this.dom = this.createElement();
      this.bindEvent();
    }
    ImageView2.prototype.createElement = function() {
      var image2 = this.createImageElement(this.node);
      if (this.imageLink) {
        var wrapper = document.createElement("span");
        wrapper.className = IMAGE_LINK_CLASS_NAME;
        wrapper.appendChild(image2);
        return wrapper;
      }
      return image2;
    };
    ImageView2.prototype.createImageElement = function(node4) {
      var image2 = document.createElement("img");
      var _a = node4.attrs, imageUrl = _a.imageUrl, altText = _a.altText;
      var attrs = getCustomAttrs(node4.attrs);
      image2.src = imageUrl;
      if (altText) {
        image2.alt = altText;
      }
      setAttributes(attrs, image2);
      return image2;
    };
    ImageView2.prototype.bindEvent = function() {
      if (this.imageLink) {
        this.dom.addEventListener("mousedown", this.handleMousedown);
      }
    };
    ImageView2.prototype.stopEvent = function() {
      return true;
    };
    ImageView2.prototype.destroy = function() {
      if (this.imageLink) {
        this.dom.removeEventListener("mousedown", this.handleMousedown);
      }
    };
    return ImageView2;
  })()
);
var WRAPPER_CLASS_NAME = "toastui-editor-ww-code-block";
var CODE_BLOCK_LANG_CLASS_NAME = "toastui-editor-ww-code-block-language";
var CodeBlockView = (
  /** @class */
  (function() {
    function CodeBlockView2(node4, view, getPos, eventEmitter) {
      var _this = this;
      this.dom = null;
      this.contentDOM = null;
      this.input = null;
      this.timer = null;
      this.handleMousedown = function(ev) {
        var target2 = ev.target;
        var style = getComputedStyle(target2, ":after");
        if (style.backgroundImage !== "none" && isFunction_1(_this.getPos)) {
          var _a = _this.view.coordsAtPos(_this.getPos()), top_1 = _a.top, right = _a.right;
          _this.createLanguageEditor({ top: top_1, right });
        }
      };
      this.handleKeydown = function(ev) {
        if (ev.key === "Enter" && _this.input) {
          ev.preventDefault();
          _this.changeLanguage();
        }
      };
      this.node = node4;
      this.view = view;
      this.getPos = getPos;
      this.eventEmitter = eventEmitter;
      this.createElement();
      this.bindDOMEvent();
      this.bindEvent();
    }
    CodeBlockView2.prototype.createElement = function() {
      var language = this.node.attrs.language;
      var wrapper = document.createElement("div");
      wrapper.setAttribute("data-language", language || "text");
      wrapper.className = WRAPPER_CLASS_NAME;
      var pre2 = this.createCodeBlockElement();
      var code2 = pre2.firstChild;
      wrapper.appendChild(pre2);
      this.dom = wrapper;
      this.contentDOM = code2;
    };
    CodeBlockView2.prototype.createCodeBlockElement = function() {
      var pre2 = document.createElement("pre");
      var code2 = document.createElement("code");
      var language = this.node.attrs.language;
      var attrs = getCustomAttrs(this.node.attrs);
      if (language) {
        code2.setAttribute("data-language", language);
      }
      setAttributes(attrs, pre2);
      pre2.appendChild(code2);
      return pre2;
    };
    CodeBlockView2.prototype.createLanguageEditor = function(_a) {
      var _this = this;
      var top2 = _a.top, right = _a.right;
      var wrapper = document.createElement("span");
      wrapper.className = CODE_BLOCK_LANG_CLASS_NAME;
      var input = document.createElement("input");
      input.type = "text";
      input.value = this.node.attrs.language;
      wrapper.appendChild(input);
      this.view.dom.parentElement.appendChild(wrapper);
      var wrpperWidth = wrapper.clientWidth;
      css_1(wrapper, {
        top: top2 + 10 + "px",
        left: right - wrpperWidth - 10 + "px",
        width: wrpperWidth + "px"
      });
      this.input = input;
      this.input.addEventListener("blur", function() {
        return _this.changeLanguage();
      });
      this.input.addEventListener("keydown", this.handleKeydown);
      this.clearTimer();
      this.timer = setTimeout(function() {
        _this.input.focus();
      });
    };
    CodeBlockView2.prototype.bindDOMEvent = function() {
      if (this.dom) {
        this.dom.addEventListener("click", this.handleMousedown);
      }
    };
    CodeBlockView2.prototype.bindEvent = function() {
      var _this = this;
      this.eventEmitter.listen("scroll", function() {
        if (_this.input) {
          _this.reset();
        }
      });
    };
    CodeBlockView2.prototype.changeLanguage = function() {
      if (this.input && isFunction_1(this.getPos)) {
        var value = this.input.value;
        this.reset();
        var pos = this.getPos();
        var tr = this.view.state.tr;
        tr.setNodeMarkup(pos, null, { language: value });
        this.view.dispatch(tr);
      }
    };
    CodeBlockView2.prototype.reset = function() {
      var _a;
      if ((_a = this.input) === null || _a === void 0 ? void 0 : _a.parentElement) {
        var parent_1 = this.input.parentElement;
        this.input = null;
        removeNode$1(parent_1);
      }
    };
    CodeBlockView2.prototype.clearTimer = function() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    };
    CodeBlockView2.prototype.stopEvent = function() {
      return true;
    };
    CodeBlockView2.prototype.update = function(node4) {
      if (!node4.sameMarkup(this.node)) {
        return false;
      }
      this.node = node4;
      return true;
    };
    CodeBlockView2.prototype.destroy = function() {
      this.reset();
      this.clearTimer();
      if (this.dom) {
        this.dom.removeEventListener("click", this.handleMousedown);
      }
    };
    return CodeBlockView2;
  })()
);
var reMSOListClassName = /MsoListParagraph/;
var reMSOStylePrefix = /style=(.|\n)*mso-/;
var reMSOListStyle = /mso-list:(.*)/;
var reMSOTagName = /O:P/;
var reMSOListBullet = /^(n|u|l)/;
var MSO_CLASS_NAME_LIST_PARA = "p.MsoListParagraph";
function isFromMso(html2) {
  return reMSOStylePrefix.test(html2);
}
function getListItemContents(para2) {
  var removedNodes = [];
  var walker = document.createTreeWalker(para2, 1, null, false);
  while (walker.nextNode()) {
    var node4 = walker.currentNode;
    if (isElemNode(node4)) {
      var _a = node4, outerHTML = _a.outerHTML, textContent = _a.textContent;
      var msoSpan = reMSOStylePrefix.test(outerHTML);
      var bulletSpan = reMSOListStyle.test(outerHTML);
      if (msoSpan && !bulletSpan && textContent) {
        removedNodes.push([node4, true]);
      } else if (reMSOTagName.test(node4.nodeName) || msoSpan && !textContent || bulletSpan) {
        removedNodes.push([node4, false]);
      }
    }
  }
  removedNodes.forEach(function(_a2) {
    var node5 = _a2[0], isUnwrap = _a2[1];
    if (isUnwrap) {
      unwrapNode(node5);
    } else {
      removeNode$1(node5);
    }
  });
  return para2.innerHTML.trim();
}
function createListItemDataFromParagraph(para2, index3) {
  var styleAttr = para2.getAttribute("style");
  if (styleAttr) {
    var _a = styleAttr.match(reMSOListStyle), listItemInfo = _a[1];
    var _b = listItemInfo.trim().split(" "), levelStr = _b[1];
    var level = parseInt(levelStr.replace("level", ""), 10);
    var unordered = reMSOListBullet.test(para2.textContent || "");
    return {
      id: index3,
      level,
      prev: null,
      parent: null,
      children: [],
      unordered,
      contents: getListItemContents(para2)
    };
  }
  return null;
}
function addListItemDetailData(data, prevData) {
  if (prevData.level < data.level) {
    prevData.children.push(data);
    data.parent = prevData;
  } else {
    while (prevData) {
      if (prevData.level === data.level) {
        break;
      }
      prevData = prevData.parent;
    }
    if (prevData) {
      data.prev = prevData;
      data.parent = prevData.parent;
      if (data.parent) {
        data.parent.children.push(data);
      }
    }
  }
}
function createListData(paras) {
  var listData = [];
  paras.forEach(function(para2, index3) {
    var prevListItemData = listData[index3 - 1];
    var listItemData = createListItemDataFromParagraph(para2, index3);
    if (listItemData) {
      if (prevListItemData) {
        addListItemDetailData(listItemData, prevListItemData);
      }
      listData.push(listItemData);
    }
  });
  return listData;
}
function makeList(listData) {
  var listTagName = listData[0].unordered ? "ul" : "ol";
  var list2 = document.createElement(listTagName);
  listData.forEach(function(data) {
    var children = data.children, contents = data.contents;
    var listItem2 = document.createElement("li");
    listItem2.innerHTML = contents;
    list2.appendChild(listItem2);
    if (children.length) {
      list2.appendChild(makeList(children));
    }
  });
  return list2;
}
function makeListFromParagraphs(paras) {
  var listData = createListData(paras);
  var rootChildren = listData.filter(function(_a) {
    var parent = _a.parent;
    return !parent;
  });
  return makeList(rootChildren);
}
function isMsoListParagraphEnd(node4) {
  while (node4) {
    if (isElemNode(node4)) {
      break;
    }
    node4 = node4.nextSibling;
  }
  return node4 ? !reMSOListClassName.test(node4.className) : true;
}
function convertMsoParagraphsToList(html2) {
  var container = document.createElement("div");
  container.innerHTML = html2;
  var paras = [];
  var foundParas = findNodes(container, MSO_CLASS_NAME_LIST_PARA);
  foundParas.forEach(function(para2) {
    var msoListParaEnd = isMsoListParagraphEnd(para2.nextSibling);
    paras.push(para2);
    if (msoListParaEnd) {
      var list2 = makeListFromParagraphs(paras);
      var nextSibling = para2.nextSibling;
      if (nextSibling) {
        insertBeforeNode(list2, nextSibling);
      } else {
        appendNodes(container, list2);
      }
      paras = [];
    }
    removeNode$1(para2);
  });
  var extraHTML = foundParas.length ? "<p></p>" : "";
  return "" + extraHTML + container.innerHTML;
}
var START_FRAGMENT_COMMENT = "<!--StartFragment-->";
var END_FRAGMENT_COMMENT = "<!--EndFragment-->";
function getContentBetweenFragmentComments(html2) {
  var startFragmentIndex = html2.indexOf(START_FRAGMENT_COMMENT);
  var endFragmentIndex = html2.lastIndexOf(END_FRAGMENT_COMMENT);
  if (startFragmentIndex > -1 && endFragmentIndex > -1) {
    html2 = html2.slice(startFragmentIndex + START_FRAGMENT_COMMENT.length, endFragmentIndex);
  }
  return html2.replace(/<br[^>]*>/g, ALTERNATIVE_TAG_FOR_BR2);
}
function convertMsoTableToCompletedTable(html2) {
  if (/<\/td>((?!<\/tr>)[\s\S])*$/i.test(html2)) {
    html2 = "<tr>" + html2 + "</tr>";
  }
  if (/<\/tr>((?!<\/table>)[\s\S])*$/i.test(html2)) {
    html2 = "<table>" + html2 + "</table>";
  }
  return html2;
}
function changePastedHTML(html2) {
  html2 = getContentBetweenFragmentComments(html2);
  html2 = convertMsoTableToCompletedTable(html2);
  if (isFromMso(html2)) {
    html2 = convertMsoParagraphsToList(html2);
  }
  return html2;
}
function getMaxColumnCount(rows) {
  var row = rows.reduce(function(prevRow, currentRow) {
    return prevRow.childCount > currentRow.childCount ? prevRow : currentRow;
  });
  return row.childCount;
}
function createCells(orgRow, maxColumnCount, cell) {
  var cells = [];
  var cellCount = orgRow.childCount;
  for (var colIdx = 0; colIdx < cellCount; colIdx += 1) {
    if (!orgRow.child(colIdx).attrs.extended) {
      var copiedCell = colIdx < cellCount ? cell.create(orgRow.child(colIdx).attrs, orgRow.child(colIdx).content) : cell.createAndFill();
      cells.push(copiedCell);
    }
  }
  return cells;
}
function copyTableHeadRow(orgRow, maxColumnCount, schema) {
  var _a = schema.nodes, tableRow2 = _a.tableRow, tableHeadCell = _a.tableHeadCell;
  var cells = createCells(orgRow, maxColumnCount, tableHeadCell);
  return tableRow2.create(null, cells);
}
function copyTableBodyRow(orgRow, maxColumnCount, schema) {
  var _a = schema.nodes, tableRow2 = _a.tableRow, tableBodyCell = _a.tableBodyCell;
  var cells = createCells(orgRow, maxColumnCount, tableBodyCell);
  return tableRow2.create(null, cells);
}
function creatTableBodyDummyRow(columnCount, schema) {
  var _a = schema.nodes, tableRow2 = _a.tableRow, tableBodyCell = _a.tableBodyCell;
  var cells = [];
  for (var columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {
    var dummyCell = tableBodyCell.createAndFill();
    cells.push(dummyCell);
  }
  return tableRow2.create({ dummyRowForPasting: true }, cells);
}
function createRowsFromPastingTable(tableContent) {
  var tableHeadRows = [];
  var tableBodyRows = [];
  if (tableContent.firstChild.type.name === "tableHead") {
    var tableHead2 = tableContent.firstChild;
    tableHead2.forEach(function(row) {
      return tableHeadRows.push(row);
    });
  }
  if (tableContent.lastChild.type.name === "tableBody") {
    var tableBody2 = tableContent.lastChild;
    tableBody2.forEach(function(row) {
      return tableBodyRows.push(row);
    });
  }
  return __spreadArray$1(__spreadArray$1([], tableHeadRows), tableBodyRows);
}
function createTableHead(tableHeadRow, maxColumnCount, schema) {
  var copiedRow = copyTableHeadRow(tableHeadRow, maxColumnCount, schema);
  return schema.nodes.tableHead.create(null, copiedRow);
}
function createTableBody(tableBodyRows, maxColumnCount, schema) {
  var copiedRows = tableBodyRows.map(function(tableBodyRow) {
    return copyTableBodyRow(tableBodyRow, maxColumnCount, schema);
  });
  if (!tableBodyRows.length) {
    var dummyTableRow = creatTableBodyDummyRow(maxColumnCount, schema);
    copiedRows.push(dummyTableRow);
  }
  return schema.nodes.tableBody.create(null, copiedRows);
}
function createTableFromPastingTable(rows, schema, startFromBody, isInTable) {
  var columnCount = getMaxColumnCount(rows);
  if (startFromBody && isInTable) {
    return schema.nodes.table.create(null, [createTableBody(rows, columnCount, schema)]);
  }
  var tableHeadRow = rows[0];
  var tableBodyRows = rows.slice(1);
  var nodes = [createTableHead(tableHeadRow, columnCount, schema)];
  if (tableBodyRows.length) {
    nodes.push(createTableBody(tableBodyRows, columnCount, schema));
  }
  return schema.nodes.table.create(null, nodes);
}
function changePastedSlice(slice4, schema, isInTable) {
  var nodes = [];
  var content2 = slice4.content, openStart = slice4.openStart, openEnd = slice4.openEnd;
  content2.forEach(function(node4) {
    if (node4.type.name === "table") {
      var tableContent = getTableContentFromSlice(new Slice(Fragment.from(node4), 0, 0));
      if (tableContent) {
        var rows = createRowsFromPastingTable(tableContent);
        var startFromBody = tableContent.firstChild.type.name === "tableBody";
        var table2 = createTableFromPastingTable(rows, schema, startFromBody, isInTable);
        nodes.push(table2);
      }
    } else {
      nodes.push(node4);
    }
  });
  return new Slice(Fragment.from(nodes), openStart, openEnd);
}
var DUMMY_CELL_SIZE = 4;
var TR_NODES_SIZE = 2;
function getDummyCellSize(dummyCellCount) {
  return dummyCellCount * DUMMY_CELL_SIZE;
}
function createPastingCells(tableContent, curSelectionInfo, schema) {
  var pastingRows = [];
  var pastingTableRows = createRowsFromPastingTable(tableContent);
  var columnCount = pastingTableRows[0].childCount;
  var rowCount = pastingTableRows.length;
  var startToTableHead = curSelectionInfo.startRowIdx === 0;
  var slicedRows = pastingTableRows.slice(0, rowCount);
  if (startToTableHead) {
    var tableHeadRow = slicedRows.shift();
    if (tableHeadRow) {
      var content2 = copyTableHeadRow(tableHeadRow, columnCount, schema).content;
      pastingRows.push(content2);
    }
  }
  slicedRows.forEach(function(tableBodyRow) {
    if (!tableBodyRow.attrs.dummyRowForPasting) {
      var content3 = copyTableBodyRow(tableBodyRow, columnCount, schema).content;
      pastingRows.push(content3);
    }
  });
  return pastingRows;
}
function getPastingRangeInfo(map14, _a, pastingCells) {
  var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx;
  var pastingRowCount = pastingCells.length;
  var pastingColumnCount = 0;
  var _loop_1 = function(i2) {
    var columnCount = pastingCells[i2].childCount;
    pastingCells[i2].forEach(function(_a2) {
      var attrs = _a2.attrs;
      var colspan = attrs.colspan;
      if (colspan > 1) {
        columnCount += colspan - 1;
      }
    });
    pastingColumnCount = Math.max(pastingColumnCount, columnCount);
  };
  for (var i = 0; i < pastingRowCount; i += 1) {
    _loop_1(i);
  }
  var endRowIdx = startRowIdx + pastingRowCount - 1;
  var endColIdx = startColIdx + pastingColumnCount - 1;
  var addedRowCount = Math.max(endRowIdx + 1 - map14.totalRowCount, 0);
  var addedColumnCount = Math.max(endColIdx + 1 - map14.totalColumnCount, 0);
  return {
    startRowIdx,
    startColIdx,
    endRowIdx,
    endColIdx,
    addedRowCount,
    addedColumnCount
  };
}
function addReplacedOffsets(_a, cellsOffsets) {
  var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;
  for (var rowIdx = startRowIdx; rowIdx <= endRowIdx - addedRowCount; rowIdx += 1) {
    cellsOffsets.push({
      rowIdx,
      startColIdx,
      endColIdx: endColIdx - addedColumnCount
    });
  }
}
function expandColumns(tr, schema, map14, _a, cellsOffsets) {
  var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;
  var totalRowCount = map14.totalRowCount;
  var index3 = 0;
  for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
    var _b = map14.getCellInfo(rowIdx, endColIdx - addedColumnCount), offset2 = _b.offset, nodeSize2 = _b.nodeSize;
    var insertOffset = tr.mapping.map(offset2 + nodeSize2);
    var cells = createDummyCells(addedColumnCount, rowIdx, schema);
    tr.insert(insertOffset, cells);
    if (rowIdx >= startRowIdx && rowIdx <= endRowIdx - addedRowCount) {
      var cellInfo = map14.getCellInfo(rowIdx, endColIdx - addedColumnCount);
      var startCellOffset = tr.mapping.map(cellInfo.offset);
      var endCellOffset = insertOffset + getDummyCellSize(addedColumnCount);
      cellsOffsets[index3] = {
        rowIdx,
        startColIdx,
        endColIdx,
        dummyOffsets: [startCellOffset, endCellOffset]
      };
      index3 += 1;
    }
  }
}
function expandRows(tr, schema, map14, _a, cellsOffsets) {
  var addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount, startColIdx = _a.startColIdx, endColIdx = _a.endColIdx;
  var mapStart = tr.mapping.maps.length;
  var tableEndPos = map14.tableEndOffset - 2;
  var rows = createTableBodyRows(addedRowCount, map14.totalColumnCount + addedColumnCount, schema);
  var startOffset = tableEndPos;
  tr.insert(tr.mapping.slice(mapStart).map(startOffset), rows);
  for (var rowIndex = 0; rowIndex < addedRowCount; rowIndex += 1) {
    var startCellOffset = startOffset + getDummyCellSize(startColIdx) + 1;
    var endCellOffset = startOffset + getDummyCellSize(endColIdx + 1) + 1;
    var nextCellOffset = startOffset + getDummyCellSize(map14.totalColumnCount + addedColumnCount) + TR_NODES_SIZE;
    cellsOffsets.push({
      rowIdx: rowIndex + map14.totalRowCount,
      startColIdx,
      endColIdx,
      dummyOffsets: [startCellOffset, endCellOffset]
    });
    startOffset = nextCellOffset;
  }
}
function replaceCells(tr, pastingRows, cellsOffsets, map14) {
  var mapStart = tr.mapping.maps.length;
  cellsOffsets.forEach(function(offsets, index3) {
    var rowIdx = offsets.rowIdx, startColIdx = offsets.startColIdx, endColIdx = offsets.endColIdx, dummyOffsets = offsets.dummyOffsets;
    var mapping = tr.mapping.slice(mapStart);
    var cells = new Slice(pastingRows[index3], 0, 0);
    var from4 = dummyOffsets ? dummyOffsets[0] : map14.getCellStartOffset(rowIdx, startColIdx);
    var to = dummyOffsets ? dummyOffsets[1] : map14.getCellEndOffset(rowIdx, endColIdx);
    tr.replace(mapping.map(from4), mapping.map(to), cells);
  });
}
function pasteToTable(view, slice4) {
  var _a = view.state, selection = _a.selection, schema = _a.schema, tr = _a.tr;
  var _b = getResolvedSelection(selection), anchor = _b.anchor, head = _b.head;
  if (anchor && head) {
    var tableContent = getTableContentFromSlice(slice4);
    if (!tableContent) {
      return false;
    }
    var map14 = TableOffsetMap.create(anchor);
    var curSelectionInfo = map14.getRectOffsets(anchor, head);
    var pastingCells = createPastingCells(tableContent, curSelectionInfo, schema);
    var pastingInfo = getPastingRangeInfo(map14, curSelectionInfo, pastingCells);
    var cellsOffsets = [];
    if (canMerge(map14, pastingInfo)) {
      addReplacedOffsets(pastingInfo, cellsOffsets);
      if (pastingInfo.addedColumnCount) {
        expandColumns(tr, schema, map14, pastingInfo, cellsOffsets);
      }
      if (pastingInfo.addedRowCount) {
        expandRows(tr, schema, map14, pastingInfo, cellsOffsets);
      }
      replaceCells(tr, pastingCells, cellsOffsets, map14);
      view.dispatch(tr);
      setSelection2(view, cellsOffsets, map14.getCellInfo(0, 0).offset);
    }
    return true;
  }
  return false;
}
function setSelection2(view, cellsOffsets, pos) {
  var _a = view.state, tr = _a.tr, doc2 = _a.doc;
  var map14 = TableOffsetMap.create(doc2.resolve(pos));
  var _b = cellsOffsets[0], startRowIdx = _b.rowIdx, startColIdx = _b.startColIdx;
  var _c = last$1(cellsOffsets), endRowIdx = _c.rowIdx, endColIdx = _c.endColIdx;
  var startOffset = map14.getCellInfo(startRowIdx, startColIdx).offset;
  var endOffset = map14.getCellInfo(endRowIdx, endColIdx).offset;
  view.dispatch(tr.setSelection(new CellSelection(doc2.resolve(startOffset), doc2.resolve(endOffset))));
}
function canMerge(map14, pastingInfo) {
  var ranges = map14.getSpannedOffsets(pastingInfo);
  var _a = getRowAndColumnCount(ranges), rowCount = _a.rowCount, columnCount = _a.columnCount;
  var _b = getRowAndColumnCount(pastingInfo), pastingRowCount = _b.rowCount, pastingColumnCount = _b.columnCount;
  return rowCount === pastingRowCount && columnCount === pastingColumnCount;
}
var Doc = (
  /** @class */
  (function(_super) {
    __extends$1(Doc2, _super);
    function Doc2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Doc2.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Doc2.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: false,
      configurable: true
    });
    return Doc2;
  })(Node$2)
);
var Paragraph = (
  /** @class */
  (function(_super) {
    __extends$1(Paragraph2, _super);
    function Paragraph2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Paragraph2.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Paragraph2.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          group: "block",
          attrs: __assign$1({}, getDefaultCustomAttrs()),
          parseDOM: [{ tag: "p" }],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["p", getCustomAttrs(attrs), 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return Paragraph2;
  })(Node$2)
);
var reSoftTabLen = /\s{1,4}$/;
var Text = (
  /** @class */
  (function(_super) {
    __extends$1(Text2, _super);
    function Text2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Text2.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Text2.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: false,
      configurable: true
    });
    Text2.prototype.addSpaces = function() {
      return function(_a, dispatch2) {
        var selection = _a.selection, tr = _a.tr;
        var $from = selection.$from, $to = selection.$to;
        var range2 = $from.blockRange($to);
        if (range2 && !isInListNode($from) && !isInTableNode($from)) {
          dispatch2(tr.insertText("    ", $from.pos, $to.pos));
          return true;
        }
        return false;
      };
    };
    Text2.prototype.removeSpaces = function() {
      return function(_a, dispatch2) {
        var selection = _a.selection, tr = _a.tr;
        var $from = selection.$from, $to = selection.$to, from4 = selection.from;
        var range2 = $from.blockRange($to);
        if (range2 && !isInListNode($from) && !isInTableNode($from)) {
          var nodeBefore = $from.nodeBefore;
          if (nodeBefore && nodeBefore.isText) {
            var text3 = nodeBefore.text;
            var removedSpaceText = text3.replace(reSoftTabLen, "");
            var spaces = text3.length - removedSpaceText.length;
            dispatch2(tr.delete(from4 - spaces, from4));
            return true;
          }
        }
        return false;
      };
    };
    Text2.prototype.keymaps = function() {
      return {
        Tab: this.addSpaces(),
        "Shift-Tab": this.removeSpaces()
      };
    };
    return Text2;
  })(Node$2)
);
var Heading = (
  /** @class */
  (function(_super) {
    __extends$1(Heading2, _super);
    function Heading2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Heading2.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Heading2.prototype, "levels", {
      get: function() {
        return [1, 2, 3, 4, 5, 6];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Heading2.prototype, "schema", {
      get: function() {
        var parseDOM = this.levels.map(function(level) {
          return {
            tag: "h" + level,
            getAttrs: function(dom) {
              var rawHTML = dom.getAttribute("data-raw-html");
              return __assign$1({ level }, rawHTML && { rawHTML });
            }
          };
        });
        return {
          attrs: __assign$1({ level: { default: 1 }, headingType: { default: "atx" }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          content: "inline*",
          group: "block",
          defining: true,
          parseDOM,
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["h" + attrs.level, getCustomAttrs(attrs), 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Heading2.prototype.commands = function() {
      return function(payload) {
        return function(state, dispatch2) {
          var nodeType2 = state.schema.nodes[payload.level ? "heading" : "paragraph"];
          return setBlockType(nodeType2, payload)(state, dispatch2);
        };
      };
    };
    return Heading2;
  })(Node$2)
);
var CodeBlock = (
  /** @class */
  (function(_super) {
    __extends$1(CodeBlock2, _super);
    function CodeBlock2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CodeBlock2.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CodeBlock2.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: __assign$1({ language: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          code: true,
          defining: true,
          marks: "",
          parseDOM: [
            {
              tag: "pre",
              preserveWhitespace: "full",
              getAttrs: function(dom) {
                var rawHTML = dom.getAttribute("data-raw-html");
                var child3 = dom.firstElementChild;
                return __assign$1({ language: (child3 === null || child3 === void 0 ? void 0 : child3.getAttribute("data-language")) || null }, rawHTML && { rawHTML });
              }
            }
          ],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return [
              attrs.rawHTML || "pre",
              ["code", __assign$1({ "data-language": attrs.language }, getCustomAttrs(attrs)), 0]
            ];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    CodeBlock2.prototype.commands = function() {
      return function() {
        return function(state, dispatch2) {
          return setBlockType(state.schema.nodes.codeBlock)(state, dispatch2);
        };
      };
    };
    CodeBlock2.prototype.moveCursor = function(direction) {
      var _this = this;
      return function(state, dispatch2) {
        var tr = state.tr, doc2 = state.doc, schema = state.schema;
        var $from = state.selection.$from;
        var view = _this.context.view;
        if (view.endOfTextblock(direction) && $from.node().type.name === "codeBlock") {
          var lines = $from.parent.textContent.split("\n");
          var offset2 = direction === "up" ? $from.start() : $from.end();
          var range2 = direction === "up" ? [offset2, lines[0].length + offset2] : [offset2 - last$1(lines).length, offset2];
          var pos = doc2.resolve(direction === "up" ? $from.before() : $from.after());
          var node4 = direction === "up" ? pos.nodeBefore : pos.nodeAfter;
          if (between$1($from.pos, range2[0], range2[1]) && !node4) {
            var newTr = addParagraph(tr, pos, schema);
            if (newTr) {
              dispatch2(newTr);
              return true;
            }
          }
        }
        return false;
      };
    };
    CodeBlock2.prototype.keymaps = function() {
      var codeCommand = this.commands()();
      return {
        "Shift-Mod-p": codeCommand,
        "Shift-Mod-P": codeCommand,
        ArrowUp: this.moveCursor("up"),
        ArrowDown: this.moveCursor("down")
      };
    };
    return CodeBlock2;
  })(Node$2)
);
var BulletList = (
  /** @class */
  (function(_super) {
    __extends$1(BulletList2, _super);
    function BulletList2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BulletList2.prototype, "name", {
      get: function() {
        return "bulletList";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BulletList2.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("ul")],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["ul", getCustomAttrs(attrs), 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    BulletList2.prototype.changeList = function() {
      return function(state, dispatch2) {
        return changeList(state.schema.nodes.bulletList)(state, dispatch2);
      };
    };
    BulletList2.prototype.commands = function() {
      return {
        bulletList: this.changeList,
        taskList: toggleTask
      };
    };
    BulletList2.prototype.keymaps = function() {
      var bulletListCommand = this.changeList();
      var _a = getWwCommands(), indent2 = _a.indent, outdent2 = _a.outdent;
      return {
        "Mod-u": bulletListCommand,
        "Mod-U": bulletListCommand,
        Tab: indent2(),
        "Shift-Tab": outdent2()
      };
    };
    return BulletList2;
  })(Node$2)
);
var OrderedList = (
  /** @class */
  (function(_super) {
    __extends$1(OrderedList2, _super);
    function OrderedList2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(OrderedList2.prototype, "name", {
      get: function() {
        return "orderedList";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(OrderedList2.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: __assign$1({ order: { default: 1 }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "ol",
              getAttrs: function(dom) {
                var start3 = dom.getAttribute("start");
                var rawHTML = dom.getAttribute("data-raw-html");
                return __assign$1({ order: dom.hasAttribute("start") ? Number(start3) : 1 }, rawHTML && { rawHTML });
              }
            }
          ],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return [
              attrs.rawHTML || "ol",
              __assign$1({ start: attrs.order === 1 ? null : attrs.order }, getCustomAttrs(attrs)),
              0
            ];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    OrderedList2.prototype.commands = function() {
      return function() {
        return function(state, dispatch2) {
          return changeList(state.schema.nodes.orderedList)(state, dispatch2);
        };
      };
    };
    OrderedList2.prototype.keymaps = function() {
      var orderedListCommand = this.commands()();
      var _a = getWwCommands(), indent2 = _a.indent, outdent2 = _a.outdent;
      return {
        "Mod-o": orderedListCommand,
        "Mod-O": orderedListCommand,
        Tab: indent2(),
        "Shift-Tab": outdent2()
      };
    };
    return OrderedList2;
  })(Node$2)
);
var ListItem = (
  /** @class */
  (function(_super) {
    __extends$1(ListItem2, _super);
    function ListItem2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ListItem2.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ListItem2.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph block*",
          selectable: false,
          attrs: {
            task: { default: false },
            checked: { default: false },
            rawHTML: { default: null }
          },
          defining: true,
          parseDOM: [
            {
              tag: "li",
              getAttrs: function(dom) {
                var rawHTML = dom.getAttribute("data-raw-html");
                return __assign$1({ task: dom.hasAttribute("data-task"), checked: dom.hasAttribute("data-task-checked") }, rawHTML && { rawHTML });
              }
            }
          ],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            var task2 = attrs.task, checked = attrs.checked;
            if (!task2) {
              return [attrs.rawHTML || "li", 0];
            }
            var classNames = ["task-list-item"];
            if (checked) {
              classNames.push("checked");
            }
            return [
              attrs.rawHTML || "li",
              __assign$1({ class: classNames.join(" "), "data-task": task2 }, checked && { "data-task-checked": checked }),
              0
            ];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    ListItem2.prototype.liftToPrevListItem = function() {
      return function(state, dispatch2) {
        var selection = state.selection, tr = state.tr, schema = state.schema;
        var $from = selection.$from, empty3 = selection.empty;
        var listItem2 = schema.nodes.listItem;
        var parent = $from.parent;
        var listItemParent = $from.node(-1);
        if (empty3 && !parent.childCount && listItemParent.type === listItem2) {
          if ($from.index(-2) >= 1) {
            tr.delete($from.start(-1) - 1, $from.end(-1));
            dispatch2(tr);
            return true;
          }
          var grandParentListItem = $from.node(-3);
          if (grandParentListItem.type === listItem2) {
            tr.delete($from.start(-2) - 1, $from.end(-1));
            dispatch2(tr);
            return true;
          }
        }
        return false;
      };
    };
    ListItem2.prototype.keymaps = function() {
      var split = function(state, dispatch2) {
        return splitListItem(state.schema.nodes.listItem)(state, dispatch2);
      };
      return {
        Backspace: this.liftToPrevListItem(),
        Enter: split
      };
    };
    return ListItem2;
  })(Node$2)
);
var BlockQuote = (
  /** @class */
  (function(_super) {
    __extends$1(BlockQuote2, _super);
    function BlockQuote2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BlockQuote2.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BlockQuote2.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          content: "block+",
          group: "block",
          parseDOM: [createDOMInfoParsedRawHTML("blockquote")],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["blockquote", getCustomAttrs(attrs), 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    BlockQuote2.prototype.commands = function() {
      return function() {
        return function(state, dispatch2) {
          return wrapIn(state.schema.nodes.blockQuote)(state, dispatch2);
        };
      };
    };
    BlockQuote2.prototype.keymaps = function() {
      var blockQutoeCommand = this.commands()();
      return {
        "Alt-q": blockQutoeCommand,
        "Alt-Q": blockQutoeCommand
      };
    };
    return BlockQuote2;
  })(Node$2)
);
var cellOffsetFnMap = {
  left: getLeftCellOffset,
  right: getRightCellOffset,
  up: getUpCellOffset,
  down: getDownCellOffset
};
function isInFirstListItem(pos, doc2, _a) {
  var paraDepth = _a[0], listDepth = _a[1];
  var listItemNode = doc2.resolve(pos.before(paraDepth - 1));
  return listDepth === paraDepth && !listItemNode.nodeBefore;
}
function isInLastListItem(pos) {
  var _a;
  var depth = pos.depth;
  var parentNode2;
  while (depth) {
    parentNode2 = pos.node(depth);
    if (parentNode2.type.name === "tableBodyCell") {
      break;
    }
    if (parentNode2.type.name === "listItem") {
      var grandParent = pos.node(depth - 1);
      var lastListItem = grandParent.lastChild === parentNode2;
      var hasChildren = ((_a = parentNode2.lastChild) === null || _a === void 0 ? void 0 : _a.type.name) !== "paragraph";
      if (!lastListItem) {
        return false;
      }
      return !hasChildren;
    }
    depth -= 1;
  }
  return false;
}
function canMoveToBeforeCell(direction, _a, from4, doc2, inList) {
  var paraDepth = _a[0], listDepth = _a[1], curDepth = _a[2];
  if (direction === "left" || direction === "up") {
    if (inList && !isInFirstListItem(from4, doc2, [paraDepth, listDepth])) {
      return false;
    }
    var endOffset = from4.before(curDepth);
    var nodeBefore = doc2.resolve(endOffset).nodeBefore;
    if (nodeBefore) {
      return false;
    }
  }
  return true;
}
function canMoveToAfterCell(direction, curDepth, from4, doc2, inList) {
  if (direction === "right" || direction === "down") {
    if (inList && !isInLastListItem(from4)) {
      return false;
    }
    var endOffset = from4.after(curDepth);
    var nodeAfter = doc2.resolve(endOffset).nodeAfter;
    if (nodeAfter) {
      return false;
    }
  }
  return true;
}
function canMoveBetweenCells(direction, _a, from4, doc2) {
  var cellDepth = _a[0], paraDepth = _a[1];
  var listDepth = cellDepth + 3;
  var inList = paraDepth >= listDepth;
  var curDepth = inList ? cellDepth + 1 : paraDepth;
  var moveBeforeCell = canMoveToBeforeCell(direction, [paraDepth, listDepth, curDepth], from4, doc2, inList);
  var moveAfterCell = canMoveToAfterCell(direction, curDepth, from4, doc2, inList);
  return moveBeforeCell && moveAfterCell;
}
function canBeOutOfTable(direction, map14, _a) {
  var rowIdx = _a[0], colIdx = _a[1];
  var rowspanInfo = map14.getRowspanStartInfo(rowIdx, colIdx);
  var inFirstRow = direction === "up" && rowIdx === 0;
  var inLastRow = direction === "down" && ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1 ? rowIdx + rowspanInfo.count - 1 : rowIdx) === map14.totalRowCount - 1;
  return inFirstRow || inLastRow;
}
function addParagraphBeforeTable(tr, map14, schema) {
  var tableStartPos = tr.doc.resolve(map14.tableStartOffset - 1);
  if (!tableStartPos.nodeBefore) {
    return addParagraph(tr, tableStartPos, schema);
  }
  return tr.setSelection(Selection.near(tableStartPos, -1));
}
function addParagraphAfterTable(tr, map14, schema, forcedAddtion) {
  if (forcedAddtion === void 0) {
    forcedAddtion = false;
  }
  var tableEndPos = tr.doc.resolve(map14.tableEndOffset);
  if (forcedAddtion || !tableEndPos.nodeAfter) {
    return addParagraph(tr, tableEndPos, schema);
  }
  return tr.setSelection(Selection.near(tableEndPos, 1));
}
function getRightCellOffset(_a, map14) {
  var rowIdx = _a[0], colIdx = _a[1];
  var totalRowCount = map14.totalRowCount, totalColumnCount = map14.totalColumnCount;
  var lastCellInRow = colIdx === totalColumnCount - 1;
  var lastCellInTable = rowIdx === totalRowCount - 1 && lastCellInRow;
  if (!lastCellInTable) {
    var nextColIdx = colIdx + 1;
    var colspanInfo = map14.getColspanStartInfo(rowIdx, colIdx);
    if ((colspanInfo === null || colspanInfo === void 0 ? void 0 : colspanInfo.count) > 1) {
      nextColIdx += colspanInfo.count - 1;
    }
    if (lastCellInRow || nextColIdx === totalColumnCount) {
      rowIdx += 1;
      nextColIdx = 0;
    }
    var offset2 = map14.getCellInfo(rowIdx, nextColIdx).offset;
    return offset2 + 2;
  }
  return null;
}
function getLeftCellOffset(_a, map14) {
  var rowIdx = _a[0], colIdx = _a[1];
  var totalColumnCount = map14.totalColumnCount;
  var firstCellInRow = colIdx === 0;
  var firstCellInTable = rowIdx === 0 && firstCellInRow;
  if (!firstCellInTable) {
    colIdx -= 1;
    if (firstCellInRow) {
      rowIdx -= 1;
      colIdx = totalColumnCount - 1;
    }
    var _b = map14.getCellInfo(rowIdx, colIdx), offset2 = _b.offset, nodeSize2 = _b.nodeSize;
    return offset2 + nodeSize2 - 2;
  }
  return null;
}
function getUpCellOffset(_a, map14) {
  var rowIdx = _a[0], colIdx = _a[1];
  if (rowIdx > 0) {
    var _b = map14.getCellInfo(rowIdx - 1, colIdx), offset2 = _b.offset, nodeSize2 = _b.nodeSize;
    return offset2 + nodeSize2 - 2;
  }
  return null;
}
function getDownCellOffset(_a, map14) {
  var rowIdx = _a[0], colIdx = _a[1];
  var totalRowCount = map14.totalRowCount;
  if (rowIdx < totalRowCount - 1) {
    var nextRowIdx = rowIdx + 1;
    var rowspanInfo = map14.getRowspanStartInfo(rowIdx, colIdx);
    if ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1) {
      nextRowIdx += rowspanInfo.count - 1;
    }
    var offset2 = map14.getCellInfo(nextRowIdx, colIdx).offset;
    return offset2 + 2;
  }
  return null;
}
function moveToCell(direction, tr, cellIndex, map14) {
  var cellOffsetFn = cellOffsetFnMap[direction];
  var offset2 = cellOffsetFn(cellIndex, map14);
  if (offset2) {
    var dir = direction === "right" || direction === "down" ? 1 : -1;
    return tr.setSelection(Selection.near(tr.doc.resolve(offset2), dir));
  }
  return null;
}
function canSelectTableNode(direction, map14, _a) {
  var rowIdx = _a[0], colIdx = _a[1];
  if (direction === "up" || direction === "down") {
    return false;
  }
  var tableStartOffset = map14.tableStartOffset, tableEndOffset = map14.tableEndOffset;
  var _b = map14.getCellInfo(rowIdx, colIdx), offset2 = _b.offset, nodeSize2 = _b.nodeSize;
  var pos = direction === "left" ? tableStartOffset : tableEndOffset;
  var curPos = direction === "left" ? offset2 - 2 : offset2 + nodeSize2 + 3;
  return pos === curPos;
}
function selectNode(tr, pos, depth) {
  var tablePos = tr.doc.resolve(pos.before(depth - 3));
  return tr.setSelection(new NodeSelection(tablePos));
}
function getTargetRowInfo(direction, map14, selectionInfo) {
  var targetRowIdx;
  var insertColIdx;
  var nodeSize2;
  if (direction === "up") {
    targetRowIdx = selectionInfo.startRowIdx;
    insertColIdx = 0;
    nodeSize2 = -1;
  } else {
    targetRowIdx = selectionInfo.endRowIdx;
    insertColIdx = map14.totalColumnCount - 1;
    nodeSize2 = map14.getCellInfo(targetRowIdx, insertColIdx).nodeSize + 1;
  }
  return { targetRowIdx, insertColIdx, nodeSize: nodeSize2 };
}
function getRowRanges(map14, rowIdx, totalColumnCount) {
  var startOffset = map14.getCellInfo(rowIdx, 0).offset;
  var _a = map14.getCellInfo(rowIdx, totalColumnCount - 1), offset2 = _a.offset, nodeSize2 = _a.nodeSize;
  return { from: startOffset, to: offset2 + nodeSize2 };
}
var Table = (
  /** @class */
  (function(_super) {
    __extends$1(Table2, _super);
    function Table2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Table2.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Table2.prototype, "schema", {
      get: function() {
        return {
          content: "tableHead{1} tableBody{1}",
          group: "block",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("table")],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["table", getCustomAttrs(attrs), 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Table2.prototype.addTable = function() {
      return function(payload) {
        if (payload === void 0) {
          payload = { rowCount: 2, columnCount: 1, data: [] };
        }
        return function(state, dispatch2) {
          var rowCount = payload.rowCount, columnCount = payload.columnCount, data = payload.data;
          var schema = state.schema, selection = state.selection, tr = state.tr;
          var from4 = selection.from, to = selection.to, $from = selection.$from;
          var collapsed = from4 === to;
          if (collapsed && !isInTableNode($from)) {
            var _a = schema.nodes, tableHead2 = _a.tableHead, tableBody2 = _a.tableBody;
            var theadData = data === null || data === void 0 ? void 0 : data.slice(0, columnCount);
            var tbodyData = data === null || data === void 0 ? void 0 : data.slice(columnCount, data.length);
            var tableHeadRow = createTableHeadRow(columnCount, schema, theadData);
            var tableBodyRows = createTableBodyRows(rowCount - 1, columnCount, schema, tbodyData);
            var table2 = schema.nodes.table.create(null, [
              tableHead2.create(null, tableHeadRow),
              tableBody2.create(null, tableBodyRows)
            ]);
            dispatch2(tr.replaceSelectionWith(table2));
            return true;
          }
          return false;
        };
      };
    };
    Table2.prototype.removeTable = function() {
      return function() {
        return function(state, dispatch2) {
          var selection = state.selection, tr = state.tr;
          var map14 = TableOffsetMap.create(selection.$anchor);
          if (map14) {
            var tableStartOffset = map14.tableStartOffset, tableEndOffset = map14.tableEndOffset;
            var startOffset = tableStartOffset - 1;
            var cursorPos = createTextSelection(tr.delete(startOffset, tableEndOffset), startOffset);
            dispatch2(tr.setSelection(cursorPos));
            return true;
          }
          return false;
        };
      };
    };
    Table2.prototype.addColumn = function(direction) {
      return function() {
        return function(state, dispatch2) {
          var selection = state.selection, tr = state.tr, schema = state.schema;
          var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
          if (anchor && head) {
            var map14 = TableOffsetMap.create(anchor);
            var selectionInfo = map14.getRectOffsets(anchor, head);
            var targetColIdx = direction === "left" ? selectionInfo.startColIdx : selectionInfo.endColIdx + 1;
            var columnCount = getRowAndColumnCount(selectionInfo).columnCount;
            var totalRowCount = map14.totalRowCount;
            for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
              var cells = createDummyCells(columnCount, rowIdx, schema);
              tr.insert(tr.mapping.map(map14.posAt(rowIdx, targetColIdx)), cells);
            }
            dispatch2(tr);
            return true;
          }
          return false;
        };
      };
    };
    Table2.prototype.removeColumn = function() {
      return function() {
        return function(state, dispatch2) {
          var selection = state.selection, tr = state.tr;
          var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
          if (anchor && head) {
            var map14 = TableOffsetMap.create(anchor);
            var selectionInfo = map14.getRectOffsets(anchor, head);
            var totalColumnCount = map14.totalColumnCount, totalRowCount = map14.totalRowCount;
            var columnCount = getRowAndColumnCount(selectionInfo).columnCount;
            var selectedAllColumn = columnCount === totalColumnCount;
            if (selectedAllColumn) {
              return false;
            }
            var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;
            var mapStart = tr.mapping.maps.length;
            for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
              for (var colIdx = endColIdx; colIdx >= startColIdx; colIdx -= 1) {
                var _b = map14.getCellInfo(rowIdx, colIdx), offset2 = _b.offset, nodeSize2 = _b.nodeSize;
                var from4 = tr.mapping.slice(mapStart).map(offset2);
                var to = from4 + nodeSize2;
                tr.delete(from4, to);
              }
            }
            dispatch2(tr);
            return true;
          }
          return false;
        };
      };
    };
    Table2.prototype.addRow = function(direction) {
      return function() {
        return function(state, dispatch2) {
          var selection = state.selection, schema = state.schema, tr = state.tr;
          var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
          if (anchor && head) {
            var map14 = TableOffsetMap.create(anchor);
            var totalColumnCount = map14.totalColumnCount;
            var selectionInfo = map14.getRectOffsets(anchor, head);
            var rowCount = getRowAndColumnCount(selectionInfo).rowCount;
            var _b = getTargetRowInfo(direction, map14, selectionInfo), targetRowIdx = _b.targetRowIdx, insertColIdx = _b.insertColIdx, nodeSize2 = _b.nodeSize;
            var selectedThead = targetRowIdx === 0;
            if (!selectedThead) {
              var rows = [];
              var from4 = tr.mapping.map(map14.posAt(targetRowIdx, insertColIdx)) + nodeSize2;
              var cells = [];
              for (var colIdx = 0; colIdx < totalColumnCount; colIdx += 1) {
                cells = cells.concat(createDummyCells(1, targetRowIdx, schema));
              }
              for (var i = 0; i < rowCount; i += 1) {
                rows.push(schema.nodes.tableRow.create(null, cells));
              }
              dispatch2(tr.insert(from4, rows));
              return true;
            }
          }
          return false;
        };
      };
    };
    Table2.prototype.removeRow = function() {
      return function() {
        return function(state, dispatch2) {
          var selection = state.selection, tr = state.tr;
          var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
          if (anchor && head) {
            var map14 = TableOffsetMap.create(anchor);
            var totalRowCount = map14.totalRowCount, totalColumnCount = map14.totalColumnCount;
            var selectionInfo = map14.getRectOffsets(anchor, head);
            var rowCount = getRowAndColumnCount(selectionInfo).rowCount;
            var startRowIdx = selectionInfo.startRowIdx, endRowIdx = selectionInfo.endRowIdx;
            var selectedThead = startRowIdx === 0;
            var selectedAllTbodyRow = rowCount === totalRowCount - 1;
            if (selectedAllTbodyRow || selectedThead) {
              return false;
            }
            for (var rowIdx = endRowIdx; rowIdx >= startRowIdx; rowIdx -= 1) {
              var _b = getRowRanges(map14, rowIdx, totalColumnCount), from4 = _b.from, to = _b.to;
              tr.delete(from4 - 1, to + 1);
            }
            dispatch2(tr);
            return true;
          }
          return false;
        };
      };
    };
    Table2.prototype.alignColumn = function() {
      return function(payload) {
        if (payload === void 0) {
          payload = { align: "center" };
        }
        return function(state, dispatch2) {
          var align = payload.align;
          var selection = state.selection, tr = state.tr;
          var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
          if (anchor && head) {
            var map14 = TableOffsetMap.create(anchor);
            var totalRowCount = map14.totalRowCount;
            var selectionInfo = map14.getRectOffsets(anchor, head);
            var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;
            for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
              for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
                if (!map14.extendedRowspan(rowIdx, colIdx) && !map14.extendedColspan(rowIdx, colIdx)) {
                  var _b = map14.getNodeAndPos(rowIdx, colIdx), node4 = _b.node, pos = _b.pos;
                  var attrs = setAttrs(node4, { align });
                  tr.setNodeMarkup(pos, null, attrs);
                }
              }
            }
            dispatch2(tr);
            return true;
          }
          return false;
        };
      };
    };
    Table2.prototype.moveToCell = function(direction) {
      return function(state, dispatch2) {
        var selection = state.selection, tr = state.tr, schema = state.schema;
        var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
        if (anchor && head) {
          var map14 = TableOffsetMap.create(anchor);
          var cellIndex = map14.getCellIndex(anchor);
          var newTr = void 0;
          if (canBeOutOfTable(direction, map14, cellIndex)) {
            newTr = addParagraphAfterTable(tr, map14, schema);
          } else {
            newTr = moveToCell(direction, tr, cellIndex, map14);
          }
          if (newTr) {
            dispatch2(newTr);
            return true;
          }
        }
        return false;
      };
    };
    Table2.prototype.moveInCell = function(direction) {
      var _this = this;
      return function(state, dispatch2) {
        var selection = state.selection, tr = state.tr, doc2 = state.doc, schema = state.schema;
        var $from = selection.$from;
        var view = _this.context.view;
        if (!view.endOfTextblock(direction)) {
          return false;
        }
        var cell = findNodeBy($from, function(_a) {
          var type = _a.type;
          return type.name === "tableHeadCell" || type.name === "tableBodyCell";
        });
        if (cell) {
          var para2 = findNodeBy($from, function(_a) {
            var type = _a.type;
            return type.name === "paragraph";
          });
          var cellDepth = cell.depth;
          if (para2 && canMoveBetweenCells(direction, [cellDepth, para2.depth], $from, doc2)) {
            var anchor = getResolvedSelection(selection).anchor;
            var map14 = TableOffsetMap.create(anchor);
            var cellIndex = map14.getCellIndex(anchor);
            var newTr = void 0;
            if (canSelectTableNode(direction, map14, cellIndex)) {
              newTr = selectNode(tr, $from, cellDepth);
            } else if (canBeOutOfTable(direction, map14, cellIndex)) {
              if (direction === "up") {
                newTr = addParagraphBeforeTable(tr, map14, schema);
              } else if (direction === "down") {
                newTr = addParagraphAfterTable(tr, map14, schema);
              }
            } else {
              newTr = moveToCell(direction, tr, cellIndex, map14);
            }
            if (newTr) {
              dispatch2(newTr);
              return true;
            }
          }
        }
        return false;
      };
    };
    Table2.prototype.deleteCells = function() {
      return function(state, dispatch2) {
        var schema = state.schema, selection = state.selection, tr = state.tr;
        var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
        var textSelection = selection instanceof TextSelection;
        if (anchor && head && !textSelection) {
          var map14 = TableOffsetMap.create(anchor);
          var _b = map14.getRectOffsets(anchor, head), startRowIdx = _b.startRowIdx, startColIdx = _b.startColIdx, endRowIdx = _b.endRowIdx, endColIdx = _b.endColIdx;
          for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {
            for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
              if (!map14.extendedRowspan(rowIdx, colIdx) && !map14.extendedColspan(rowIdx, colIdx)) {
                var _c = map14.getNodeAndPos(rowIdx, colIdx), node4 = _c.node, pos = _c.pos;
                var cells = createDummyCells(1, rowIdx, schema, node4.attrs);
                tr.replaceWith(tr.mapping.map(pos), tr.mapping.map(pos + node4.nodeSize), cells);
              }
            }
          }
          dispatch2(tr);
          return true;
        }
        return false;
      };
    };
    Table2.prototype.exitTable = function() {
      return function(state, dispatch2) {
        var selection = state.selection, tr = state.tr, schema = state.schema;
        var $from = selection.$from;
        var cell = findNodeBy($from, function(_a) {
          var type = _a.type;
          return type.name === "tableHeadCell" || type.name === "tableBodyCell";
        });
        if (cell) {
          var para2 = findNodeBy($from, function(_a) {
            var type = _a.type;
            return type.name === "paragraph";
          });
          if (para2) {
            var anchor = getResolvedSelection(selection).anchor;
            var map14 = TableOffsetMap.create(anchor);
            dispatch2(addParagraphAfterTable(tr, map14, schema, true));
            return true;
          }
        }
        return false;
      };
    };
    Table2.prototype.commands = function() {
      return {
        addTable: this.addTable(),
        removeTable: this.removeTable(),
        addColumnToLeft: this.addColumn(
          "left"
          /* LEFT */
        ),
        addColumnToRight: this.addColumn(
          "right"
          /* RIGHT */
        ),
        removeColumn: this.removeColumn(),
        addRowToUp: this.addRow(
          "up"
          /* UP */
        ),
        addRowToDown: this.addRow(
          "down"
          /* DOWN */
        ),
        removeRow: this.removeRow(),
        alignColumn: this.alignColumn()
      };
    };
    Table2.prototype.keymaps = function() {
      var deleteCellContent = this.deleteCells();
      return {
        Tab: this.moveToCell(
          "right"
          /* RIGHT */
        ),
        "Shift-Tab": this.moveToCell(
          "left"
          /* LEFT */
        ),
        ArrowUp: this.moveInCell(
          "up"
          /* UP */
        ),
        ArrowDown: this.moveInCell(
          "down"
          /* DOWN */
        ),
        ArrowLeft: this.moveInCell(
          "left"
          /* LEFT */
        ),
        ArrowRight: this.moveInCell(
          "right"
          /* RIGHT */
        ),
        Backspace: deleteCellContent,
        "Mod-Backspace": deleteCellContent,
        Delete: deleteCellContent,
        "Mod-Delete": deleteCellContent,
        "Mod-Enter": this.exitTable()
      };
    };
    return Table2;
  })(Node$2)
);
var TableHead = (
  /** @class */
  (function(_super) {
    __extends$1(TableHead2, _super);
    function TableHead2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableHead2.prototype, "name", {
      get: function() {
        return "tableHead";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TableHead2.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow{1}",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [createDOMInfoParsedRawHTML("thead")],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["thead", getCustomAttrs(attrs), 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return TableHead2;
  })(Node$2)
);
var TableBody = (
  /** @class */
  (function(_super) {
    __extends$1(TableBody2, _super);
    function TableBody2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableBody2.prototype, "name", {
      get: function() {
        return "tableBody";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TableBody2.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow+",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "tbody",
              getAttrs: function(dom) {
                var rows = dom.querySelectorAll("tr");
                var columns = rows[0].children.length;
                var rawHTML = dom.getAttribute("data-raw-html");
                if (!columns) {
                  return false;
                }
                return __assign$1({}, rawHTML && { rawHTML });
              }
            }
          ],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["tbody", getCustomAttrs(attrs), 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return TableBody2;
  })(Node$2)
);
var TableRow = (
  /** @class */
  (function(_super) {
    __extends$1(TableRow2, _super);
    function TableRow2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableRow2.prototype, "name", {
      get: function() {
        return "tableRow";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TableRow2.prototype, "schema", {
      get: function() {
        return {
          content: "(tableHeadCell | tableBodyCell)*",
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "tr",
              getAttrs: function(dom) {
                var columns = dom.children.length;
                var rawHTML = dom.getAttribute("data-raw-html");
                if (!columns) {
                  return false;
                }
                return __assign$1({}, rawHTML && { rawHTML });
              }
            }
          ],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["tr", getCustomAttrs(attrs), 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return TableRow2;
  })(Node$2)
);
var TableHeadCell = (
  /** @class */
  (function(_super) {
    __extends$1(TableHeadCell2, _super);
    function TableHeadCell2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableHeadCell2.prototype, "name", {
      get: function() {
        return "tableHeadCell";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TableHeadCell2.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph+",
          attrs: __assign$1({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, getDefaultCustomAttrs()),
          isolating: true,
          parseDOM: [createParsedCellDOM("th")],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            var cellAttrs = createCellAttrs(attrs);
            return ["th", __assign$1(__assign$1({}, cellAttrs), getCustomAttrs(attrs)), 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return TableHeadCell2;
  })(Node$2)
);
var TableBodyCell = (
  /** @class */
  (function(_super) {
    __extends$1(TableBodyCell2, _super);
    function TableBodyCell2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableBodyCell2.prototype, "name", {
      get: function() {
        return "tableBodyCell";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TableBodyCell2.prototype, "schema", {
      get: function() {
        return {
          content: "(paragraph | bulletList | orderedList)+",
          attrs: {
            align: { default: null },
            className: { default: null },
            rawHTML: { default: null },
            colspan: { default: null },
            rowspan: { default: null },
            extended: { default: null }
          },
          isolating: true,
          parseDOM: [createParsedCellDOM("td")],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            var cellAttrs = createCellAttrs(attrs);
            return ["td", cellAttrs, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    return TableBodyCell2;
  })(Node$2)
);
var Image = (
  /** @class */
  (function(_super) {
    __extends$1(Image2, _super);
    function Image2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Image2.prototype, "name", {
      get: function() {
        return "image";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Image2.prototype, "schema", {
      get: function() {
        return {
          inline: true,
          attrs: __assign$1({ imageUrl: { default: "" }, altText: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          group: "inline",
          selectable: false,
          parseDOM: [
            {
              tag: "img[src]",
              getAttrs: function(dom) {
                var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true }).firstChild;
                var imageUrl = sanitizedDOM.getAttribute("src") || "";
                var rawHTML = sanitizedDOM.getAttribute("data-raw-html");
                var altText = sanitizedDOM.getAttribute("alt");
                return __assign$1({
                  imageUrl,
                  altText
                }, rawHTML && { rawHTML });
              }
            }
          ],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return [
              attrs.rawHTML || "img",
              __assign$1(__assign$1({ src: escapeXml$1(attrs.imageUrl) }, attrs.altText && { alt: attrs.altText }), getCustomAttrs(attrs))
            ];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Image2.prototype.addImage = function() {
      return function(payload) {
        return function(_a, dispatch2) {
          var schema = _a.schema, tr = _a.tr;
          var _b = payload, imageUrl = _b.imageUrl, altText = _b.altText;
          if (!imageUrl) {
            return false;
          }
          var node4 = schema.nodes.image.createAndFill(__assign$1({ imageUrl }, altText && { altText }));
          dispatch2(tr.replaceSelectionWith(node4).scrollIntoView());
          return true;
        };
      };
    };
    Image2.prototype.commands = function() {
      return {
        addImage: this.addImage()
      };
    };
    return Image2;
  })(Node$2)
);
var ROOT_BLOCK_DEPTH = 1;
var ThematicBreak = (
  /** @class */
  (function(_super) {
    __extends$1(ThematicBreak2, _super);
    function ThematicBreak2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ThematicBreak2.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ThematicBreak2.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          group: "block",
          parseDOM: [{ tag: "hr" }],
          selectable: false,
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["div", getCustomAttrs(attrs), [attrs.rawHTML || "hr"]];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    ThematicBreak2.prototype.hr = function() {
      var _this = this;
      return function() {
        return function(state, dispatch2) {
          var _a;
          var _b = state.selection, $from = _b.$from, $to = _b.$to;
          if ($from === $to) {
            var doc2 = state.doc;
            var _c = state.schema.nodes, thematicBreak2 = _c.thematicBreak, paragraph2 = _c.paragraph;
            var nodes = [thematicBreak2.create()];
            var rootBlock = $from.node(ROOT_BLOCK_DEPTH);
            var lastBlock = doc2.child(doc2.childCount - 1) === rootBlock;
            var blockEnd = doc2.resolve($from.after(ROOT_BLOCK_DEPTH));
            var nextHr = ((_a = $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.type.name) === _this.name;
            if (lastBlock || nextHr) {
              nodes.push(paragraph2.create());
            }
            dispatch2(state.tr.insert(blockEnd.pos, nodes).scrollIntoView());
            return true;
          }
          return false;
        };
      };
    };
    ThematicBreak2.prototype.commands = function() {
      return { hr: this.hr() };
    };
    ThematicBreak2.prototype.keymaps = function() {
      var hrCommand = this.hr()();
      return {
        "Mod-l": hrCommand,
        "Mod-L": hrCommand
      };
    };
    return ThematicBreak2;
  })(Node$2)
);
var Strong = (
  /** @class */
  (function(_super) {
    __extends$1(Strong2, _super);
    function Strong2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Strong2.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Strong2.prototype, "schema", {
      get: function() {
        var parseDOM = ["b", "strong"].map(function(tag) {
          return {
            tag,
            getAttrs: function(dom) {
              var rawHTML = dom.getAttribute("data-raw-html");
              return __assign$1({}, rawHTML && { rawHTML });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM,
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return [attrs.rawHTML || "strong", getCustomAttrs(attrs)];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Strong2.prototype.bold = function() {
      return function() {
        return function(state, dispatch2) {
          return toggleMark(state.schema.marks.strong)(state, dispatch2);
        };
      };
    };
    Strong2.prototype.commands = function() {
      return { bold: this.bold() };
    };
    Strong2.prototype.keymaps = function() {
      var boldCommand = this.bold()();
      return {
        "Mod-b": boldCommand,
        "Mod-B": boldCommand
      };
    };
    return Strong2;
  })(Mark3)
);
var Emph = (
  /** @class */
  (function(_super) {
    __extends$1(Emph2, _super);
    function Emph2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Emph2.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Emph2.prototype, "schema", {
      get: function() {
        var parseDOM = ["i", "em"].map(function(tag) {
          return {
            tag,
            getAttrs: function(dom) {
              var rawHTML = dom.getAttribute("data-raw-html");
              return __assign$1({}, rawHTML && { rawHTML });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM,
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return [attrs.rawHTML || "em", getCustomAttrs(attrs)];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Emph2.prototype.italic = function() {
      return function() {
        return function(state, dispatch2) {
          return toggleMark(state.schema.marks.emph)(state, dispatch2);
        };
      };
    };
    Emph2.prototype.commands = function() {
      return { italic: this.italic() };
    };
    Emph2.prototype.keymaps = function() {
      var italicCommand = this.italic()();
      return {
        "Mod-i": italicCommand,
        "Mod-I": italicCommand
      };
    };
    return Emph2;
  })(Mark3)
);
var Strike = (
  /** @class */
  (function(_super) {
    __extends$1(Strike2, _super);
    function Strike2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Strike2.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Strike2.prototype, "schema", {
      get: function() {
        var parseDOM = ["s", "del"].map(function(tag) {
          return {
            tag,
            getAttrs: function(dom) {
              var rawHTML = dom.getAttribute("data-raw-html");
              return __assign$1({}, rawHTML && { rawHTML });
            }
          };
        });
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM,
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return [attrs.rawHTML || "del", getCustomAttrs(attrs)];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Strike2.prototype.commands = function() {
      return function() {
        return function(state, dispatch2) {
          return toggleMark(state.schema.marks.strike)(state, dispatch2);
        };
      };
    };
    Strike2.prototype.keymaps = function() {
      var strikeCommand = this.commands()();
      return {
        "Mod-s": strikeCommand,
        "Mod-S": strikeCommand
      };
    };
    return Strike2;
  })(Mark3)
);
var Link = (
  /** @class */
  (function(_super) {
    __extends$1(Link2, _super);
    function Link2(linkAttributes) {
      var _this = _super.call(this) || this;
      _this.linkAttributes = linkAttributes;
      return _this;
    }
    Object.defineProperty(Link2.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Link2.prototype, "schema", {
      get: function() {
        var _this = this;
        return {
          attrs: __assign$1({ linkUrl: { default: "" }, title: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
          inclusive: false,
          parseDOM: [
            {
              tag: "a[href]",
              getAttrs: function(dom) {
                var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true }).firstChild;
                var href = sanitizedDOM.getAttribute("href") || "";
                var title = sanitizedDOM.getAttribute("title") || "";
                var rawHTML = sanitizedDOM.getAttribute("data-raw-html");
                return __assign$1({ linkUrl: href, title }, rawHTML && { rawHTML });
              }
            }
          ],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return [
              attrs.rawHTML || "a",
              __assign$1(__assign$1({ href: escapeXml$1(attrs.linkUrl) }, _this.linkAttributes), getCustomAttrs(attrs))
            ];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Link2.prototype.addLink = function() {
      return function(payload) {
        return function(state, dispatch2) {
          var _a = payload, linkUrl = _a.linkUrl, _b = _a.linkText, linkText = _b === void 0 ? "" : _b;
          var schema = state.schema, tr = state.tr, selection = state.selection;
          var empty3 = selection.empty, from4 = selection.from, to = selection.to;
          if (from4 && to && linkUrl) {
            var attrs = { linkUrl };
            var mark3 = schema.mark("link", attrs);
            if (empty3 && linkText) {
              var node4 = createTextNode$1(schema, linkText, mark3);
              tr.replaceRangeWith(from4, to, node4);
            } else {
              tr.addMark(from4, to, mark3);
            }
            dispatch2(tr.scrollIntoView());
            return true;
          }
          return false;
        };
      };
    };
    Link2.prototype.toggleLink = function() {
      return function(payload) {
        return function(state, dispatch2) {
          return toggleMark(state.schema.marks.link, payload)(state, dispatch2);
        };
      };
    };
    Link2.prototype.commands = function() {
      return {
        addLink: this.addLink(),
        toggleLink: this.toggleLink()
      };
    };
    return Link2;
  })(Mark3)
);
var Code = (
  /** @class */
  (function(_super) {
    __extends$1(Code2, _super);
    function Code2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Code2.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Code2.prototype, "schema", {
      get: function() {
        return {
          attrs: __assign$1({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
          parseDOM: [
            {
              tag: "code",
              getAttrs: function(dom) {
                var rawHTML = dom.getAttribute("data-raw-html");
                return __assign$1({}, rawHTML && { rawHTML });
              }
            }
          ],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return [attrs.rawHTML || "code", getCustomAttrs(attrs)];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    Code2.prototype.commands = function() {
      return function() {
        return function(state, dispatch2) {
          return toggleMark(state.schema.marks.code)(state, dispatch2);
        };
      };
    };
    Code2.prototype.keymaps = function() {
      var codeCommand = this.commands()();
      return {
        "Shift-Mod-c": codeCommand,
        "Shift-Mod-C": codeCommand
      };
    };
    return Code2;
  })(Mark3)
);
var CustomBlock = (
  /** @class */
  (function(_super) {
    __extends$1(CustomBlock2, _super);
    function CustomBlock2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CustomBlock2.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CustomBlock2.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: {
            info: { default: null }
          },
          atom: true,
          code: true,
          defining: true,
          parseDOM: [
            {
              tag: "div[data-custom-info]",
              getAttrs: function(dom) {
                var info = dom.getAttribute("data-custom-info");
                return { info };
              }
            }
          ],
          toDOM: function(_a) {
            var attrs = _a.attrs;
            return ["div", { "data-custom-info": attrs.info || null }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    CustomBlock2.prototype.commands = function() {
      return function(payload) {
        return function(state, dispatch2) {
          return (payload === null || payload === void 0 ? void 0 : payload.info) ? setBlockType(state.schema.nodes.customBlock, payload)(state, dispatch2) : false;
        };
      };
    };
    return CustomBlock2;
  })(Node$2)
);
var FrontMatter = (
  /** @class */
  (function(_super) {
    __extends$1(FrontMatter2, _super);
    function FrontMatter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(FrontMatter2.prototype, "name", {
      get: function() {
        return "frontMatter";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FrontMatter2.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: true,
          defining: true,
          parseDOM: [
            {
              preserveWhitespace: "full",
              tag: "div[data-front-matter]"
            }
          ],
          toDOM: function() {
            return ["div", { "data-front-matter": "true" }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    FrontMatter2.prototype.commands = function() {
      return function() {
        return function(state, dispatch2, view) {
          var $from = state.selection.$from;
          if (view.endOfTextblock("down") && $from.node().type.name === "frontMatter") {
            return exitCode(state, dispatch2);
          }
          return false;
        };
      };
    };
    FrontMatter2.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    };
    return FrontMatter2;
  })(Node$2)
);
var HTMLComment = (
  /** @class */
  (function(_super) {
    __extends$1(HTMLComment2, _super);
    function HTMLComment2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(HTMLComment2.prototype, "name", {
      get: function() {
        return "htmlComment";
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(HTMLComment2.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: true,
          defining: true,
          parseDOM: [{ preserveWhitespace: "full", tag: "div[data-html-comment]" }],
          toDOM: function() {
            return ["div", { "data-html-comment": "true" }, 0];
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    HTMLComment2.prototype.commands = function() {
      return function() {
        return function(state, dispatch2, view) {
          var $from = state.selection.$from;
          if (view.endOfTextblock("down") && $from.node().type.name === "htmlComment") {
            return exitCode(state, dispatch2);
          }
          return false;
        };
      };
    };
    HTMLComment2.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    };
    return HTMLComment2;
  })(Node$2)
);
function createSpecs(linkAttributes) {
  return new SpecManager([
    new Doc(),
    new Paragraph(),
    new Text(),
    new Heading(),
    new CodeBlock(),
    new BulletList(),
    new OrderedList(),
    new ListItem(),
    new BlockQuote(),
    new Table(),
    new TableHead(),
    new TableBody(),
    new TableRow(),
    new TableHeadCell(),
    new TableBodyCell(),
    new Image(),
    new ThematicBreak(),
    new Strong(),
    new Emph(),
    new Strike(),
    new Link(linkAttributes),
    new Code(),
    new CustomBlock(),
    new FrontMatter(),
    new Widget(),
    new HTMLComment()
  ]);
}
var CONTENTS_CLASS_NAME = cls("contents");
var WysiwygEditor = (
  /** @class */
  (function(_super) {
    __extends$1(WysiwygEditor2, _super);
    function WysiwygEditor2(eventEmitter, options) {
      var _this = _super.call(this, eventEmitter) || this;
      var toDOMAdaptor = options.toDOMAdaptor, _a = options.htmlSchemaMap, htmlSchemaMap = _a === void 0 ? {} : _a, _b = options.linkAttributes, linkAttributes = _b === void 0 ? {} : _b, _c = options.useCommandShortcut, useCommandShortcut = _c === void 0 ? true : _c, _d = options.wwPlugins, wwPlugins = _d === void 0 ? [] : _d, _e = options.wwNodeViews, wwNodeViews = _e === void 0 ? {} : _e;
      _this.editorType = "wysiwyg";
      _this.el.classList.add("ww-mode");
      _this.toDOMAdaptor = toDOMAdaptor;
      _this.linkAttributes = linkAttributes;
      _this.extraPlugins = wwPlugins;
      _this.pluginNodeViews = wwNodeViews;
      _this.specs = _this.createSpecs();
      _this.schema = _this.createSchema(htmlSchemaMap);
      _this.context = _this.createContext();
      _this.keymaps = _this.createKeymaps(useCommandShortcut);
      _this.view = _this.createView();
      _this.commands = _this.createCommands();
      _this.specs.setContext(__assign$1(__assign$1({}, _this.context), { view: _this.view }));
      _this.initEvent();
      return _this;
    }
    WysiwygEditor2.prototype.createSpecs = function() {
      return createSpecs(this.linkAttributes);
    };
    WysiwygEditor2.prototype.createContext = function() {
      return {
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    };
    WysiwygEditor2.prototype.createSchema = function(htmlSchemaMap) {
      return new Schema({
        nodes: __assign$1(__assign$1({}, this.specs.nodes), htmlSchemaMap.nodes),
        marks: __assign$1(__assign$1({}, this.specs.marks), htmlSchemaMap.marks)
      });
    };
    WysiwygEditor2.prototype.createPlugins = function() {
      return __spreadArray$1([
        tableSelection(),
        tableContextMenu(this.eventEmitter),
        task(),
        toolbarStateHighlight(this.eventEmitter)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    };
    WysiwygEditor2.prototype.createPluginNodeViews = function() {
      var _a = this, eventEmitter = _a.eventEmitter, pluginNodeViews = _a.pluginNodeViews;
      var pluginNodeViewMap = {};
      if (pluginNodeViews) {
        Object.keys(pluginNodeViews).forEach(function(key) {
          pluginNodeViewMap[key] = function(node4, view, getPos) {
            return pluginNodeViews[key](node4, view, getPos, eventEmitter);
          };
        });
      }
      return pluginNodeViewMap;
    };
    WysiwygEditor2.prototype.createView = function() {
      var _this = this;
      var _a = this, toDOMAdaptor = _a.toDOMAdaptor, eventEmitter = _a.eventEmitter;
      return new EditorView(this.el, {
        state: this.createState(),
        attributes: {
          class: CONTENTS_CLASS_NAME
        },
        nodeViews: __assign$1({
          customBlock: function(node4, view, getPos) {
            return new CustomBlockView(node4, view, getPos, toDOMAdaptor);
          },
          image: function(node4, view, getPos) {
            return new ImageView(node4, view, getPos, eventEmitter);
          },
          codeBlock: function(node4, view, getPos) {
            return new CodeBlockView(node4, view, getPos, eventEmitter);
          },
          widget: widgetNodeView
        }, this.createPluginNodeViews()),
        dispatchTransaction: function(tr) {
          var state = _this.view.state.applyTransaction(tr).state;
          _this.view.updateState(state);
          _this.emitChangeEvent(tr.scrollIntoView());
          _this.eventEmitter.emit("setFocusedNode", state.selection.$from.node(1));
        },
        transformPastedHTML: changePastedHTML,
        transformPasted: function(slice4) {
          return changePastedSlice(slice4, _this.schema, isInTableNode(_this.view.state.selection.$from));
        },
        handlePaste: function(view, _, slice4) {
          return pasteToTable(view, slice4);
        },
        handleKeyDown: function(_, ev) {
          _this.eventEmitter.emit("keydown", _this.editorType, ev);
          return false;
        },
        handleDOMEvents: {
          paste: function(_, ev) {
            var clipboardData = ev.clipboardData || window.clipboardData;
            var items = clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.items;
            if (items) {
              var containRtfItem = toArray_1(items).some(function(item2) {
                return item2.kind === "string" && item2.type === "text/rtf";
              });
              if (!containRtfItem) {
                var imageBlob = pasteImageOnly(items);
                if (imageBlob) {
                  ev.preventDefault();
                  emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);
                }
              }
            }
            return false;
          },
          keyup: function(_, ev) {
            _this.eventEmitter.emit("keyup", _this.editorType, ev);
            return false;
          },
          scroll: function() {
            _this.eventEmitter.emit("scroll", "editor");
            return true;
          }
        }
      });
    };
    WysiwygEditor2.prototype.createCommands = function() {
      return this.specs.commands(this.view, getWwCommands());
    };
    WysiwygEditor2.prototype.getHTML = function() {
      return this.view.dom.innerHTML;
    };
    WysiwygEditor2.prototype.getModel = function() {
      return this.view.state.doc;
    };
    WysiwygEditor2.prototype.getSelection = function() {
      var _a = this.view.state.selection, from4 = _a.from, to = _a.to;
      return [from4, to];
    };
    WysiwygEditor2.prototype.getSchema = function() {
      return this.view.state.schema;
    };
    WysiwygEditor2.prototype.replaceSelection = function(text3, start3, end2) {
      var _a = this.view.state, schema = _a.schema, tr = _a.tr;
      var lineTexts = text3.split("\n");
      var paras = lineTexts.map(function(lineText) {
        return createParagraph(schema, createNodesWithWidget(lineText, schema));
      });
      var slice4 = new Slice(Fragment.from(paras), 1, 1);
      var newTr = isNumber_1(start3) && isNumber_1(end2) ? tr.replaceRange(start3, end2, slice4) : tr.replaceSelection(slice4);
      this.view.dispatch(newTr);
      this.focus();
    };
    WysiwygEditor2.prototype.deleteSelection = function(start3, end2) {
      var tr = this.view.state.tr;
      var newTr = isNumber_1(start3) && isNumber_1(end2) ? tr.deleteRange(start3, end2) : tr.deleteSelection();
      this.view.dispatch(newTr.scrollIntoView());
    };
    WysiwygEditor2.prototype.getSelectedText = function(start3, end2) {
      var _a = this.view.state, doc2 = _a.doc, selection = _a.selection;
      var from4 = selection.from, to = selection.to;
      if (isNumber_1(start3) && isNumber_1(end2)) {
        from4 = start3;
        to = end2;
      }
      return doc2.textBetween(from4, to, "\n");
    };
    WysiwygEditor2.prototype.setModel = function(newDoc, cursorToEnd) {
      if (cursorToEnd === void 0) {
        cursorToEnd = false;
      }
      var _a = this.view.state, tr = _a.tr, doc2 = _a.doc;
      this.view.dispatch(tr.replaceWith(0, doc2.content.size, newDoc));
      if (cursorToEnd) {
        this.moveCursorToEnd(true);
      }
    };
    WysiwygEditor2.prototype.setSelection = function(start3, end2) {
      if (end2 === void 0) {
        end2 = start3;
      }
      var tr = this.view.state.tr;
      var selection = createTextSelection(tr, start3, end2);
      this.view.dispatch(tr.setSelection(selection).scrollIntoView());
    };
    WysiwygEditor2.prototype.addWidget = function(node4, style, pos) {
      var _a = this.view, dispatch2 = _a.dispatch, state = _a.state;
      dispatch2(state.tr.setMeta("widget", { pos: pos !== null && pos !== void 0 ? pos : state.selection.to, node: node4, style }));
    };
    WysiwygEditor2.prototype.replaceWithWidget = function(start3, end2, text3) {
      var _a = this.view.state, tr = _a.tr, schema = _a.schema;
      var nodes = createNodesWithWidget(text3, schema);
      this.view.dispatch(tr.replaceWith(start3, end2, nodes));
    };
    WysiwygEditor2.prototype.getRangeInfoOfNode = function(pos) {
      var _a = this.view.state, doc2 = _a.doc, selection = _a.selection;
      var $pos = pos ? doc2.resolve(pos) : selection.$from;
      var marks2 = $pos.marks();
      var node4 = $pos.node();
      var start3 = $pos.start();
      var end2 = $pos.end();
      var type = node4.type.name;
      if (marks2.length || type === "paragraph") {
        var mark_1 = marks2[marks2.length - 1];
        var maybeHasMark_1 = function(nodeMarks) {
          return nodeMarks.length ? includes2(nodeMarks, mark_1) : true;
        };
        type = mark_1 ? mark_1.type.name : "text";
        node4.forEach(function(child3, offset2) {
          var isText = child3.isText, nodeSize2 = child3.nodeSize, nodeMarks = child3.marks;
          var startOffset = $pos.pos - start3;
          if (isText && offset2 <= startOffset && offset2 + nodeSize2 >= startOffset && maybeHasMark_1(nodeMarks)) {
            start3 = start3 + offset2;
            end2 = start3 + nodeSize2;
          }
        });
      }
      return { range: [start3, end2], type };
    };
    return WysiwygEditor2;
  })(EditorBase)
);
var isUndefined2 = isUndefined_1;
var isNull2 = isNull_1;
function isExisty$1(param) {
  return !isUndefined2(param) && !isNull2(param);
}
var isExisty_1 = isExisty$1;
var isExisty = isExisty_1;
function isTruthy$1(obj) {
  return isExisty(obj) && obj !== false;
}
var isTruthy_1 = isTruthy$1;
var isTruthy = isTruthy_1;
function isFalsy(obj) {
  return !isTruthy(obj);
}
var isFalsy_1 = isFalsy;
var eventTypeList = [
  "afterPreviewRender",
  "updatePreview",
  "changeMode",
  "needChangeMode",
  "command",
  "changePreviewStyle",
  "changePreviewTabPreview",
  "changePreviewTabWrite",
  "scroll",
  "contextmenu",
  "show",
  "hide",
  "changeLanguage",
  "changeToolbarState",
  "toggleScrollSync",
  "mixinTableOffsetMapPrototype",
  "setFocusedNode",
  "removePopupWidget",
  "query",
  // provide event for user
  "openPopup",
  "closePopup",
  "addImageBlobHook",
  "beforePreviewRender",
  "beforeConvertWysiwygToMarkdown",
  "load",
  "loadUI",
  "change",
  "caretChange",
  "destroy",
  "focus",
  "blur",
  "keydown",
  "keyup"
];
var EventEmitter = (
  /** @class */
  (function() {
    function EventEmitter2() {
      var _this = this;
      this.events = new Map$1();
      this.eventTypes = eventTypeList.reduce(function(types, type) {
        return __assign$1(__assign$1({}, types), { type });
      }, {});
      this.hold = false;
      eventTypeList.forEach(function(eventType) {
        _this.addEventType(eventType);
      });
    }
    EventEmitter2.prototype.listen = function(type, handler) {
      var typeInfo = this.getTypeInfo(type);
      var eventHandlers = this.events.get(typeInfo.type) || [];
      if (!this.hasEventType(typeInfo.type)) {
        throw new Error("There is no event type " + typeInfo.type);
      }
      if (typeInfo.namespace) {
        handler.namespace = typeInfo.namespace;
      }
      eventHandlers.push(handler);
      this.events.set(typeInfo.type, eventHandlers);
    };
    EventEmitter2.prototype.emit = function(type) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var typeInfo = this.getTypeInfo(type);
      var eventHandlers = this.events.get(typeInfo.type);
      var results = [];
      if (!this.hold && eventHandlers) {
        eventHandlers.forEach(function(handler) {
          var result2 = handler.apply(void 0, args);
          if (!isUndefined_1(result2)) {
            results.push(result2);
          }
        });
      }
      return results;
    };
    EventEmitter2.prototype.emitReduce = function(type, source) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var eventHandlers = this.events.get(type);
      if (!this.hold && eventHandlers) {
        eventHandlers.forEach(function(handler) {
          var result2 = handler.apply(void 0, __spreadArray$1([source], args));
          if (!isFalsy_1(result2)) {
            source = result2;
          }
        });
      }
      return source;
    };
    EventEmitter2.prototype.getTypeInfo = function(type) {
      var splited = type.split(".");
      return {
        type: splited[0],
        namespace: splited[1]
      };
    };
    EventEmitter2.prototype.hasEventType = function(type) {
      return !isUndefined_1(this.eventTypes[this.getTypeInfo(type).type]);
    };
    EventEmitter2.prototype.addEventType = function(type) {
      if (this.hasEventType(type)) {
        throw new Error("There is already have event type " + type);
      }
      this.eventTypes[type] = type;
    };
    EventEmitter2.prototype.removeEventHandler = function(eventType, handler) {
      var _this = this;
      var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;
      if (type && handler) {
        this.removeEventHandlerWithHandler(type, handler);
      } else if (type && !namespace) {
        this.events.delete(type);
      } else if (!type && namespace) {
        this.events.forEach(function(_, evtType) {
          _this.removeEventHandlerWithTypeInfo(evtType, namespace);
        });
      } else if (type && namespace) {
        this.removeEventHandlerWithTypeInfo(type, namespace);
      }
    };
    EventEmitter2.prototype.removeEventHandlerWithHandler = function(type, handler) {
      var eventHandlers = this.events.get(type);
      if (eventHandlers) {
        var handlerIndex = eventHandlers.indexOf(handler);
        if (eventHandlers.indexOf(handler) >= 0) {
          eventHandlers.splice(handlerIndex, 1);
        }
      }
    };
    EventEmitter2.prototype.removeEventHandlerWithTypeInfo = function(type, namespace) {
      var handlersToSurvive = [];
      var eventHandlers = this.events.get(type);
      if (!eventHandlers) {
        return;
      }
      eventHandlers.map(function(handler) {
        if (handler.namespace !== namespace) {
          handlersToSurvive.push(handler);
        }
        return null;
      });
      this.events.set(type, handlersToSurvive);
    };
    EventEmitter2.prototype.getEvents = function() {
      return this.events;
    };
    EventEmitter2.prototype.holdEventInvoke = function(fn) {
      this.hold = true;
      fn();
      this.hold = false;
    };
    return EventEmitter2;
  })()
);
var CommandManager = (
  /** @class */
  (function() {
    function CommandManager2(eventEmitter, mdCommands, wwCommands, getEditorType) {
      this.eventEmitter = eventEmitter;
      this.mdCommands = mdCommands;
      this.wwCommands = wwCommands;
      this.getEditorType = getEditorType;
      this.initEvent();
    }
    CommandManager2.prototype.initEvent = function() {
      var _this = this;
      this.eventEmitter.listen("command", function(command, payload) {
        _this.exec(command, payload);
      });
    };
    CommandManager2.prototype.addCommand = function(type, name, command) {
      if (type === "markdown") {
        this.mdCommands[name] = command;
      } else {
        this.wwCommands[name] = command;
      }
    };
    CommandManager2.prototype.deleteCommand = function(type, name) {
      if (type === "markdown") {
        delete this.mdCommands[name];
      } else {
        delete this.wwCommands[name];
      }
    };
    CommandManager2.prototype.exec = function(name, payload) {
      var type = this.getEditorType();
      if (type === "markdown") {
        this.mdCommands[name](payload);
      } else {
        this.wwCommands[name](payload);
      }
    };
    return CommandManager2;
  })()
);
function getTextWithoutTrailingNewline(text3) {
  return text3[text3.length - 1] === "\n" ? text3.slice(0, text3.length - 1) : text3;
}
function isCustomHTMLInlineNode(_a, node4) {
  var schema = _a.schema;
  var html2 = node4.literal;
  var matched = html2.match(reHTMLTag);
  if (matched) {
    var openTagName = matched[1], closeTagName = matched[3];
    var typeName = (openTagName || closeTagName).toLowerCase();
    return node4.type === "htmlInline" && !!(schema.marks[typeName] || schema.nodes[typeName]);
  }
  return false;
}
function isInlineNode(_a) {
  var type = _a.type;
  return includes2(["text", "strong", "emph", "strike", "image", "link", "code"], type);
}
function isSoftbreak(mdNode) {
  return (mdNode === null || mdNode === void 0 ? void 0 : mdNode.type) === "softbreak";
}
function isListNode(_a) {
  var type = _a.type, literal = _a.literal;
  var matched = type === "htmlInline" && literal.match(reHTMLTag);
  if (matched) {
    var openTagName = matched[1], closeTagName = matched[3];
    var tagName = openTagName || closeTagName;
    if (tagName) {
      return includes2(["ul", "ol", "li"], tagName.toLowerCase());
    }
  }
  return false;
}
function getListItemAttrs(_a) {
  var literal = _a.literal;
  var task2 = /data-task/.test(literal);
  var checked = /data-task-checked/.test(literal);
  return { task: task2, checked };
}
function getMatchedAttributeValue(rawHTML) {
  var attrNames = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    attrNames[_i - 1] = arguments[_i];
  }
  var wrapper = document.createElement("div");
  wrapper.innerHTML = sanitizeHTML(rawHTML);
  var el2 = wrapper.firstChild;
  return attrNames.map(function(attrName) {
    return el2.getAttribute(attrName) || "";
  });
}
function createConvertors(convertors2) {
  var convertorMap = {};
  Object.keys(convertors2).forEach(function(key) {
    var tagNames = key.split(", ");
    tagNames.forEach(function(tagName) {
      var name = tagName.toLowerCase();
      convertorMap[name] = convertors2[key];
    });
  });
  return convertorMap;
}
var convertors = {
  "b, strong": function(state, _, openTagName) {
    var strong = state.schema.marks.strong;
    if (openTagName) {
      state.openMark(strong.create({ rawHTML: openTagName }));
    } else {
      state.closeMark(strong);
    }
  },
  "i, em": function(state, _, openTagName) {
    var emph = state.schema.marks.emph;
    if (openTagName) {
      state.openMark(emph.create({ rawHTML: openTagName }));
    } else {
      state.closeMark(emph);
    }
  },
  "s, del": function(state, _, openTagName) {
    var strike = state.schema.marks.strike;
    if (openTagName) {
      state.openMark(strike.create({ rawHTML: openTagName }));
    } else {
      state.closeMark(strike);
    }
  },
  code: function(state, _, openTagName) {
    var code2 = state.schema.marks.code;
    if (openTagName) {
      state.openMark(code2.create({ rawHTML: openTagName }));
    } else {
      state.closeMark(code2);
    }
  },
  a: function(state, node4, openTagName) {
    var tag = node4.literal;
    var link2 = state.schema.marks.link;
    if (openTagName) {
      var linkUrl = getMatchedAttributeValue(tag, "href")[0];
      state.openMark(link2.create({
        linkUrl,
        rawHTML: openTagName
      }));
    } else {
      state.closeMark(link2);
    }
  },
  img: function(state, node4, openTagName) {
    var tag = node4.literal;
    if (openTagName) {
      var _a = getMatchedAttributeValue(tag, "src", "alt"), imageUrl = _a[0], altText = _a[1];
      var image2 = state.schema.nodes.image;
      state.addNode(image2, __assign$1({ rawHTML: openTagName, imageUrl }, altText && { altText }));
    }
  },
  hr: function(state, _, openTagName) {
    state.addNode(state.schema.nodes.thematicBreak, { rawHTML: openTagName });
  },
  br: function(state, node4) {
    var paragraph2 = state.schema.nodes.paragraph;
    var parent = node4.parent, prev = node4.prev, next = node4.next;
    if ((parent === null || parent === void 0 ? void 0 : parent.type) === "paragraph") {
      if (isSoftbreak(prev)) {
        state.openNode(paragraph2);
      }
      if (isSoftbreak(next)) {
        state.closeNode();
      } else if (next) {
        state.closeNode();
        state.openNode(paragraph2);
      }
    } else if ((parent === null || parent === void 0 ? void 0 : parent.type) === "tableCell") {
      if (prev && (isInlineNode(prev) || isCustomHTMLInlineNode(state, prev))) {
        state.closeNode();
      }
      if (next && (isInlineNode(next) || isCustomHTMLInlineNode(state, next))) {
        state.openNode(paragraph2);
      }
    }
  },
  pre: function(state, node4, openTagName) {
    var _a, _b;
    var container = document.createElement("div");
    container.innerHTML = node4.literal;
    var literal = (_b = (_a = container.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.textContent;
    state.openNode(state.schema.nodes.codeBlock, { rawHTML: openTagName });
    state.addText(getTextWithoutTrailingNewline(literal));
    state.closeNode();
  },
  "ul, ol": function(state, node4, openTagName) {
    if (node4.parent.type === "tableCell") {
      var _a = state.schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList, paragraph2 = _a.paragraph;
      var list2 = openTagName === "ul" ? bulletList : orderedList;
      if (openTagName) {
        if (node4.prev && !isListNode(node4.prev)) {
          state.closeNode();
        }
        state.openNode(list2, { rawHTML: openTagName });
      } else {
        state.closeNode();
        if (node4.next && !isListNode(node4.next)) {
          state.openNode(paragraph2);
        }
      }
    }
  },
  li: function(state, node4, openTagName) {
    var _a;
    if (((_a = node4.parent) === null || _a === void 0 ? void 0 : _a.type) === "tableCell") {
      var _b = state.schema.nodes, listItem2 = _b.listItem, paragraph2 = _b.paragraph;
      if (openTagName) {
        var attrs = getListItemAttrs(node4);
        if (node4.prev && !isListNode(node4.prev)) {
          state.closeNode();
        }
        state.openNode(listItem2, __assign$1({ rawHTML: openTagName }, attrs));
        if (node4.next && !isListNode(node4.next)) {
          state.openNode(paragraph2);
        }
      } else {
        if (node4.prev && !isListNode(node4.prev)) {
          state.closeNode();
        }
        state.closeNode();
      }
    }
  }
};
var htmlToWwConvertors = createConvertors(convertors);
function isBRTag(node4) {
  return node4.type === "htmlInline" && reBR2.test(node4.literal);
}
function addRawHTMLAttributeToDOM(parent) {
  toArray_1(parent.childNodes).forEach(function(child3) {
    if (isElemNode(child3)) {
      var openTagName = child3.nodeName.toLowerCase();
      child3.setAttribute("data-raw-html", openTagName);
      if (child3.childNodes) {
        addRawHTMLAttributeToDOM(child3);
      }
    }
  });
}
var toWwConvertors = {
  text: function(state, node4) {
    state.addText(node4.literal || "");
  },
  paragraph: function(state, node4, _a, customAttrs) {
    var _b;
    var entering = _a.entering;
    if (entering) {
      var paragraph2 = state.schema.nodes.paragraph;
      if (((_b = node4.prev) === null || _b === void 0 ? void 0 : _b.type) === "paragraph") {
        state.openNode(paragraph2, customAttrs);
        state.closeNode();
      }
      state.openNode(paragraph2, customAttrs);
    } else {
      state.closeNode();
    }
  },
  heading: function(state, node4, _a, customAttrs) {
    var entering = _a.entering;
    if (entering) {
      var _b = node4, level = _b.level, headingType = _b.headingType;
      state.openNode(state.schema.nodes.heading, __assign$1({ level, headingType }, customAttrs));
    } else {
      state.closeNode();
    }
  },
  codeBlock: function(state, node4, customAttrs) {
    var codeBlock2 = state.schema.nodes.codeBlock;
    var _a = node4, info = _a.info, literal = _a.literal;
    state.openNode(codeBlock2, __assign$1({ language: info }, customAttrs));
    state.addText(getTextWithoutTrailingNewline(literal || ""));
    state.closeNode();
  },
  list: function(state, node4, _a, customAttrs) {
    var entering = _a.entering;
    if (entering) {
      var _b = state.schema.nodes, bulletList = _b.bulletList, orderedList = _b.orderedList;
      var _c = node4.listData, type = _c.type, start3 = _c.start;
      if (type === "bullet") {
        state.openNode(bulletList, customAttrs);
      } else {
        state.openNode(orderedList, __assign$1({ order: start3 }, customAttrs));
      }
    } else {
      state.closeNode();
    }
  },
  item: function(state, node4, _a, customAttrs) {
    var entering = _a.entering;
    var listItem2 = state.schema.nodes.listItem;
    var _b = node4.listData, task2 = _b.task, checked = _b.checked;
    if (entering) {
      var attrs = __assign$1(__assign$1(__assign$1({}, task2 && { task: task2 }), checked && { checked }), customAttrs);
      state.openNode(listItem2, attrs);
    } else {
      state.closeNode();
    }
  },
  blockQuote: function(state, _, _a, customAttrs) {
    var entering = _a.entering;
    if (entering) {
      state.openNode(state.schema.nodes.blockQuote, customAttrs);
    } else {
      state.closeNode();
    }
  },
  image: function(state, node4, _a, customAttrs) {
    var entering = _a.entering, skipChildren = _a.skipChildren;
    var image2 = state.schema.nodes.image;
    var _b = node4, destination = _b.destination, firstChild = _b.firstChild;
    if (entering && skipChildren) {
      skipChildren();
    }
    state.addNode(image2, __assign$1(__assign$1({ imageUrl: destination }, firstChild && { altText: firstChild.literal }), customAttrs));
  },
  thematicBreak: function(state, node4, _, customAttrs) {
    state.addNode(state.schema.nodes.thematicBreak, customAttrs);
  },
  strong: function(state, _, _a, customAttrs) {
    var entering = _a.entering;
    var strong = state.schema.marks.strong;
    if (entering) {
      state.openMark(strong.create(customAttrs));
    } else {
      state.closeMark(strong);
    }
  },
  emph: function(state, _, _a, customAttrs) {
    var entering = _a.entering;
    var emph = state.schema.marks.emph;
    if (entering) {
      state.openMark(emph.create(customAttrs));
    } else {
      state.closeMark(emph);
    }
  },
  link: function(state, node4, _a, customAttrs) {
    var entering = _a.entering;
    var link2 = state.schema.marks.link;
    var _b = node4, destination = _b.destination, title = _b.title;
    if (entering) {
      var attrs = __assign$1({ linkUrl: destination, title }, customAttrs);
      state.openMark(link2.create(attrs));
    } else {
      state.closeMark(link2);
    }
  },
  softbreak: function(state, node4) {
    if (node4.parent.type === "paragraph") {
      var prev = node4.prev, next = node4.next;
      if (prev && !isBRTag(prev)) {
        state.closeNode();
      }
      if (next && !isBRTag(next)) {
        state.openNode(state.schema.nodes.paragraph);
      }
    }
  },
  // GFM specifications node
  table: function(state, _, _a, customAttrs) {
    var entering = _a.entering;
    if (entering) {
      state.openNode(state.schema.nodes.table, customAttrs);
    } else {
      state.closeNode();
    }
  },
  tableHead: function(state, _, _a, customAttrs) {
    var entering = _a.entering;
    if (entering) {
      state.openNode(state.schema.nodes.tableHead, customAttrs);
    } else {
      state.closeNode();
    }
  },
  tableBody: function(state, _, _a, customAttrs) {
    var entering = _a.entering;
    if (entering) {
      state.openNode(state.schema.nodes.tableBody, customAttrs);
    } else {
      state.closeNode();
    }
  },
  tableRow: function(state, _, _a, customAttrs) {
    var entering = _a.entering;
    if (entering) {
      state.openNode(state.schema.nodes.tableRow, customAttrs);
    } else {
      state.closeNode();
    }
  },
  tableCell: function(state, node4, _a) {
    var entering = _a.entering;
    if (!node4.ignored) {
      var hasParaNode = function(childNode) {
        return childNode && (isInlineNode(childNode) || isCustomHTMLInlineNode(state, childNode));
      };
      if (entering) {
        var _b = state.schema.nodes, tableHeadCell = _b.tableHeadCell, tableBodyCell = _b.tableBodyCell, paragraph2 = _b.paragraph;
        var tablePart = node4.parent.parent;
        var cell = tablePart.type === "tableHead" ? tableHeadCell : tableBodyCell;
        var table2 = tablePart.parent;
        var align = (table2.columns[node4.startIdx] || {}).align;
        var attrs = __assign$1({}, node4.attrs);
        if (align) {
          attrs.align = align;
        }
        state.openNode(cell, attrs);
        if (hasParaNode(node4.firstChild)) {
          state.openNode(paragraph2);
        }
      } else {
        if (hasParaNode(node4.lastChild)) {
          state.closeNode();
        }
        state.closeNode();
      }
    }
  },
  strike: function(state, _, _a, customAttrs) {
    var entering = _a.entering;
    var strike = state.schema.marks.strike;
    if (entering) {
      state.openMark(strike.create(customAttrs));
    } else {
      state.closeMark(strike);
    }
  },
  code: function(state, node4, _, customAttrs) {
    var code2 = state.schema.marks.code;
    state.openMark(code2.create(customAttrs));
    state.addText(getTextWithoutTrailingNewline(node4.literal || ""));
    state.closeMark(code2);
  },
  customBlock: function(state, node4) {
    var _a = state.schema.nodes, customBlock2 = _a.customBlock, paragraph2 = _a.paragraph;
    var _b = node4, info = _b.info, literal = _b.literal;
    state.openNode(customBlock2, { info });
    state.addText(getTextWithoutTrailingNewline(literal || ""));
    state.closeNode();
    if (!node4.next) {
      state.openNode(paragraph2);
      state.closeNode();
    }
  },
  frontMatter: function(state, node4) {
    state.openNode(state.schema.nodes.frontMatter);
    state.addText(node4.literal);
    state.closeNode();
  },
  htmlInline: function(state, node4) {
    var html2 = node4.literal;
    var matched = html2.match(reHTMLTag);
    var openTagName = matched[1], closeTagName = matched[3];
    var typeName = (openTagName || closeTagName).toLowerCase();
    var markType = state.schema.marks[typeName];
    var sanitizedHTML = sanitizeHTML(html2);
    if (markType === null || markType === void 0 ? void 0 : markType.spec.attrs.htmlInline) {
      if (openTagName) {
        var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);
        state.openMark(markType.create({ htmlAttrs }));
      } else {
        state.closeMark(markType);
      }
    } else {
      var htmlToWwConvertor = htmlToWwConvertors[typeName];
      if (htmlToWwConvertor) {
        htmlToWwConvertor(state, node4, openTagName);
      }
    }
  },
  htmlBlock: function(state, node4) {
    var html2 = node4.literal;
    var container = document.createElement("div");
    var isHTMLComment = reHTMLComment.test(html2);
    if (isHTMLComment) {
      state.openNode(state.schema.nodes.htmlComment);
      state.addText(node4.literal);
      state.closeNode();
    } else {
      var matched = html2.match(reHTMLTag);
      var openTagName = matched[1], closeTagName = matched[3];
      var typeName = (openTagName || closeTagName).toLowerCase();
      var nodeType2 = state.schema.nodes[typeName];
      var sanitizedHTML = sanitizeHTML(html2);
      if (nodeType2 === null || nodeType2 === void 0 ? void 0 : nodeType2.spec.attrs.htmlBlock) {
        var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);
        var childrenHTML = getChildrenHTML(node4, typeName);
        state.addNode(nodeType2, { htmlAttrs, childrenHTML });
      } else {
        container.innerHTML = sanitizedHTML;
        addRawHTMLAttributeToDOM(container);
        state.convertByDOMParser(container);
      }
    }
  },
  customInline: function(state, node4, _a) {
    var entering = _a.entering, skipChildren = _a.skipChildren;
    var _b = node4, info = _b.info, firstChild = _b.firstChild;
    var schema = state.schema;
    if (info.indexOf("widget") !== -1 && entering) {
      var content2 = getWidgetContent(node4);
      skipChildren();
      state.addNode(schema.nodes.widget, { info }, [
        schema.text(createWidgetContent(info, content2))
      ]);
    } else {
      var text3 = "$$";
      if (entering) {
        text3 += firstChild ? info + " " : info;
      }
      state.addText(text3);
    }
  }
};
function createWwConvertors(customConvertors) {
  var customConvertorTypes = Object.keys(customConvertors);
  var convertors2 = __assign$1({}, toWwConvertors);
  var renderer = new Renderer({
    gfm: true,
    nodeId: true,
    convertors: customConvertors
  });
  var orgConvertors = renderer.getConvertors();
  customConvertorTypes.forEach(function(type) {
    var wwConvertor = toWwConvertors[type];
    if (wwConvertor && !includes2(["htmlBlock", "htmlInline"], type)) {
      convertors2[type] = function(state, node4, context) {
        context.origin = function() {
          return orgConvertors[type](node4, context, orgConvertors);
        };
        var tokens = customConvertors[type](node4, context);
        var attrs;
        if (tokens) {
          var _a = Array.isArray(tokens) ? tokens[0] : tokens, htmlAttrs = _a.attributes, classNames = _a.classNames;
          attrs = { htmlAttrs, classNames };
        }
        wwConvertor(state, node4, context, attrs);
      };
    }
  });
  return convertors2;
}
function mergeMarkText(a, b) {
  if (a.isText && b.isText && Mark.sameSet(a.marks, b.marks)) {
    return a.withText(a.text + b.text);
  }
  return false;
}
var ToWwConvertorState = (
  /** @class */
  (function() {
    function ToWwConvertorState2(schema, convertors2) {
      this.schema = schema;
      this.convertors = convertors2;
      this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }];
      this.marks = Mark.none;
    }
    ToWwConvertorState2.prototype.top = function() {
      return last$1(this.stack);
    };
    ToWwConvertorState2.prototype.push = function(node4) {
      if (this.stack.length) {
        this.top().content.push(node4);
      }
    };
    ToWwConvertorState2.prototype.addText = function(text3) {
      if (text3) {
        var nodes = this.top().content;
        var lastNode = last$1(nodes);
        var node4 = this.schema.text(text3, this.marks);
        var merged = lastNode && mergeMarkText(lastNode, node4);
        if (merged) {
          nodes[nodes.length - 1] = merged;
        } else {
          nodes.push(node4);
        }
      }
    };
    ToWwConvertorState2.prototype.openMark = function(mark3) {
      this.marks = mark3.addToSet(this.marks);
    };
    ToWwConvertorState2.prototype.closeMark = function(mark3) {
      this.marks = mark3.removeFromSet(this.marks);
    };
    ToWwConvertorState2.prototype.addNode = function(type, attrs, content2) {
      var node4 = type.createAndFill(attrs, content2, this.marks);
      if (node4) {
        this.push(node4);
        return node4;
      }
      return null;
    };
    ToWwConvertorState2.prototype.openNode = function(type, attrs) {
      this.stack.push({ type, attrs, content: [] });
    };
    ToWwConvertorState2.prototype.closeNode = function() {
      if (this.marks.length) {
        this.marks = Mark.none;
      }
      var _a = this.stack.pop(), type = _a.type, attrs = _a.attrs, content2 = _a.content;
      return this.addNode(type, attrs, content2);
    };
    ToWwConvertorState2.prototype.convertByDOMParser = function(root) {
      var _this = this;
      var doc2 = DOMParser.fromSchema(this.schema).parse(root);
      doc2.content.forEach(function(node4) {
        return _this.push(node4);
      });
    };
    ToWwConvertorState2.prototype.closeUnmatchedHTMLInline = function(node4, entering) {
      var _a;
      if (!entering && node4.type !== "htmlInline") {
        var length_1 = this.stack.length - 1;
        for (var i = length_1; i >= 0; i -= 1) {
          var nodeInfo = this.stack[i];
          if ((_a = nodeInfo.attrs) === null || _a === void 0 ? void 0 : _a.rawHTML) {
            if (nodeInfo.content.length) {
              this.closeNode();
            } else {
              this.stack.pop();
            }
          } else {
            break;
          }
        }
      }
    };
    ToWwConvertorState2.prototype.convert = function(mdNode, infoForPosSync) {
      var walker = mdNode.walker();
      var event = walker.next();
      var _loop_1 = function() {
        var node4 = event.node, entering = event.entering;
        var convertor = this_1.convertors[node4.type];
        var skipped = false;
        if (convertor) {
          var context = {
            entering,
            leaf: !isContainer$2(node4),
            getChildrenText: getChildrenText$1,
            options: { gfm: true, nodeId: false, tagFilter: false, softbreak: "\n" },
            skipChildren: function() {
              skipped = true;
            }
          };
          this_1.closeUnmatchedHTMLInline(node4, entering);
          convertor(this_1, node4, context);
          if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node4) {
            var pos = this_1.stack.reduce(function(nodeSize2, stackItem) {
              return nodeSize2 + stackItem.content.reduce(function(contentSize, pmNode) {
                return contentSize + pmNode.nodeSize;
              }, 0);
            }, 0) + 1;
            infoForPosSync.setMappedPos(pos);
          }
        }
        if (skipped) {
          walker.resumeAt(node4, false);
          walker.next();
        }
        event = walker.next();
      };
      var this_1 = this;
      while (event) {
        _loop_1();
      }
    };
    ToWwConvertorState2.prototype.convertNode = function(mdNode, infoForPosSync) {
      this.convert(mdNode, infoForPosSync);
      if (this.stack.length) {
        return this.closeNode();
      }
      return null;
    };
    return ToWwConvertorState2;
  })()
);
function convertToRawHTMLHavingInlines(state, node4, _a) {
  var openTag = _a[0], closeTag = _a[1];
  state.write(openTag);
  state.convertInline(node4);
  state.write(closeTag);
}
function convertToRawHTMLHavingBlocks(state, _a, _b) {
  var node4 = _a.node, parent = _a.parent;
  var openTag = _b[0], closeTag = _b[1];
  state.stopNewline = true;
  state.write(openTag);
  state.convertNode(node4);
  state.write(closeTag);
  if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === "doc") {
    state.closeBlock(node4);
    state.stopNewline = false;
  }
}
function createTableHeadDelim(textContent, columnAlign) {
  var textLen = textContent.length;
  var leftDelim = "";
  var rightDelim = "";
  if (columnAlign === "left") {
    leftDelim = ":";
    textLen -= 1;
  } else if (columnAlign === "right") {
    rightDelim = ":";
    textLen -= 1;
  } else if (columnAlign === "center") {
    leftDelim = ":";
    rightDelim = ":";
    textLen -= 2;
  }
  return "" + leftDelim + repeat$1("-", Math.max(textLen, 3)) + rightDelim;
}
var nodeTypeWriters = {
  text: function(state, _a) {
    var _b;
    var node4 = _a.node;
    var text3 = (_b = node4.text) !== null && _b !== void 0 ? _b : "";
    if ((node4.marks || []).some(function(mark3) {
      return mark3.type.name === "link";
    })) {
      state.text(escapeTextForLink(text3), false);
    } else {
      state.text(text3);
    }
  },
  paragraph: function(state, _a) {
    var node4 = _a.node, parent = _a.parent, _b = _a.index, index3 = _b === void 0 ? 0 : _b;
    if (state.stopNewline) {
      state.convertInline(node4);
    } else {
      var firstChildNode = index3 === 0;
      var prevNode = !firstChildNode && parent.child(index3 - 1);
      var prevEmptyNode = prevNode && prevNode.childCount === 0;
      var nextNode = index3 < parent.childCount - 1 && parent.child(index3 + 1);
      var nextParaNode = nextNode && nextNode.type.name === "paragraph";
      var emptyNode = node4.childCount === 0;
      if (emptyNode && prevEmptyNode) {
        state.write("<br>\n");
      } else if (emptyNode && !prevEmptyNode && !firstChildNode) {
        if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === "listItem") {
          var prevDelim = state.getDelim();
          state.setDelim("");
          state.write("<br>");
          state.setDelim(prevDelim);
        }
        state.write("\n");
      } else {
        state.convertInline(node4);
        if (nextParaNode) {
          state.write("\n");
        } else {
          state.closeBlock(node4);
        }
      }
    }
  },
  heading: function(state, _a, _b) {
    var node4 = _a.node;
    var delim = _b.delim;
    var headingType = node4.attrs.headingType;
    if (headingType === "atx") {
      state.write(delim + " ");
      state.convertInline(node4);
      state.closeBlock(node4);
    } else {
      state.convertInline(node4);
      state.ensureNewLine();
      state.write(delim);
      state.closeBlock(node4);
    }
  },
  codeBlock: function(state, _a, _b) {
    var node4 = _a.node;
    var delim = _b.delim, text3 = _b.text;
    var _c = delim, openDelim = _c[0], closeDelim = _c[1];
    state.write(openDelim);
    state.ensureNewLine();
    state.text(text3, false);
    state.ensureNewLine();
    state.write(closeDelim);
    state.closeBlock(node4);
  },
  blockQuote: function(state, _a, _b) {
    var node4 = _a.node, parent = _a.parent;
    var delim = _b.delim;
    if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === node4.type.name) {
      state.flushClose(1);
    }
    state.wrapBlock(delim, null, node4, function() {
      return state.convertNode(node4);
    });
  },
  bulletList: function(state, _a, _b) {
    var node4 = _a.node;
    var delim = _b.delim;
    state.convertList(node4, repeat$1(" ", 4), function() {
      return delim + " ";
    });
  },
  orderedList: function(state, _a) {
    var node4 = _a.node;
    var start3 = node4.attrs.order || 1;
    state.convertList(node4, repeat$1(" ", 4), function(index3) {
      var orderedNum = String(start3 + index3);
      return orderedNum + ". ";
    });
  },
  listItem: function(state, _a) {
    var node4 = _a.node;
    var _b = node4.attrs, task2 = _b.task, checked = _b.checked;
    if (task2) {
      state.write("[" + (checked ? "x" : " ") + "] ");
    }
    state.convertNode(node4);
  },
  image: function(state, _, _a) {
    var attrs = _a.attrs;
    state.write("![" + (attrs === null || attrs === void 0 ? void 0 : attrs.altText) + "](" + (attrs === null || attrs === void 0 ? void 0 : attrs.imageUrl) + ")");
  },
  thematicBreak: function(state, _a, _b) {
    var node4 = _a.node;
    var delim = _b.delim;
    state.write(delim);
    state.closeBlock(node4);
  },
  table: function(state, _a) {
    var node4 = _a.node;
    state.convertNode(node4);
    state.closeBlock(node4);
  },
  tableHead: function(state, _a, _b) {
    var node4 = _a.node;
    var delim = _b.delim;
    var row = node4.firstChild;
    state.convertNode(node4);
    var result2 = delim !== null && delim !== void 0 ? delim : "";
    if (!delim && row) {
      row.forEach(function(_a2) {
        var textContent = _a2.textContent, attrs = _a2.attrs;
        var headDelim = createTableHeadDelim(textContent, attrs.align);
        result2 += "| " + headDelim + " ";
      });
    }
    state.write(result2 + "|");
    state.ensureNewLine();
  },
  tableBody: function(state, _a) {
    var node4 = _a.node;
    state.convertNode(node4);
  },
  tableRow: function(state, _a) {
    var node4 = _a.node;
    state.convertNode(node4);
    state.write("|");
    state.ensureNewLine();
  },
  tableHeadCell: function(state, _a, _b) {
    var node4 = _a.node;
    var _c = _b.delim, delim = _c === void 0 ? "| " : _c;
    state.write(delim);
    state.convertTableCell(node4);
    state.write(" ");
  },
  tableBodyCell: function(state, _a, _b) {
    var node4 = _a.node;
    var _c = _b.delim, delim = _c === void 0 ? "| " : _c;
    state.write(delim);
    state.convertTableCell(node4);
    state.write(" ");
  },
  customBlock: function(state, _a, _b) {
    var node4 = _a.node;
    var delim = _b.delim, text3 = _b.text;
    var _c = delim, openDelim = _c[0], closeDelim = _c[1];
    state.write(openDelim);
    state.ensureNewLine();
    state.text(text3, false);
    state.ensureNewLine();
    state.write(closeDelim);
    state.closeBlock(node4);
  },
  frontMatter: function(state, _a, _b) {
    var node4 = _a.node;
    var text3 = _b.text;
    state.text(text3, false);
    state.closeBlock(node4);
  },
  widget: function(state, _, _a) {
    var text3 = _a.text;
    state.write(text3);
  },
  html: function(state, _a, _b) {
    var node4 = _a.node;
    var text3 = _b.text;
    state.write(text3);
    if (node4.attrs.htmlBlock) {
      state.closeBlock(node4);
    }
  },
  htmlComment: function(state, _a, _b) {
    var node4 = _a.node;
    var text3 = _b.text;
    state.write(text3);
    state.closeBlock(node4);
  }
};
function write(type, _a) {
  var state = _a.state, nodeInfo = _a.nodeInfo, params = _a.params;
  var rawHTML = params.rawHTML;
  if (rawHTML) {
    if (inArray_1(type, ["heading", "codeBlock"]) > -1) {
      convertToRawHTMLHavingInlines(state, nodeInfo.node, rawHTML);
    } else if (inArray_1(type, ["image", "thematicBreak"]) > -1) {
      state.write(rawHTML);
    } else {
      convertToRawHTMLHavingBlocks(state, nodeInfo, rawHTML);
    }
  } else {
    nodeTypeWriters[type](state, nodeInfo, params);
  }
}
function addBackticks(node4, side) {
  var text3 = node4.text;
  var ticks = /`+/g;
  var len = 0;
  if (node4.isText && text3) {
    var matched = ticks.exec(text3);
    while (matched) {
      len = Math.max(len, matched[0].length);
      matched = ticks.exec(text3);
    }
  }
  var result2 = len > 0 && side > 0 ? " `" : "`";
  for (var i = 0; i < len; i += 1) {
    result2 += "`";
  }
  if (len > 0 && side < 0) {
    result2 += " ";
  }
  return result2;
}
function getPairRawHTML(rawHTML) {
  return rawHTML ? ["<" + rawHTML + ">", "</" + rawHTML + ">"] : null;
}
function getOpenRawHTML(rawHTML) {
  return rawHTML ? "<" + rawHTML + ">" : null;
}
function getCloseRawHTML(rawHTML) {
  return rawHTML ? "</" + rawHTML + ">" : null;
}
var toMdConvertors = {
  heading: function(_a) {
    var node4 = _a.node;
    var attrs = node4.attrs;
    var level = attrs.level;
    var delim = repeat$1("#", level);
    if (attrs.headingType === "setext") {
      delim = level === 1 ? "===" : "---";
    }
    return {
      delim,
      rawHTML: getPairRawHTML(attrs.rawHTML)
    };
  },
  codeBlock: function(_a) {
    var node4 = _a.node;
    var _b = node4, attrs = _b.attrs, textContent = _b.textContent;
    return {
      delim: ["```" + (attrs.language || ""), "```"],
      rawHTML: getPairRawHTML(attrs.rawHTML),
      text: textContent
    };
  },
  blockQuote: function(_a) {
    var node4 = _a.node;
    return {
      delim: "> ",
      rawHTML: getPairRawHTML(node4.attrs.rawHTML)
    };
  },
  bulletList: function(_a, _b) {
    var node4 = _a.node;
    var inTable = _b.inTable;
    var rawHTML = node4.attrs.rawHTML;
    if (inTable) {
      rawHTML = rawHTML || "ul";
    }
    return {
      delim: "*",
      rawHTML: getPairRawHTML(rawHTML)
    };
  },
  orderedList: function(_a, _b) {
    var node4 = _a.node;
    var inTable = _b.inTable;
    var rawHTML = node4.attrs.rawHTML;
    if (inTable) {
      rawHTML = rawHTML || "ol";
    }
    return {
      rawHTML: getPairRawHTML(rawHTML)
    };
  },
  listItem: function(_a, _b) {
    var node4 = _a.node;
    var inTable = _b.inTable;
    var _c = node4.attrs, task2 = _c.task, checked = _c.checked;
    var rawHTML = node4.attrs.rawHTML;
    if (inTable) {
      rawHTML = rawHTML || "li";
    }
    var className = task2 ? ' class="task-list-item' + (checked ? " checked" : "") + '"' : "";
    var dataset = task2 ? " data-task" + (checked ? " data-task-checked" : "") : "";
    return {
      rawHTML: rawHTML ? ["<" + rawHTML + className + dataset + ">", "</" + rawHTML + ">"] : null
    };
  },
  table: function(_a) {
    var node4 = _a.node;
    return {
      rawHTML: getPairRawHTML(node4.attrs.rawHTML)
    };
  },
  tableHead: function(_a) {
    var node4 = _a.node;
    return {
      rawHTML: getPairRawHTML(node4.attrs.rawHTML)
    };
  },
  tableBody: function(_a) {
    var node4 = _a.node;
    return {
      rawHTML: getPairRawHTML(node4.attrs.rawHTML)
    };
  },
  tableRow: function(_a) {
    var node4 = _a.node;
    return {
      rawHTML: getPairRawHTML(node4.attrs.rawHTML)
    };
  },
  tableHeadCell: function(_a) {
    var node4 = _a.node;
    return {
      rawHTML: getPairRawHTML(node4.attrs.rawHTML)
    };
  },
  tableBodyCell: function(_a) {
    var node4 = _a.node;
    return {
      rawHTML: getPairRawHTML(node4.attrs.rawHTML)
    };
  },
  image: function(_a) {
    var node4 = _a.node;
    var attrs = node4.attrs;
    var rawHTML = attrs.rawHTML, altText = attrs.altText;
    var imageUrl = attrs.imageUrl.replace(/&amp;/g, "&");
    var altAttr = altText ? ' alt="' + escapeXml$1(altText) + '"' : "";
    return {
      rawHTML: rawHTML ? "<" + rawHTML + ' src="' + escapeXml$1(imageUrl) + '"' + altAttr + ">" : null,
      attrs: {
        altText: escapeTextForLink(altText || ""),
        imageUrl
      }
    };
  },
  thematicBreak: function(_a) {
    var node4 = _a.node;
    return {
      delim: "***",
      rawHTML: getOpenRawHTML(node4.attrs.rawHTML)
    };
  },
  customBlock: function(_a) {
    var node4 = _a.node;
    var _b = node4, attrs = _b.attrs, textContent = _b.textContent;
    return {
      delim: ["$$" + attrs.info, "$$"],
      text: textContent
    };
  },
  frontMatter: function(_a) {
    var node4 = _a.node;
    return {
      text: node4.textContent
    };
  },
  widget: function(_a) {
    var node4 = _a.node;
    return {
      text: node4.textContent
    };
  },
  strong: function(_a, _b, betweenSpace) {
    var node4 = _a.node;
    var entering = _b.entering;
    var rawHTML = node4.attrs.rawHTML;
    var delim = "**";
    if (!betweenSpace) {
      delim = entering ? "<strong>" : "</strong>";
    }
    return {
      delim,
      rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML)
    };
  },
  emph: function(_a, _b, betweenSpace) {
    var node4 = _a.node;
    var entering = _b.entering;
    var rawHTML = node4.attrs.rawHTML;
    var delim = "*";
    if (!betweenSpace) {
      delim = entering ? "<em>" : "</em>";
    }
    return {
      delim,
      rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML)
    };
  },
  strike: function(_a, _b, betweenSpace) {
    var node4 = _a.node;
    var entering = _b.entering;
    var rawHTML = node4.attrs.rawHTML;
    var delim = "~~";
    if (!betweenSpace) {
      delim = entering ? "<del>" : "</del>";
    }
    return {
      delim,
      rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML)
    };
  },
  link: function(_a, _b) {
    var node4 = _a.node;
    var entering = _b.entering;
    var attrs = node4.attrs;
    var title = attrs.title, rawHTML = attrs.rawHTML;
    var linkUrl = attrs.linkUrl.replace(/&amp;/g, "&");
    var titleAttr = title ? ' title="' + escapeXml$1(title) + '"' : "";
    if (entering) {
      return {
        delim: "[",
        rawHTML: rawHTML ? "<" + rawHTML + ' href="' + escapeXml$1(linkUrl) + '"' + titleAttr + ">" : null
      };
    }
    return {
      delim: "](" + linkUrl + (title ? " " + quote(escapeTextForLink(title)) : "") + ")",
      rawHTML: getCloseRawHTML(rawHTML)
    };
  },
  code: function(_a, _b) {
    var node4 = _a.node, parent = _a.parent, _c = _a.index, index3 = _c === void 0 ? 0 : _c;
    var entering = _b.entering;
    var delim = entering ? addBackticks(parent.child(index3), -1) : addBackticks(parent.child(index3 - 1), 1);
    var rawHTML = entering ? getOpenRawHTML(node4.attrs.rawHTML) : getCloseRawHTML(node4.attrs.rawHTML);
    return {
      delim,
      rawHTML
    };
  },
  htmlComment: function(_a) {
    var node4 = _a.node;
    return {
      text: node4.textContent
    };
  },
  // html inline node, html block node
  html: function(_a, _b) {
    var node4 = _a.node;
    var entering = _b.entering;
    var tagName = node4.type.name;
    var attrs = node4.attrs.htmlAttrs;
    var openTag = "<" + tagName;
    var closeTag = "</" + tagName + ">";
    Object.keys(attrs).forEach(function(attrName) {
      openTag += " " + attrName + '="' + attrs[attrName].replace(/"/g, "'") + '"';
    });
    openTag += ">";
    if (node4.attrs.htmlInline) {
      return {
        rawHTML: entering ? openTag : closeTag
      };
    }
    return {
      text: "" + openTag + node4.attrs.childrenHTML + closeTag
    };
  }
};
var markTypeOptions = {
  strong: {
    mixable: true,
    removedEnclosingWhitespace: true
  },
  emph: {
    mixable: true,
    removedEnclosingWhitespace: true
  },
  strike: {
    mixable: true,
    removedEnclosingWhitespace: true
  },
  code: {
    escape: false
  },
  link: null,
  html: null
};
function createNodeTypeConvertors(convertors2) {
  var nodeTypeConvertors = {};
  var nodeTypes = Object.keys(nodeTypeWriters);
  nodeTypes.forEach(function(type) {
    nodeTypeConvertors[type] = function(state, nodeInfo) {
      var writer = nodeTypeWriters[type];
      if (writer) {
        var convertor = convertors2[type];
        var params = convertor ? convertor(nodeInfo, {
          inTable: state.inTable
        }) : {};
        write(type, { state, nodeInfo, params });
      }
    };
  });
  return nodeTypeConvertors;
}
function createMarkTypeConvertors(convertors2) {
  var markTypeConvertors = {};
  var markTypes = Object.keys(markTypeOptions);
  markTypes.forEach(function(type) {
    markTypeConvertors[type] = function(nodeInfo, entering, betweenSpace) {
      var markOption = markTypeOptions[type];
      var convertor = convertors2[type];
      var runConvertor = convertor && nodeInfo && !isUndefined_1(entering);
      var params = runConvertor ? convertor(nodeInfo, { entering }, betweenSpace) : {};
      return __assign$1(__assign$1({}, params), markOption);
    };
  });
  return markTypeConvertors;
}
function createMdConvertors(customConvertors) {
  var customConvertorTypes = Object.keys(customConvertors);
  customConvertorTypes.forEach(function(type) {
    var baseConvertor = toMdConvertors[type];
    var customConvertor = customConvertors[type];
    if (baseConvertor) {
      toMdConvertors[type] = function(nodeInfo, context) {
        context.origin = function() {
          return baseConvertor(nodeInfo, context);
        };
        return customConvertor(nodeInfo, context);
      };
    } else {
      toMdConvertors[type] = customConvertor;
    }
    delete customConvertors[type];
  });
  var nodeTypeConvertors = createNodeTypeConvertors(toMdConvertors);
  var markTypeConvertors = createMarkTypeConvertors(toMdConvertors);
  return {
    nodeTypeConvertors,
    markTypeConvertors
  };
}
var ToMdConvertorState = (
  /** @class */
  (function() {
    function ToMdConvertorState2(_a) {
      var nodeTypeConvertors = _a.nodeTypeConvertors, markTypeConvertors = _a.markTypeConvertors;
      this.nodeTypeConvertors = nodeTypeConvertors;
      this.markTypeConvertors = markTypeConvertors;
      this.delim = "";
      this.result = "";
      this.closed = false;
      this.tightList = false;
      this.stopNewline = false;
      this.inTable = false;
    }
    ToMdConvertorState2.prototype.getMarkConvertor = function(mark3) {
      var type = mark3.attrs.htmlInline ? "html" : mark3.type.name;
      return this.markTypeConvertors[type];
    };
    ToMdConvertorState2.prototype.isInBlank = function() {
      return /(^|\n)$/.test(this.result);
    };
    ToMdConvertorState2.prototype.isBetweenSpaces = function(parent, index3) {
      var _a, _b;
      var content2 = parent.content;
      var isFrontNodeEndWithSpace = index3 === 0 || isEndWithSpace((_a = content2.child(index3 - 1).text) !== null && _a !== void 0 ? _a : DEFAULT_TEXT_NOT_START_OR_END_WITH_SPACE);
      var isRearNodeStartWithSpace = index3 >= content2.childCount - 1 || isStartWithSpace((_b = content2.child(index3 + 1).text) !== null && _b !== void 0 ? _b : DEFAULT_TEXT_NOT_START_OR_END_WITH_SPACE);
      return isFrontNodeEndWithSpace && isRearNodeStartWithSpace;
    };
    ToMdConvertorState2.prototype.markText = function(mark3, entering, parent, index3) {
      var convertor = this.getMarkConvertor(mark3);
      if (convertor) {
        var betweenSpace = this.isBetweenSpaces(parent, entering ? index3 : index3 - 1);
        var _a = convertor({ node: mark3, parent, index: index3 }, entering, betweenSpace), delim = _a.delim, rawHTML = _a.rawHTML;
        return rawHTML || delim;
      }
      return "";
    };
    ToMdConvertorState2.prototype.setDelim = function(delim) {
      this.delim = delim;
    };
    ToMdConvertorState2.prototype.getDelim = function() {
      return this.delim;
    };
    ToMdConvertorState2.prototype.flushClose = function(size) {
      if (!this.stopNewline && this.closed) {
        if (!this.isInBlank()) {
          this.result += "\n";
        }
        if (!size) {
          size = 2;
        }
        if (size > 1) {
          var delimMin = this.delim;
          var trim = /\s+$/.exec(delimMin);
          if (trim) {
            delimMin = delimMin.slice(0, delimMin.length - trim[0].length);
          }
          for (var i = 1; i < size; i += 1) {
            this.result += delimMin + "\n";
          }
        }
        this.closed = false;
      }
    };
    ToMdConvertorState2.prototype.wrapBlock = function(delim, firstDelim, node4, fn) {
      var old = this.getDelim();
      this.write(firstDelim || delim);
      this.setDelim(this.getDelim() + delim);
      fn();
      this.setDelim(old);
      this.closeBlock(node4);
    };
    ToMdConvertorState2.prototype.ensureNewLine = function() {
      if (!this.isInBlank()) {
        this.result += "\n";
      }
    };
    ToMdConvertorState2.prototype.write = function(content2) {
      if (content2 === void 0) {
        content2 = "";
      }
      this.flushClose();
      if (this.delim && this.isInBlank()) {
        this.result += this.delim;
      }
      if (content2) {
        this.result += content2;
      }
    };
    ToMdConvertorState2.prototype.closeBlock = function(node4) {
      this.closed = node4;
    };
    ToMdConvertorState2.prototype.text = function(text3, escaped) {
      if (escaped === void 0) {
        escaped = true;
      }
      var lines = text3.split("\n");
      for (var i = 0; i < lines.length; i += 1) {
        this.write();
        this.result += escaped ? escape$1(lines[i]) : lines[i];
        if (i !== lines.length - 1) {
          this.result += "\n";
        }
      }
    };
    ToMdConvertorState2.prototype.convertBlock = function(node4, parent, index3) {
      var type = node4.type.name;
      var convertor = this.nodeTypeConvertors[type];
      var nodeInfo = { node: node4, parent, index: index3 };
      if (node4.attrs.htmlBlock) {
        this.nodeTypeConvertors.html(this, nodeInfo);
      } else if (convertor) {
        convertor(this, nodeInfo);
      }
    };
    ToMdConvertorState2.prototype.convertInline = function(parent) {
      var _this = this;
      var active = [];
      var trailing = "";
      var progress = function(node4, _, index3) {
        var marks2 = node4 ? node4.marks : [];
        var leading = trailing;
        trailing = "";
        var removedWhitespace = node4 && node4.isText && marks2.some(function(mark4) {
          var markConvertor2 = _this.getMarkConvertor(mark4);
          var info = markConvertor2 && markConvertor2();
          return info && info.removedEnclosingWhitespace;
        });
        if (removedWhitespace && node4 && node4.text) {
          var _a = /^(\s*)(.*?)(\s*)$/m.exec(node4.text), lead = _a[1], mark3 = _a[2], trail = _a[3];
          leading += lead;
          trailing = trail;
          if (lead || trail) {
            node4 = mark3 ? node4.withText(mark3) : null;
            if (!node4) {
              marks2 = active;
            }
          }
        }
        var lastMark = marks2.length && last$1(marks2);
        var markConvertor = lastMark && _this.getMarkConvertor(lastMark);
        var markType = markConvertor && markConvertor();
        var noEscape = markType && markType.escape === false;
        var len = marks2.length - (noEscape ? 1 : 0);
        for (var i = 0; i < len; i += 1) {
          var mark3 = marks2[i];
          if (markType && !markType.mixable) {
            break;
          }
          for (var j = 0; j < active.length; j += 1) {
            var other = active[j];
            if (markType && !markType.mixable) {
              break;
            }
            if (mark3.eq(other)) {
              if (i > j) {
                marks2 = marks2.slice(0, j).concat(mark3).concat(marks2.slice(j, i)).concat(marks2.slice(i + 1, len));
              } else if (j > i) {
                marks2 = marks2.slice(0, i).concat(marks2.slice(i + 1, j)).concat(mark3).concat(marks2.slice(j, len));
              }
              break;
            }
          }
        }
        var keep = 0;
        while (keep < Math.min(active.length, len) && marks2[keep].eq(active[keep])) {
          keep += 1;
        }
        while (keep < active.length) {
          var activedMark = active.pop();
          if (activedMark) {
            _this.text(_this.markText(activedMark, false, parent, index3), false);
          }
        }
        if (leading) {
          _this.text(leading);
        }
        if (node4) {
          while (active.length < len) {
            var mark3 = marks2[active.length];
            active.push(mark3);
            _this.text(_this.markText(mark3, true, parent, index3), false);
          }
          if (noEscape && node4.isText) {
            _this.text(_this.markText(lastMark, true, parent, index3) + node4.text + _this.markText(lastMark, false, parent, index3 + 1), false);
          } else {
            _this.convertBlock(node4, parent, index3);
          }
        }
      };
      parent.forEach(progress);
      progress(null, null, parent.childCount);
    };
    ToMdConvertorState2.prototype.convertList = function(node4, delim, firstDelimFn) {
      var _this = this;
      var _a;
      if (this.closed && this.closed.type === node4.type) {
        this.flushClose(3);
      } else if (this.tightList) {
        this.flushClose(1);
      }
      var tight = (_a = node4.attrs.tight) !== null && _a !== void 0 ? _a : true;
      var prevTight = this.tightList;
      this.tightList = tight;
      node4.forEach(function(child3, _, index3) {
        if (index3 && tight) {
          _this.flushClose(1);
        }
        _this.wrapBlock(delim, firstDelimFn(index3), node4, function() {
          return _this.convertBlock(child3, node4, index3);
        });
      });
      this.tightList = prevTight;
    };
    ToMdConvertorState2.prototype.convertTableCell = function(node4) {
      var _this = this;
      this.stopNewline = true;
      this.inTable = true;
      node4.forEach(function(child3, _, index3) {
        if (includes2(["bulletList", "orderedList"], child3.type.name)) {
          _this.convertBlock(child3, node4, index3);
          _this.closed = false;
        } else {
          _this.convertInline(child3);
          if (index3 < node4.childCount - 1) {
            var nextChild = node4.child(index3 + 1);
            if (nextChild.type.name === "paragraph") {
              _this.write("<br>");
            }
          }
        }
      });
      this.stopNewline = false;
      this.inTable = false;
    };
    ToMdConvertorState2.prototype.convertNode = function(parent, infoForPosSync) {
      var _this = this;
      parent.forEach(function(node4, _, index3) {
        _this.convertBlock(node4, parent, index3);
        if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node4) {
          var lineTexts = _this.result.split("\n");
          infoForPosSync.setMappedPos([lineTexts.length, last$1(lineTexts).length + 1]);
        }
      });
      return this.result;
    };
    return ToMdConvertorState2;
  })()
);
var Convertor = (
  /** @class */
  (function() {
    function Convertor2(schema, toMdConvertors2, toHTMLConvertors, eventEmitter) {
      var _this = this;
      this.setMappedPos = function(pos) {
        _this.mappedPosWhenConverting = pos;
      };
      this.schema = schema;
      this.eventEmitter = eventEmitter;
      this.focusedNode = null;
      this.mappedPosWhenConverting = null;
      this.toWwConvertors = createWwConvertors(toHTMLConvertors);
      this.toMdConvertors = createMdConvertors(toMdConvertors2 || {});
      this.eventEmitter.listen("setFocusedNode", function(node4) {
        return _this.focusedNode = node4;
      });
    }
    Convertor2.prototype.getMappedPos = function() {
      return this.mappedPosWhenConverting;
    };
    Convertor2.prototype.getInfoForPosSync = function() {
      return { node: this.focusedNode, setMappedPos: this.setMappedPos };
    };
    Convertor2.prototype.toWysiwygModel = function(mdNode) {
      var state = new ToWwConvertorState(this.schema, this.toWwConvertors);
      return state.convertNode(mdNode, this.getInfoForPosSync());
    };
    Convertor2.prototype.toMarkdownText = function(wwNode) {
      var state = new ToMdConvertorState(this.toMdConvertors);
      var markdownText = state.convertNode(wwNode, this.getInfoForPosSync());
      markdownText = this.eventEmitter.emitReduce("beforeConvertWysiwygToMarkdown", markdownText);
      return markdownText;
    };
    return Convertor2;
  })()
);
function execPlugin(plugin, eventEmitter, usageStatistics) {
  var pmState = { Plugin, PluginKey, Selection, TextSelection };
  var pmView = { Decoration, DecorationSet };
  var pmModel = { Fragment };
  var pmRules = { InputRule, inputRules, undoInputRule };
  var context = { eventEmitter, usageStatistics, pmState, pmView, pmModel, pmRules, i18n };
  if (isArray_1(plugin)) {
    var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;
    return pluginFn(context, options);
  }
  return plugin(context);
}
function getPluginInfo(plugins, eventEmitter, usageStatistics) {
  eventEmitter.listen("mixinTableOffsetMapPrototype", mixinTableOffsetMapPrototype);
  return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function(acc, plugin) {
    var pluginInfoResult = execPlugin(plugin, eventEmitter, usageStatistics);
    if (!pluginInfoResult) {
      throw new Error("The return value of the executed plugin is empty.");
    }
    var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;
    if (toHTMLRenderers) {
      acc.toHTMLRenderers = deepMergedCopy(acc.toHTMLRenderers, toHTMLRenderers);
    }
    if (toMarkdownRenderers) {
      acc.toMarkdownRenderers = deepMergedCopy(acc.toMarkdownRenderers, toMarkdownRenderers);
    }
    if (markdownPlugins) {
      acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);
    }
    if (wysiwygPlugins) {
      acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);
    }
    if (wysiwygNodeViews) {
      acc.wwNodeViews = __assign$1(__assign$1({}, acc.wwNodeViews), wysiwygNodeViews);
    }
    if (markdownCommands) {
      acc.mdCommands = __assign$1(__assign$1({}, acc.mdCommands), markdownCommands);
    }
    if (wysiwygCommands) {
      acc.wwCommands = __assign$1(__assign$1({}, acc.wwCommands), wysiwygCommands);
    }
    if (toolbarItems) {
      acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);
    }
    if (markdownParsers) {
      acc.markdownParsers = __assign$1(__assign$1({}, acc.markdownParsers), markdownParsers);
    }
    return acc;
  }, {
    toHTMLRenderers: {},
    toMarkdownRenderers: {},
    mdPlugins: [],
    wwPlugins: [],
    wwNodeViews: {},
    mdCommands: {},
    wwCommands: {},
    toolbarItems: [],
    markdownParsers: {}
  });
}
var TASK_ATTR_NAME = "data-task";
var DISABLED_TASK_ATTR_NAME = "data-task-disabled";
var TASK_CHECKED_CLASS_NAME = "checked";
function registerHTMLTagToWhitelist(convertorMap) {
  ["htmlBlock", "htmlInline"].forEach(function(htmlType) {
    if (convertorMap[htmlType]) {
      Object.keys(convertorMap[htmlType]).forEach(function(type) {
        return registerTagWhitelistIfPossible2(type);
      });
    }
  });
}
var ToastUIEditorViewer = (
  /** @class */
  (function() {
    function ToastUIEditorViewer2(options) {
      var _this = this;
      this.options = extend_1({
        linkAttributes: null,
        extendedAutolinks: false,
        customHTMLRenderer: null,
        referenceDefinition: false,
        customHTMLSanitizer: null,
        frontMatter: false,
        usageStatistics: true,
        theme: "light"
      }, options);
      this.eventEmitter = new EventEmitter();
      var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);
      var _a = getPluginInfo(this.options.plugins, this.eventEmitter, this.options.usageStatistics) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;
      var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter2 = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;
      var rendererOptions = {
        linkAttributes,
        customHTMLRenderer: __assign$1(__assign$1({}, toHTMLRenderers), customHTMLRenderer),
        extendedAutolinks,
        referenceDefinition,
        frontMatter: frontMatter2,
        sanitizer: customHTMLSanitizer || sanitizeHTML
      };
      registerHTMLTagToWhitelist(rendererOptions.customHTMLRenderer);
      if (this.options.events) {
        forEachOwnProperties_1(this.options.events, function(fn, key) {
          _this.on(key, fn);
        });
      }
      var _c = this.options, el2 = _c.el, initialValue = _c.initialValue, theme = _c.theme;
      var existingHTML = el2.innerHTML;
      if (theme !== "light") {
        el2.classList.add(cls(theme));
      }
      el2.innerHTML = "";
      this.toastMark = new ToastMark("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks,
        referenceDefinition,
        disallowDeepHeading: true,
        frontMatter: frontMatter2,
        customParser: markdownParsers
      });
      this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: true }));
      on_1(this.preview.previewContent, "mousedown", this.toggleTask.bind(this));
      if (initialValue) {
        this.setMarkdown(initialValue);
      } else if (existingHTML) {
        this.preview.setHTML(existingHTML);
      }
      el2.appendChild(this.preview.previewContent);
      this.eventEmitter.emit("load", this);
    }
    ToastUIEditorViewer2.prototype.toggleTask = function(ev) {
      var element = ev.target;
      var style = getComputedStyle(element, ":before");
      if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME) && element.hasAttribute(TASK_ATTR_NAME) && isPositionInBox(style, ev.offsetX, ev.offsetY)) {
        toggleClass(element, TASK_CHECKED_CLASS_NAME);
        this.eventEmitter.emit("change", {
          source: "viewer",
          date: ev
        });
      }
    };
    ToastUIEditorViewer2.prototype.setMarkdown = function(markdown) {
      var lineTexts = this.toastMark.getLineTexts();
      var length = lineTexts.length;
      var lastLine = last$1(lineTexts);
      var endSourcepos = [length, lastLine.length + 1];
      var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || "");
      this.eventEmitter.emit("updatePreview", editResult);
    };
    ToastUIEditorViewer2.prototype.on = function(type, handler) {
      this.eventEmitter.listen(type, handler);
    };
    ToastUIEditorViewer2.prototype.off = function(type) {
      this.eventEmitter.removeEventHandler(type);
    };
    ToastUIEditorViewer2.prototype.addHook = function(type, handler) {
      this.eventEmitter.removeEventHandler(type);
      this.eventEmitter.listen(type, handler);
    };
    ToastUIEditorViewer2.prototype.destroy = function() {
      off_1(this.preview.el, "mousedown", this.toggleTask.bind(this));
      this.preview.destroy();
      this.eventEmitter.emit("destroy");
    };
    ToastUIEditorViewer2.prototype.isViewer = function() {
      return true;
    };
    ToastUIEditorViewer2.prototype.isMarkdownMode = function() {
      return false;
    };
    ToastUIEditorViewer2.prototype.isWysiwygMode = function() {
      return false;
    };
    return ToastUIEditorViewer2;
  })()
);
function isPmNode(node4) {
  return node4 instanceof Node2;
}
function isContainer(type) {
  var containerTypes = [
    "document",
    "blockQuote",
    "bulletList",
    "orderedList",
    "listItem",
    "paragraph",
    "heading",
    "emph",
    "strong",
    "strike",
    "link",
    "image",
    "table",
    "tableHead",
    "tableBody",
    "tableRow",
    "tableHeadCell",
    "tableBodyCell"
  ];
  return includes2(containerTypes, type);
}
function createMdLikeNode(node4) {
  var attrs = node4.attrs, type = node4.type;
  var nodeType2 = type.name;
  var mdLikeNode = {
    type: nodeType2,
    wysiwygNode: true,
    literal: !isContainer(nodeType2) && isPmNode(node4) ? node4.textContent : null
  };
  var nodeTypeMap = {
    heading: { level: attrs.level },
    link: { destination: attrs.linkUrl, title: attrs.title },
    image: { destination: attrs.imageUrl },
    codeBlock: { info: attrs.language },
    bulletList: { type: "list", listData: { type: "bullet" } },
    orderedList: { type: "list", listData: { type: "ordered", start: attrs.order } },
    listItem: { type: "item", listData: { task: attrs.task, checked: attrs.checked } },
    tableHeadCell: { type: "tableCell", cellType: "head", align: attrs.align },
    tableBodyCell: { type: "tableCell", cellType: "body", align: attrs.align },
    customBlock: { info: attrs.info }
  };
  var nodeInfo = nodeTypeMap[nodeType2];
  var attributes = __assign$1(__assign$1({}, mdLikeNode), nodeInfo);
  var _a = node4.attrs, htmlAttrs = _a.htmlAttrs, childrenHTML = _a.childrenHTML;
  if (htmlAttrs) {
    return __assign$1(__assign$1({}, attributes), { attrs: htmlAttrs, childrenHTML });
  }
  return attributes;
}
var tokenToDOMNode = {
  openTag: function(token, stack) {
    var _a = token, tagName = _a.tagName, classNames = _a.classNames, attributes = _a.attributes;
    var el2 = document.createElement(tagName);
    var attrs = {};
    if (classNames) {
      el2.className = classNames.join(" ");
    }
    if (attributes) {
      attrs = __assign$1(__assign$1({}, attrs), attributes);
    }
    setAttributes(attrs, el2);
    stack.push(el2);
  },
  closeTag: function(_, stack) {
    if (stack.length > 1) {
      var el2 = stack.pop();
      last$1(stack).appendChild(el2);
    }
  },
  html: function(token, stack) {
    last$1(stack).insertAdjacentHTML("beforeend", token.content);
  },
  text: function(token, stack) {
    var textNode = document.createTextNode(token.content);
    last$1(stack).appendChild(textNode);
  }
};
var WwToDOMAdaptor = (
  /** @class */
  (function() {
    function WwToDOMAdaptor2(linkAttributes, customRenderer) {
      var convertors2 = getHTMLRenderConvertors(linkAttributes, customRenderer);
      var customHTMLConvertor = __assign$1(__assign$1({}, customRenderer.htmlBlock), customRenderer.htmlInline);
      this.customConvertorKeys = Object.keys(customRenderer).concat(Object.keys(customHTMLConvertor));
      this.renderer = new Renderer({
        gfm: true,
        convertors: __assign$1(__assign$1({}, convertors2), customHTMLConvertor)
      });
      this.convertors = this.renderer.getConvertors();
    }
    WwToDOMAdaptor2.prototype.generateTokens = function(node4) {
      var mdLikeNode = createMdLikeNode(node4);
      var context = {
        entering: true,
        leaf: isPmNode(node4) ? node4.isLeaf : false,
        options: this.renderer.getOptions(),
        getChildrenText: function() {
          return isPmNode(node4) ? node4.textContent : "";
        },
        skipChildren: function() {
          return false;
        }
      };
      var convertor = this.convertors[node4.type.name];
      var converted = convertor(mdLikeNode, context, this.convertors);
      var tokens = isArray_1(converted) ? converted : [converted];
      if (isContainer(node4.type.name) || node4.attrs.htmlInline) {
        context.entering = false;
        tokens.push({ type: "text", content: isPmNode(node4) ? node4.textContent : "" });
        tokens = tokens.concat(convertor(mdLikeNode, context, this.convertors));
      }
      return tokens;
    };
    WwToDOMAdaptor2.prototype.toDOMNode = function(node4) {
      var tokens = this.generateTokens(node4);
      var stack = [];
      tokens.forEach(function(token) {
        return tokenToDOMNode[token.type](token, stack);
      });
      return stack[0];
    };
    WwToDOMAdaptor2.prototype.getToDOMNode = function(name) {
      if (includes2(this.customConvertorKeys, name)) {
        return this.toDOMNode.bind(this);
      }
      return null;
    };
    return WwToDOMAdaptor2;
  })()
);
var ANIMATION_TIME = 100;
var SCROLL_BLOCKING_RESET_DELAY = 15;
var currentTimeoutId = null;
var releaseTimer = null;
function run2(deltaScrollTop, _a) {
  var syncScrollTop = _a.syncScrollTop, releaseEventBlock = _a.releaseEventBlock;
  if (releaseTimer) {
    clearTimeout(releaseTimer);
  }
  syncScrollTop(deltaScrollTop);
  releaseTimer = setTimeout(function() {
    releaseEventBlock();
  }, SCROLL_BLOCKING_RESET_DELAY);
}
function animate(curScrollTop, targetScrollTop, syncCallbacks) {
  var diff2 = targetScrollTop - curScrollTop;
  var startTime = Date.now();
  var step2 = function() {
    var stepTime = Date.now();
    var progress = (stepTime - startTime) / ANIMATION_TIME;
    var deltaValue;
    if (currentTimeoutId) {
      clearTimeout(currentTimeoutId);
    }
    if (progress < 1) {
      deltaValue = curScrollTop + diff2 * Math.cos((1 - progress) * Math.PI / 2);
      run2(Math.ceil(deltaValue), syncCallbacks);
      currentTimeoutId = setTimeout(step2, 1);
    } else {
      run2(targetScrollTop, syncCallbacks);
      currentTimeoutId = null;
    }
  };
  step2();
}
var EDITOR_BOTTOM_PADDING = 18;
var ScrollSync = (
  /** @class */
  (function() {
    function ScrollSync2(mdEditor, preview, eventEmitter) {
      this.latestEditorScrollTop = null;
      this.latestPreviewScrollTop = null;
      this.blockedScroll = null;
      this.active = true;
      this.timer = null;
      var previewRoot = preview.previewContent, previewEl = preview.el;
      this.previewRoot = previewRoot;
      this.previewEl = previewEl;
      this.mdEditor = mdEditor;
      this.editorView = mdEditor.view;
      this.toastMark = mdEditor.getToastMark();
      this.eventEmitter = eventEmitter;
      this.addScrollSyncEvent();
    }
    ScrollSync2.prototype.addScrollSyncEvent = function() {
      var _this = this;
      this.eventEmitter.listen("afterPreviewRender", function() {
        _this.clearTimer();
        _this.timer = setTimeout(function() {
          _this.syncPreviewScrollTop(true);
        }, 200);
      });
      this.eventEmitter.listen("scroll", function(type, data) {
        if (_this.active) {
          if (type === "editor" && _this.blockedScroll !== "editor") {
            _this.syncPreviewScrollTop();
          } else if (type === "preview" && _this.blockedScroll !== "preview") {
            _this.syncEditorScrollTop(data);
          }
        }
      });
      this.eventEmitter.listen("toggleScrollSync", function(active) {
        _this.active = active;
      });
    };
    ScrollSync2.prototype.getMdNodeAtPos = function(doc2, posInfo) {
      var indexInfo = doc2.content.findIndex(posInfo.pos);
      var line = indexInfo.index;
      return this.toastMark.findFirstNodeAtLine(line + 1);
    };
    ScrollSync2.prototype.getScrollTopByCaretPos = function() {
      var pos = this.mdEditor.getSelection();
      var firstMdNode = this.toastMark.findFirstNodeAtLine(pos[0][0]);
      var previewHeight = this.previewEl.clientHeight;
      var el2 = getParentNodeObj(this.previewRoot, firstMdNode).el;
      var totalOffsetTop = getTotalOffsetTop2(el2, this.previewRoot) || el2.offsetTop;
      var nodeHeight = el2.clientHeight;
      var targetScrollTop = totalOffsetTop + nodeHeight - previewHeight * 0.5;
      this.latestEditorScrollTop = null;
      var diff2 = el2.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;
      return diff2 < previewHeight ? null : targetScrollTop;
    };
    ScrollSync2.prototype.syncPreviewScrollTop = function(editing) {
      if (editing === void 0) {
        editing = false;
      }
      var _a = this, editorView = _a.editorView, previewEl = _a.previewEl, previewRoot = _a.previewRoot;
      var _b = editorView.dom.getBoundingClientRect(), left = _b.left, top2 = _b.top;
      var posInfo = editorView.posAtCoords({ left, top: top2 });
      var doc2 = editorView.state.doc;
      var firstMdNode = this.getMdNodeAtPos(doc2, posInfo);
      if (!firstMdNode || isHTMLNode(firstMdNode)) {
        return;
      }
      var curScrollTop = previewEl.scrollTop;
      var _c = editorView.dom, scrollTop = _c.scrollTop, scrollHeight = _c.scrollHeight, clientHeight = _c.clientHeight, children = _c.children;
      var isBottomPos = scrollHeight - scrollTop <= clientHeight + EDITOR_BOTTOM_PADDING;
      var targetScrollTop = isBottomPos ? previewEl.scrollHeight : 0;
      if (scrollTop && !isBottomPos) {
        if (editing) {
          var scrollTopByEditing = this.getScrollTopByCaretPos();
          if (!scrollTopByEditing) {
            return;
          }
          targetScrollTop = scrollTopByEditing;
        } else {
          var _d = getParentNodeObj(this.previewRoot, firstMdNode), el2 = _d.el, mdNode = _d.mdNode;
          var _e = getEditorRangeHeightInfo(doc2, mdNode, children), height = _e.height, rect2 = _e.rect;
          var totalOffsetTop = getTotalOffsetTop2(el2, previewRoot) || el2.offsetTop;
          var nodeHeight = el2.clientHeight;
          var ratio2 = top2 > rect2.top ? Math.min((top2 - rect2.top) / height, 1) : 0;
          targetScrollTop = totalOffsetTop + nodeHeight * ratio2;
        }
        targetScrollTop = this.getResolvedScrollTop("editor", scrollTop, targetScrollTop, curScrollTop);
        this.latestEditorScrollTop = scrollTop;
      }
      if (targetScrollTop !== curScrollTop) {
        this.run("editor", targetScrollTop, curScrollTop);
      }
    };
    ScrollSync2.prototype.syncEditorScrollTop = function(targetNode) {
      var _a = this, toastMark = _a.toastMark, editorView = _a.editorView, previewRoot = _a.previewRoot, previewEl = _a.previewEl;
      var dom = editorView.dom, state = editorView.state;
      var scrollTop = previewEl.scrollTop, clientHeight = previewEl.clientHeight, scrollHeight = previewEl.scrollHeight;
      var isBottomPos = scrollHeight - scrollTop <= clientHeight;
      var curScrollTop = dom.scrollTop;
      var targetScrollTop = isBottomPos ? dom.scrollHeight : 0;
      if (scrollTop && targetNode && !isBottomPos) {
        targetNode = findAncestorHavingId(targetNode, previewRoot);
        if (!targetNode.getAttribute("data-nodeid")) {
          return;
        }
        var children = dom.children;
        var mdNodeId = Number(targetNode.getAttribute("data-nodeid"));
        var _b = getParentNodeObj(this.previewRoot, toastMark.findNodeById(mdNodeId)), mdNode = _b.mdNode, el2 = _b.el;
        var mdNodeStartLine = getMdStartLine2(mdNode);
        targetScrollTop = children[mdNodeStartLine - 1].offsetTop;
        var height = getEditorRangeHeightInfo(state.doc, mdNode, children).height;
        var _c = getAndSaveOffsetInfo(el2, previewRoot, mdNodeId), nodeHeight = _c.nodeHeight, offsetTop = _c.offsetTop;
        targetScrollTop += getAdditionalPos(scrollTop, offsetTop, nodeHeight, height);
        targetScrollTop = this.getResolvedScrollTop("preview", scrollTop, targetScrollTop, curScrollTop);
        this.latestPreviewScrollTop = scrollTop;
      }
      if (targetScrollTop !== curScrollTop) {
        this.run("preview", targetScrollTop, curScrollTop);
      }
    };
    ScrollSync2.prototype.getResolvedScrollTop = function(from4, scrollTop, targetScrollTop, curScrollTop) {
      var latestScrollTop = from4 === "editor" ? this.latestEditorScrollTop : this.latestPreviewScrollTop;
      if (latestScrollTop === null) {
        return targetScrollTop;
      }
      return latestScrollTop < scrollTop ? Math.max(targetScrollTop, curScrollTop) : Math.min(targetScrollTop, curScrollTop);
    };
    ScrollSync2.prototype.run = function(from4, targetScrollTop, curScrollTop) {
      var _this = this;
      var scrollTarget;
      if (from4 === "editor") {
        scrollTarget = this.previewEl;
        this.blockedScroll = "preview";
      } else {
        scrollTarget = this.editorView.dom;
        this.blockedScroll = "editor";
      }
      var syncCallbacks = {
        syncScrollTop: function(scrollTop) {
          return scrollTarget.scrollTop = scrollTop;
        },
        releaseEventBlock: function() {
          return _this.blockedScroll = null;
        }
      };
      animate(curScrollTop, targetScrollTop, syncCallbacks);
    };
    ScrollSync2.prototype.clearTimer = function() {
      if (this.timer) {
        clearTimeout(this.timer);
        this.timer = null;
      }
    };
    ScrollSync2.prototype.destroy = function() {
      this.clearTimer();
      this.eventEmitter.removeEventHandler("scroll");
      this.eventEmitter.removeEventHandler("afterPreviewRender");
    };
    return ScrollSync2;
  })()
);
var queryMap = {
  getPopupInitialValues: function(editor, payload) {
    var popupName = payload.popupName;
    return popupName === "link" ? { linkText: editor.getSelectedText() } : {};
  }
};
function buildQuery(editor) {
  editor.eventEmitter.listen("query", function(query, payload) {
    return queryMap[query](editor, payload);
  });
}
var ToastUIEditorCore = (
  /** @class */
  (function() {
    function ToastUIEditorCore2(options) {
      var _this = this;
      this.initialHTML = options.el.innerHTML;
      options.el.innerHTML = "";
      this.options = extend_1({
        previewStyle: "tab",
        previewHighlight: true,
        initialEditType: "markdown",
        height: "300px",
        minHeight: "200px",
        language: "en-US",
        useCommandShortcut: true,
        usageStatistics: true,
        toolbarItems: [
          ["heading", "bold", "italic", "strike"],
          ["hr", "quote"],
          ["ul", "ol", "task", "indent", "outdent"],
          ["table", "image", "link"],
          ["code", "codeblock"],
          ["scrollSync"]
        ],
        hideModeSwitch: false,
        linkAttributes: null,
        extendedAutolinks: false,
        customHTMLRenderer: null,
        customMarkdownRenderer: null,
        referenceDefinition: false,
        customHTMLSanitizer: null,
        frontMatter: false,
        widgetRules: [],
        theme: "light",
        autofocus: true
      }, options);
      var _a = this.options, customHTMLRenderer = _a.customHTMLRenderer, extendedAutolinks = _a.extendedAutolinks, referenceDefinition = _a.referenceDefinition, frontMatter2 = _a.frontMatter, customMarkdownRenderer = _a.customMarkdownRenderer, useCommandShortcut = _a.useCommandShortcut, initialEditType = _a.initialEditType, widgetRules2 = _a.widgetRules, customHTMLSanitizer = _a.customHTMLSanitizer;
      this.mode = initialEditType || "markdown";
      this.mdPreviewStyle = this.options.previewStyle;
      this.i18n = i18n;
      this.i18n.setCode(this.options.language);
      this.eventEmitter = new EventEmitter();
      setWidgetRules(widgetRules2);
      var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);
      this.pluginInfo = getPluginInfo(this.options.plugins, this.eventEmitter, this.options.usageStatistics);
      var _b = this.pluginInfo, toHTMLRenderers = _b.toHTMLRenderers, toMarkdownRenderers = _b.toMarkdownRenderers, mdPlugins = _b.mdPlugins, wwPlugins = _b.wwPlugins, wwNodeViews = _b.wwNodeViews, mdCommands = _b.mdCommands, wwCommands = _b.wwCommands, markdownParsers = _b.markdownParsers;
      var rendererOptions = {
        linkAttributes,
        customHTMLRenderer: deepMergedCopy(toHTMLRenderers, customHTMLRenderer),
        extendedAutolinks,
        referenceDefinition,
        frontMatter: frontMatter2,
        sanitizer: customHTMLSanitizer || sanitizeHTML
      };
      var wwToDOMAdaptor = new WwToDOMAdaptor(linkAttributes, rendererOptions.customHTMLRenderer);
      var htmlSchemaMap = createHTMLSchemaMap(rendererOptions.customHTMLRenderer, rendererOptions.sanitizer, wwToDOMAdaptor);
      this.toastMark = new ToastMark("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks,
        referenceDefinition,
        disallowDeepHeading: true,
        frontMatter: frontMatter2,
        customParser: markdownParsers
      });
      this.mdEditor = new MdEditor(this.eventEmitter, {
        toastMark: this.toastMark,
        useCommandShortcut,
        mdPlugins
      });
      this.preview = new MarkdownPreview(this.eventEmitter, __assign$1(__assign$1({}, rendererOptions), { isViewer: false, highlight: this.options.previewHighlight }));
      this.wwEditor = new WysiwygEditor(this.eventEmitter, {
        toDOMAdaptor: wwToDOMAdaptor,
        useCommandShortcut,
        htmlSchemaMap,
        linkAttributes,
        wwPlugins,
        wwNodeViews
      });
      this.convertor = new Convertor(this.wwEditor.getSchema(), __assign$1(__assign$1({}, toMarkdownRenderers), customMarkdownRenderer), getHTMLRenderConvertors(linkAttributes, rendererOptions.customHTMLRenderer), this.eventEmitter);
      this.setMinHeight(this.options.minHeight);
      this.setHeight(this.options.height);
      this.setMarkdown(this.options.initialValue, false);
      if (this.options.placeholder) {
        this.setPlaceholder(this.options.placeholder);
      }
      if (!this.options.initialValue) {
        this.setHTML(this.initialHTML, false);
      }
      this.commandManager = new CommandManager(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function() {
        return _this.mode;
      });
      if (this.options.usageStatistics) {
        sendHostName();
      }
      this.scrollSync = new ScrollSync(this.mdEditor, this.preview, this.eventEmitter);
      this.addInitEvent();
      this.addInitCommand(mdCommands, wwCommands);
      buildQuery(this);
      if (this.options.hooks) {
        forEachOwnProperties_1(this.options.hooks, function(fn, key) {
          return _this.addHook(key, fn);
        });
      }
      if (this.options.events) {
        forEachOwnProperties_1(this.options.events, function(fn, key) {
          return _this.on(key, fn);
        });
      }
      this.eventEmitter.emit("load", this);
      this.moveCursorToStart(this.options.autofocus);
    }
    ToastUIEditorCore2.prototype.addInitEvent = function() {
      var _this = this;
      this.on("needChangeMode", this.changeMode.bind(this));
      this.on("loadUI", function() {
        if (_this.height !== "auto") {
          var minHeight = Math.min(parseInt(_this.minHeight, 10), parseInt(_this.height, 10) - 75) + "px";
          _this.setMinHeight(minHeight);
        }
      });
      addDefaultImageBlobHook(this.eventEmitter);
    };
    ToastUIEditorCore2.prototype.addInitCommand = function(mdCommands, wwCommands) {
      var _this = this;
      var addPluginCommands = function(type, commandMap) {
        Object.keys(commandMap).forEach(function(name) {
          _this.addCommand(type, name, commandMap[name]);
        });
      };
      this.addCommand("markdown", "toggleScrollSync", function(payload) {
        _this.eventEmitter.emit("toggleScrollSync", payload.active);
        return true;
      });
      addPluginCommands("markdown", mdCommands);
      addPluginCommands("wysiwyg", wwCommands);
    };
    ToastUIEditorCore2.prototype.getCurrentModeEditor = function() {
      return this.isMarkdownMode() ? this.mdEditor : this.wwEditor;
    };
    ToastUIEditorCore2.factory = function(options) {
      return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditorCore2(options);
    };
    ToastUIEditorCore2.setLanguage = function(code2, data) {
      i18n.setLanguage(code2, data);
    };
    ToastUIEditorCore2.prototype.changePreviewStyle = function(style) {
      if (this.mdPreviewStyle !== style) {
        this.mdPreviewStyle = style;
        this.eventEmitter.emit("changePreviewStyle", style);
      }
    };
    ToastUIEditorCore2.prototype.exec = function(name, payload) {
      this.commandManager.exec(name, payload);
    };
    ToastUIEditorCore2.prototype.addCommand = function(type, name, command) {
      var _this = this;
      var commandHoc = function(paylaod) {
        if (paylaod === void 0) {
          paylaod = {};
        }
        var view = (type === "markdown" ? _this.mdEditor : _this.wwEditor).view;
        command(paylaod, view.state, view.dispatch, view);
      };
      this.commandManager.addCommand(type, name, commandHoc);
    };
    ToastUIEditorCore2.prototype.on = function(type, handler) {
      this.eventEmitter.listen(type, handler);
    };
    ToastUIEditorCore2.prototype.off = function(type) {
      this.eventEmitter.removeEventHandler(type);
    };
    ToastUIEditorCore2.prototype.addHook = function(type, handler) {
      this.eventEmitter.removeEventHandler(type);
      this.eventEmitter.listen(type, handler);
    };
    ToastUIEditorCore2.prototype.removeHook = function(type) {
      this.eventEmitter.removeEventHandler(type);
    };
    ToastUIEditorCore2.prototype.focus = function() {
      this.getCurrentModeEditor().focus();
    };
    ToastUIEditorCore2.prototype.blur = function() {
      this.getCurrentModeEditor().blur();
    };
    ToastUIEditorCore2.prototype.moveCursorToEnd = function(focus2) {
      if (focus2 === void 0) {
        focus2 = true;
      }
      this.getCurrentModeEditor().moveCursorToEnd(focus2);
    };
    ToastUIEditorCore2.prototype.moveCursorToStart = function(focus2) {
      if (focus2 === void 0) {
        focus2 = true;
      }
      this.getCurrentModeEditor().moveCursorToStart(focus2);
    };
    ToastUIEditorCore2.prototype.setMarkdown = function(markdown, cursorToEnd) {
      if (markdown === void 0) {
        markdown = "";
      }
      if (cursorToEnd === void 0) {
        cursorToEnd = true;
      }
      this.mdEditor.setMarkdown(markdown, cursorToEnd);
      if (this.isWysiwygMode()) {
        var mdNode = this.toastMark.getRootNode();
        var wwNode = this.convertor.toWysiwygModel(mdNode);
        this.wwEditor.setModel(wwNode, cursorToEnd);
      }
    };
    ToastUIEditorCore2.prototype.setHTML = function(html2, cursorToEnd) {
      if (html2 === void 0) {
        html2 = "";
      }
      if (cursorToEnd === void 0) {
        cursorToEnd = true;
      }
      var container = document.createElement("div");
      container.innerHTML = replaceBRWithEmptyBlock(html2);
      var wwNode = DOMParser.fromSchema(this.wwEditor.schema).parse(container);
      if (this.isMarkdownMode()) {
        this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), cursorToEnd);
      } else {
        this.wwEditor.setModel(wwNode, cursorToEnd);
      }
    };
    ToastUIEditorCore2.prototype.getMarkdown = function() {
      if (this.isMarkdownMode()) {
        return this.mdEditor.getMarkdown();
      }
      return this.convertor.toMarkdownText(this.wwEditor.getModel());
    };
    ToastUIEditorCore2.prototype.getHTML = function() {
      var _this = this;
      this.eventEmitter.holdEventInvoke(function() {
        if (_this.isMarkdownMode()) {
          var mdNode = _this.toastMark.getRootNode();
          var wwNode = _this.convertor.toWysiwygModel(mdNode);
          _this.wwEditor.setModel(wwNode);
        }
      });
      var html2 = this.wwEditor.view.dom.innerHTML;
      if (this.placeholder) {
        var rePlaceholder = new RegExp('<span class="placeholder[^>]+>' + this.placeholder + "</span>", "i");
        return html2.replace(rePlaceholder, "");
      }
      return html2;
    };
    ToastUIEditorCore2.prototype.insertText = function(text3) {
      this.getCurrentModeEditor().replaceSelection(text3);
    };
    ToastUIEditorCore2.prototype.setSelection = function(start3, end2) {
      this.getCurrentModeEditor().setSelection(start3, end2);
    };
    ToastUIEditorCore2.prototype.replaceSelection = function(text3, start3, end2) {
      this.getCurrentModeEditor().replaceSelection(text3, start3, end2);
    };
    ToastUIEditorCore2.prototype.deleteSelection = function(start3, end2) {
      this.getCurrentModeEditor().deleteSelection(start3, end2);
    };
    ToastUIEditorCore2.prototype.getSelectedText = function(start3, end2) {
      return this.getCurrentModeEditor().getSelectedText(start3, end2);
    };
    ToastUIEditorCore2.prototype.getRangeInfoOfNode = function(pos) {
      return this.getCurrentModeEditor().getRangeInfoOfNode(pos);
    };
    ToastUIEditorCore2.prototype.addWidget = function(node4, style, pos) {
      this.getCurrentModeEditor().addWidget(node4, style, pos);
    };
    ToastUIEditorCore2.prototype.replaceWithWidget = function(start3, end2, text3) {
      this.getCurrentModeEditor().replaceWithWidget(start3, end2, text3);
    };
    ToastUIEditorCore2.prototype.setHeight = function(height) {
      var el2 = this.options.el;
      if (isString_1(height)) {
        if (height === "auto") {
          addClass_1(el2, "auto-height");
        } else {
          removeClass_1(el2, "auto-height");
        }
        this.setMinHeight(this.getMinHeight());
      }
      css_1(el2, { height });
      this.height = height;
    };
    ToastUIEditorCore2.prototype.getHeight = function() {
      return this.height;
    };
    ToastUIEditorCore2.prototype.setMinHeight = function(minHeight) {
      if (minHeight !== this.minHeight) {
        var height = this.height || this.options.height;
        if (height !== "auto" && this.options.el.querySelector("." + cls("main"))) {
          minHeight = Math.min(parseInt(minHeight, 10), parseInt(height, 10) - 75) + "px";
        }
        var minHeightNum = parseInt(minHeight, 10);
        this.minHeight = minHeight;
        this.wwEditor.setMinHeight(minHeightNum);
        this.mdEditor.setMinHeight(minHeightNum);
        this.preview.setMinHeight(minHeightNum);
      }
    };
    ToastUIEditorCore2.prototype.getMinHeight = function() {
      return this.minHeight;
    };
    ToastUIEditorCore2.prototype.isMarkdownMode = function() {
      return this.mode === "markdown";
    };
    ToastUIEditorCore2.prototype.isWysiwygMode = function() {
      return this.mode === "wysiwyg";
    };
    ToastUIEditorCore2.prototype.isViewer = function() {
      return false;
    };
    ToastUIEditorCore2.prototype.getCurrentPreviewStyle = function() {
      return this.mdPreviewStyle;
    };
    ToastUIEditorCore2.prototype.changeMode = function(mode, withoutFocus) {
      if (this.mode === mode) {
        return;
      }
      this.mode = mode;
      if (this.isWysiwygMode()) {
        var mdNode = this.toastMark.getRootNode();
        var wwNode = this.convertor.toWysiwygModel(mdNode);
        this.wwEditor.setModel(wwNode);
      } else {
        var wwNode = this.wwEditor.getModel();
        this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), !withoutFocus);
      }
      this.eventEmitter.emit("removePopupWidget");
      this.eventEmitter.emit("changeMode", mode);
      if (!withoutFocus) {
        var pos = this.convertor.getMappedPos();
        this.focus();
        if (this.isWysiwygMode() && isNumber_1(pos)) {
          this.wwEditor.setSelection(pos);
        } else if (Array.isArray(pos)) {
          this.mdEditor.setSelection(pos);
        }
      }
    };
    ToastUIEditorCore2.prototype.destroy = function() {
      var _this = this;
      this.wwEditor.destroy();
      this.mdEditor.destroy();
      this.preview.destroy();
      this.scrollSync.destroy();
      this.eventEmitter.emit("destroy");
      this.eventEmitter.getEvents().forEach(function(_, type) {
        return _this.off(type);
      });
    };
    ToastUIEditorCore2.prototype.hide = function() {
      this.eventEmitter.emit("hide");
    };
    ToastUIEditorCore2.prototype.show = function() {
      this.eventEmitter.emit("show");
    };
    ToastUIEditorCore2.prototype.setScrollTop = function(value) {
      this.getCurrentModeEditor().setScrollTop(value);
    };
    ToastUIEditorCore2.prototype.getScrollTop = function() {
      return this.getCurrentModeEditor().getScrollTop();
    };
    ToastUIEditorCore2.prototype.reset = function() {
      this.wwEditor.setModel([]);
      this.mdEditor.setMarkdown("");
    };
    ToastUIEditorCore2.prototype.getSelection = function() {
      return this.getCurrentModeEditor().getSelection();
    };
    ToastUIEditorCore2.prototype.setPlaceholder = function(placeholder2) {
      this.placeholder = placeholder2;
      this.mdEditor.setPlaceholder(placeholder2);
      this.wwEditor.setPlaceholder(placeholder2);
    };
    ToastUIEditorCore2.prototype.getEditorElements = function() {
      return {
        mdEditor: this.mdEditor.getElement(),
        mdPreview: this.preview.getElement(),
        wwEditor: this.wwEditor.getElement()
      };
    };
    ToastUIEditorCore2.prototype.convertPosToMatchEditorMode = function(start3, end2, mode) {
      var _a, _b;
      if (end2 === void 0) {
        end2 = start3;
      }
      if (mode === void 0) {
        mode = this.mode;
      }
      var doc2 = this.mdEditor.view.state.doc;
      var isFromArray = Array.isArray(start3);
      var isToArray = Array.isArray(end2);
      var convertedFrom = start3;
      var convertedTo = end2;
      if (isFromArray !== isToArray) {
        throw new Error("Types of arguments must be same");
      }
      if (mode === "markdown" && !isFromArray && !isToArray) {
        _a = getEditorToMdPos(doc2, start3, end2), convertedFrom = _a[0], convertedTo = _a[1];
      } else if (mode === "wysiwyg" && isFromArray && isToArray) {
        _b = getMdToEditorPos(doc2, start3, end2), convertedFrom = _b[0], convertedTo = _b[1];
      }
      return [convertedFrom, convertedTo];
    };
    return ToastUIEditorCore2;
  })()
);
function html$1(n) {
  for (var l, e, s = arguments, t = 1, r = "", u = "", a = [0], c = function(n2) {
    t === 1 && (n2 || (r = r.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? a.push(n2 ? s[n2] : r) : t === 3 && (n2 || r) ? (a[1] = n2 ? s[n2] : r, t = 2) : t === 2 && r === "..." && n2 ? a[2] = assign(a[2] || {}, s[n2]) : t === 2 && r && !n2 ? (a[2] = a[2] || {})[r] = true : t >= 5 && (t === 5 ? ((a[2] = a[2] || {})[e] = n2 ? r ? r + s[n2] : s[n2] : r, t = 6) : (n2 || r) && (a[2][e] += n2 ? r + s[n2] : r)), r = "";
  }, h2 = 0; h2 < n.length; h2++) {
    h2 && (t === 1 && c(), c(h2));
    for (let i = 0; i < n[h2].length; i++)
      l = n[h2][i], t === 1 ? l === "<" ? (c(), a = [a, "", null], t = 3) : r += l : t === 4 ? r === "--" && l === ">" ? (t = 1, r = "") : r = l + r[0] : u ? l === u ? u = "" : r += l : l === '"' || l === "'" ? u = l : l === ">" ? (c(), t = 1) : t && (l === "=" ? (t = 5, e = r, r = "") : l === "/" && (t < 5 || n[h2][i + 1] === ">") ? (c(), t === 3 && (a = a[0]), t = a, (a = a[0]).push(this.apply(null, t.slice(1))), t = 0) : l === " " || l === "	" || l === "\n" || l === "\r" ? (c(), t = 2) : r += l), t === 3 && r === "!--" && (t = 4, a = a[0]);
  }
  return c(), a.length > 2 ? a.slice(1) : a[1];
}
function isBoolean(obj) {
  return typeof obj === "boolean" || obj instanceof Boolean;
}
var isBoolean_1 = isBoolean;
var VNodeWalker = (
  /** @class */
  (function() {
    function VNodeWalker2(current) {
      this.current = current;
      this.root = current;
      this.entering = true;
    }
    VNodeWalker2.prototype.walk = function() {
      var _a = this, entering = _a.entering, cur = _a.current;
      if (!cur) {
        return null;
      }
      if (entering) {
        if (cur.firstChild) {
          this.current = cur.firstChild;
          this.entering = true;
        } else {
          this.entering = false;
        }
      } else if (cur === this.root) {
        this.current = null;
      } else if (cur.next) {
        this.current = cur.next;
        this.entering = true;
      } else {
        this.current = cur.parent;
        this.entering = false;
      }
      return { vnode: cur, entering };
    };
    return VNodeWalker2;
  })()
);
var VNode = (
  /** @class */
  (function() {
    function VNode2(type, props, children) {
      this.parent = null;
      this.old = null;
      this.firstChild = null;
      this.next = null;
      this.skip = false;
      this.type = type;
      this.props = props;
      this.children = children;
      this.props.children = children;
      if (props.ref) {
        this.ref = props.ref;
        delete props.ref;
      }
      if (props.key) {
        this.key = props.key;
        delete props.key;
      }
    }
    VNode2.prototype.walker = function() {
      return new VNodeWalker(this);
    };
    VNode2.removalNodes = [];
    return VNode2;
  })()
);
function createTextNode(text3) {
  return new VNode("TEXT_NODE", { nodeValue: text3 }, []);
}
function excludeUnnecessaryChild(child3, flatted) {
  var vnode = child3;
  if (isBoolean_1(child3) || child3 == null) {
    vnode = null;
  } else if (isString_1(child3) || isNumber_1(child3)) {
    vnode = createTextNode(String(child3));
  }
  if (vnode) {
    flatted.push(vnode);
  }
}
function h(type, props) {
  var children = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }
  var flatted = [];
  children.forEach(function(child3) {
    if (Array.isArray(child3)) {
      child3.forEach(function(vnode) {
        excludeUnnecessaryChild(vnode, flatted);
      });
    } else {
      excludeUnnecessaryChild(child3, flatted);
    }
  });
  return new VNode(type, props || {}, flatted);
}
var html = html$1.bind(h);
function isObject(obj) {
  return obj === Object(obj);
}
var isObject_1 = isObject;
function createNode(vnode) {
  var node4;
  if (vnode.type === "TEXT_NODE") {
    node4 = document.createTextNode(vnode.props.nodeValue);
  } else {
    node4 = document.createElement(vnode.type);
    setProps2(node4, {}, vnode.props);
  }
  return node4;
}
function removeNode(vnode, parentNode2) {
  if (vnode.node) {
    parentNode2.removeChild(vnode.node);
  } else {
    removeNode(vnode.firstChild, parentNode2);
  }
}
function innerDiff(node4, prevProps, nextProps) {
  Object.keys(prevProps).forEach(function(propName) {
    if (/^on/.test(propName)) {
      if (!nextProps[propName] || prevProps[propName] !== nextProps[propName]) {
        var eventName = propName.slice(2).toLowerCase();
        node4.removeEventListener(eventName, prevProps[propName]);
      }
    } else if (propName !== "children" && !nextProps[propName] && !isTextNode(node4)) {
      node4.removeAttribute(propName);
    }
  });
  setProps2(node4, prevProps, nextProps, function(propName) {
    return !shallowEqual(prevProps[propName], nextProps[propName]);
  });
}
var reNonDimension = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function setProps2(node4, prevProps, props, condition) {
  Object.keys(props).forEach(function(propName) {
    if (!condition || condition(propName)) {
      if (/^on/.test(propName)) {
        var eventName = propName.slice(2).toLowerCase();
        node4.addEventListener(eventName, props[propName]);
      } else if (propName === "nodeValue") {
        node4[propName] = props[propName];
      } else if (propName === "style" && isObject_1(props[propName])) {
        setStyleProps(node4, prevProps[propName], props[propName]);
      } else if (propName !== "children") {
        if (props[propName] === false) {
          node4.removeAttribute(propName);
        } else {
          node4.setAttribute(propName, props[propName]);
        }
      }
    }
  });
}
function setStyleProps(node4, prevStyleProps, styleProps) {
  if (prevStyleProps) {
    Object.keys(prevStyleProps).forEach(function(styleProp) {
      node4.style[styleProp] = "";
    });
  }
  Object.keys(styleProps).forEach(function(styleProp) {
    var value = styleProps[styleProp];
    node4.style[styleProp] = isNumber_1(value) && !reNonDimension.test(styleProp) ? value + "px" : value;
  });
}
function commit(vnode) {
  VNode.removalNodes.forEach(function(removalNode) {
    return diff(removalNode);
  });
  if (vnode) {
    var next = void 0;
    var walker = vnode.walker();
    while (next = walker.walk()) {
      vnode = next.vnode;
      if (next.entering) {
        diff(vnode);
      } else if (isFunction_1(vnode.type)) {
        var comp2 = vnode.component;
        if (!vnode.old && comp2.mounted) {
          comp2.mounted();
        }
        if (vnode.old && comp2.updated) {
          var prevProps = comp2.prevProps || {};
          comp2.updated(prevProps);
        }
      }
    }
  }
}
function getParentNode(vnode) {
  var parent = vnode.parent;
  while (!parent.node) {
    parent = parent.parent;
  }
  return parent.node;
}
function diff(vnode) {
  if (!vnode || !vnode.parent) {
    return;
  }
  if (vnode.node) {
    var parentNode2 = getParentNode(vnode);
    if (vnode.effect === "A") {
      parentNode2.appendChild(vnode.node);
    } else if (vnode.effect === "U") {
      innerDiff(vnode.node, vnode.old.props, vnode.props);
    }
  }
  if (vnode.effect === "D") {
    var next = void 0;
    var walker = vnode.walker();
    while (next = walker.walk()) {
      vnode = next.vnode;
      if (!next.entering) {
        if (isFunction_1(vnode.type)) {
          var comp2 = vnode.component;
          if (comp2.beforeDestroy) {
            comp2.beforeDestroy();
          }
        } else {
          var parentNode2 = getParentNode(vnode);
          removeNode(vnode, parentNode2);
        }
      }
    }
  }
  if (vnode.ref) {
    if (vnode.component) {
      vnode.ref(vnode.component);
    } else if (vnode.node) {
      vnode.ref(vnode.node);
    }
  }
}
function createComponent(Comp, vnode) {
  var props = vnode.props, component = vnode.component;
  if (component) {
    component.prevProps = component.props;
    component.props = vnode.props;
    return component;
  }
  return new Comp(props);
}
function buildVNode(vnode) {
  var root = vnode;
  while (vnode && !vnode.skip) {
    if (isFunction_1(vnode.type)) {
      var instance = createComponent(vnode.type, vnode);
      instance.vnode = vnode;
      vnode.component = instance;
      vnode.props.children = vnode.children = [instance.render()];
      buildChildrenVNode(vnode);
    } else {
      if (!vnode.node) {
        vnode.node = createNode(vnode);
      }
      buildChildrenVNode(vnode);
    }
    if (vnode.firstChild) {
      vnode = vnode.firstChild;
    } else {
      while (vnode && vnode.parent && !vnode.next) {
        vnode = vnode.parent;
        if (vnode === root) {
          break;
        }
      }
      vnode = vnode.next;
    }
  }
}
function isSameType(old, vnode) {
  return old && vnode && vnode.type === old.type && (!vnode.key || vnode.key === old.key);
}
function buildChildrenVNode(parent) {
  var children = parent.children;
  var old = parent.old ? parent.old.firstChild : null;
  var prev = null;
  children.forEach(function(vnode, index3) {
    var sameType = isSameType(old, vnode);
    if (sameType) {
      vnode.old = old;
      vnode.parent = parent;
      vnode.node = old.node;
      vnode.component = old.component;
      vnode.effect = "U";
    }
    if (vnode && !sameType) {
      vnode.old = null;
      vnode.parent = parent;
      vnode.node = null;
      vnode.effect = "A";
    }
    if (old && !sameType) {
      VNode.removalNodes.push(old);
      old.effect = "D";
    }
    if (old) {
      old = old.next;
    }
    if (index3 === 0) {
      parent.firstChild = vnode;
    } else if (vnode) {
      prev.next = vnode;
    }
    prev = vnode;
  });
  var lastChild = last$1(children);
  if (!children.length) {
    while (old) {
      VNode.removalNodes.push(old);
      old.effect = "D";
      old = old.next;
    }
  }
  while (old && lastChild) {
    if (old && lastChild.old !== old) {
      VNode.removalNodes.push(old);
      old.effect = "D";
      old = old.next;
    }
  }
}
function destroy3(vnode) {
  vnode.effect = "D";
  VNode.removalNodes = [vnode];
  commit();
  VNode.removalNodes = [];
}
function rerender(comp2) {
  var root = comp2.vnode;
  root.effect = "U";
  root.old = root;
  if (root.next) {
    root.next.skip = true;
  }
  VNode.removalNodes = [];
  buildVNode(root);
  commit(root);
  if (root.next) {
    root.next.skip = false;
  }
}
function render(container, vnode) {
  var root = new VNode(container.tagName.toLowerCase(), {}, [vnode]);
  root.node = container;
  VNode.removalNodes = [];
  buildVNode(root);
  commit(root);
  return function() {
    return destroy3(root.firstChild);
  };
}
var Component = (
  /** @class */
  (function() {
    function Component2(props) {
      this.props = props;
      this.state = {};
      this.refs = {};
    }
    Component2.prototype.setState = function(state) {
      var newState = __assign$1(__assign$1({}, this.state), state);
      if (!shallowEqual(this.state, newState)) {
        this.state = newState;
        rerender(this);
      }
    };
    return Component2;
  })()
);
var Switch = (
  /** @class */
  (function(_super) {
    __extends$1(Switch2, _super);
    function Switch2(props) {
      var _this = _super.call(this, props) || this;
      _this.state = {
        hide: false
      };
      return _this;
    }
    Switch2.prototype.show = function() {
      this.setState({ hide: false });
    };
    Switch2.prototype.hide = function() {
      this.setState({ hide: true });
    };
    Switch2.prototype.render = function() {
      var _a = this.props, editorType = _a.editorType, eventEmitter = _a.eventEmitter;
      return html(templateObject_1$h || (templateObject_1$h = __makeTemplateObject(['\n      <div class="', '" style="display: ', '">\n        <div\n          class="tab-item', '"\n          onClick=', "\n        >\n          ", '\n        </div>\n        <div\n          class="tab-item', '"\n          onClick=', "\n        >\n          ", "\n        </div>\n      </div>\n    "], [
        '\n      <div class="',
        '" style="display: ',
        '">\n        <div\n          class="tab-item',
        '"\n          onClick=',
        "\n        >\n          ",
        '\n        </div>\n        <div\n          class="tab-item',
        '"\n          onClick=',
        "\n        >\n          ",
        "\n        </div>\n      </div>\n    "
      ])), cls("mode-switch"), this.state.hide ? "none" : "block", editorType === "markdown" ? " active" : "", function() {
        eventEmitter.emit("needChangeMode", "markdown");
      }, i18n.get("Markdown"), editorType === "wysiwyg" ? " active" : "", function() {
        eventEmitter.emit("needChangeMode", "wysiwyg");
      }, i18n.get("WYSIWYG"));
    };
    return Switch2;
  })(Component)
);
var templateObject_1$h;
function debounce$1(fn, delay) {
  var timer, args;
  delay = delay || 0;
  function debounced() {
    args = Array.prototype.slice.call(arguments);
    window.clearTimeout(timer);
    timer = window.setTimeout(function() {
      fn.apply(null, args);
    }, delay);
  }
  return debounced;
}
var debounce_1 = debounce$1;
var debounce = debounce_1;
function throttle$1(fn, interval) {
  var base2;
  var isLeading = true;
  var tick = function(_args) {
    fn.apply(null, _args);
    base2 = null;
  };
  var debounced, stamp, args;
  interval = interval || 0;
  debounced = debounce(tick, interval);
  function throttled() {
    args = Array.prototype.slice.call(arguments);
    if (isLeading) {
      tick(args);
      isLeading = false;
      return;
    }
    stamp = Number(/* @__PURE__ */ new Date());
    base2 = base2 || stamp;
    debounced(args);
    if (stamp - base2 >= interval) {
      tick(args);
    }
  }
  function reset() {
    isLeading = true;
    base2 = null;
  }
  throttled.reset = reset;
  return throttled;
}
var throttle_1 = throttle$1;
var MapShim = (function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result2 = -1;
    arr.some(function(entry, index3) {
      if (entry[0] === key) {
        result2 = index3;
        return true;
      }
      return false;
    });
    return result2;
  }
  return (
    /** @class */
    (function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index3 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index3];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index3 = getIndex(this.__entries__, key);
        if (~index3) {
          this.__entries__[index3][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index3 = getIndex(entries, key);
        if (~index3) {
          entries.splice(index3, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    })()
  );
})();
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = (function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
})();
var requestAnimationFrame$1 = (function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
})();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  (function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index3 = observers2.indexOf(observer);
      if (~index3) {
        observers2.splice(index3, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  })()
);
var defineConfigurable = (function(target2, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target2, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target2;
});
var getWindowOf = (function(target2) {
  var ownerGlobal = target2 && target2.ownerDocument && target2.ownerDocument.defaultView;
  return ownerGlobal || global$1;
});
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target2) {
  var bbox = target2.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target2) {
  var clientWidth = target2.clientWidth, clientHeight = target2.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target2).getComputedStyle(target2);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target2)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = (function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target2) {
      return target2 instanceof getWindowOf(target2).SVGGraphicsElement;
    };
  }
  return function(target2) {
    return target2 instanceof getWindowOf(target2).SVGElement && typeof target2.getBBox === "function";
  };
})();
function isDocumentElement(target2) {
  return target2 === getWindowOf(target2).document.documentElement;
}
function getContentRect(target2) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target2)) {
    return getSVGContentRect(target2);
  }
  return getHTMLElementContentRect(target2);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect2 = Object.create(Constr.prototype);
  defineConfigurable(rect2, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect2;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var ResizeObservation = (
  /** @class */
  (function() {
    function ResizeObservation2(target2) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target2;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect2 = getContentRect(this.target);
      this.contentRect_ = rect2;
      return rect2.width !== this.broadcastWidth || rect2.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect2 = this.contentRect_;
      this.broadcastWidth = rect2.width;
      this.broadcastHeight = rect2.height;
      return rect2;
    };
    return ResizeObservation2;
  })()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ResizeObserverEntry2(target2, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target: target2, contentRect });
    }
    return ResizeObserverEntry2;
  })()
);
var ResizeObserverSPI = (
  /** @class */
  (function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target2) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target2 instanceof getWindowOf(target2).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target2)) {
        return;
      }
      observations.set(target2, new ResizeObservation(target2));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target2) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target2 instanceof getWindowOf(target2).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target2)) {
        return;
      }
      observations.delete(target2);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  })()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  })()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index2 = (function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
})();
var HeadingPopupBody = (
  /** @class */
  (function(_super) {
    __extends$1(HeadingPopupBody2, _super);
    function HeadingPopupBody2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HeadingPopupBody2.prototype.execCommand = function(ev) {
      var el2 = closest(ev.target, "li");
      this.props.execCommand("heading", {
        level: Number(el2.getAttribute("data-level"))
      });
    };
    HeadingPopupBody2.prototype.render = function() {
      var _this = this;
      return html(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject(["\n      <ul\n        onClick=", '\n        aria-role="menu"\n        aria-label="', '"\n      >\n        ', '\n        <li data-type="Paragraph" aria-role="menuitem">\n          <div>', "</div>\n        </li>\n      </ul>\n    "], [
        "\n      <ul\n        onClick=",
        '\n        aria-role="menu"\n        aria-label="',
        '"\n      >\n        ',
        '\n        <li data-type="Paragraph" aria-role="menuitem">\n          <div>',
        "</div>\n        </li>\n      </ul>\n    "
      ])), function(ev) {
        return _this.execCommand(ev);
      }, i18n.get("Headings"), [1, 2, 3, 4, 5, 6].map(function(level) {
        return html(templateObject_1$g || (templateObject_1$g = __makeTemplateObject(['\n              <li data-level="', '" data-type="Heading" aria-role="menuitem">\n                <', ">", " ", "</$>\n              </li>\n            "], ['\n              <li data-level="', '" data-type="Heading" aria-role="menuitem">\n                <', ">", " ", "</$>\n              </li>\n            "])), level, "h" + level, i18n.get("Heading"), level);
      }), i18n.get("Paragraph"));
    };
    return HeadingPopupBody2;
  })(Component)
);
var templateObject_1$g;
var templateObject_2$8;
var Tabs = (
  /** @class */
  (function(_super) {
    __extends$1(Tabs2, _super);
    function Tabs2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Tabs2.prototype.toggleTab = function(ev, activeTab) {
      this.props.onClick(ev, activeTab);
    };
    Tabs2.prototype.render = function() {
      var _this = this;
      return html(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject(['\n      <div class="', '" aria-role="tabpanel">\n        ', "\n      </div>\n    "], [
        '\n      <div class="',
        '" aria-role="tabpanel">\n        ',
        "\n      </div>\n    "
      ])), cls("tabs"), this.props.tabs.map(function(_a) {
        var name = _a.name, text3 = _a.text;
        var isActive = _this.props.activeTab === name;
        return html(templateObject_1$f || (templateObject_1$f = __makeTemplateObject(['\n            <div\n              class="tab-item', '"\n              onClick=', '\n              aria-role="tab"\n              aria-label="', '"\n              aria-selected="', '"\n              tabindex="', '"\n            >\n              ', "\n            </div>\n          "], ['\n            <div\n              class="tab-item', '"\n              onClick=', '\n              aria-role="tab"\n              aria-label="', '"\n              aria-selected="', '"\n              tabindex="', '"\n            >\n              ', "\n            </div>\n          "])), isActive ? " active" : "", function(ev) {
          return _this.toggleTab(ev, name);
        }, i18n.get(text3), isActive ? "true" : "false", isActive ? "0" : "-1", i18n.get(text3));
      }));
    };
    return Tabs2;
  })(Component)
);
var templateObject_1$f;
var templateObject_2$7;
var TYPE_UI = "ui";
var ImagePopupBody = (
  /** @class */
  (function(_super) {
    __extends$1(ImagePopupBody2, _super);
    function ImagePopupBody2(props) {
      var _this = _super.call(this, props) || this;
      _this.initialize = function(activeTab) {
        if (activeTab === void 0) {
          activeTab = "file";
        }
        var urlEl = _this.refs.url;
        urlEl.value = "";
        _this.refs.altText.value = "";
        _this.refs.file.value = "";
        removeClass_1(urlEl, "wrong");
        _this.setState({ activeTab, file: null, fileNameElClassName: "" });
      };
      _this.execCommand = function() {
        if (_this.state.activeTab === "file") {
          _this.emitAddImageBlob();
        } else {
          _this.emitAddImage();
        }
      };
      _this.toggleTab = function(_, activeTab) {
        if (activeTab !== _this.state.activeTab) {
          _this.initialize(activeTab);
        }
      };
      _this.showFileSelectBox = function() {
        _this.refs.file.click();
      };
      _this.changeFile = function(ev) {
        var files = ev.target.files;
        if (files === null || files === void 0 ? void 0 : files.length) {
          _this.setState({ file: files[0] });
        }
      };
      _this.state = { activeTab: "file", file: null, fileNameElClassName: "" };
      _this.tabs = [
        { name: "file", text: "File" },
        { name: "url", text: "URL" }
      ];
      return _this;
    }
    ImagePopupBody2.prototype.emitAddImageBlob = function() {
      var _this = this;
      var files = this.refs.file.files;
      var altTextEl = this.refs.altText;
      var fileNameElClassName = " wrong";
      if (files === null || files === void 0 ? void 0 : files.length) {
        fileNameElClassName = "";
        var imageFile = files.item(0);
        var hookCallback = function(url, text3) {
          return _this.props.execCommand("addImage", { imageUrl: url, altText: text3 || altTextEl.value });
        };
        this.props.eventEmitter.emit("addImageBlobHook", imageFile, hookCallback, TYPE_UI);
      }
      this.setState({ fileNameElClassName });
    };
    ImagePopupBody2.prototype.emitAddImage = function() {
      var imageUrlEl = this.refs.url;
      var altTextEl = this.refs.altText;
      var imageUrl = imageUrlEl.value;
      var altText = altTextEl.value || "image";
      removeClass_1(imageUrlEl, "wrong");
      if (!imageUrl.length) {
        addClass_1(imageUrlEl, "wrong");
        return;
      }
      if (imageUrl) {
        this.props.execCommand("addImage", { imageUrl, altText });
      }
    };
    ImagePopupBody2.prototype.preventSelectStart = function(ev) {
      ev.preventDefault();
    };
    ImagePopupBody2.prototype.updated = function() {
      if (!this.props.show) {
        this.initialize();
      }
    };
    ImagePopupBody2.prototype.render = function() {
      var _this = this;
      var _a = this.state, activeTab = _a.activeTab, file = _a.file, fileNameElClassName = _a.fileNameElClassName;
      return html(templateObject_1$e || (templateObject_1$e = __makeTemplateObject(['\n      <div aria-label="', '">\n        <', " tabs=", " activeTab=", " onClick=", ' />\n        <div style="display:', '">\n          <label for="toastuiImageUrlInput">', '</label>\n          <input\n            id="toastuiImageUrlInput"\n            type="text"\n            ref=', '\n          />\n        </div>\n        <div style="display:', ';position: relative;">\n          <label for="toastuiImageFileInput">', '</label>\n          <span\n            class="', "", '"\n            onClick=', "\n            onSelectstart=", "\n          >\n            ", '\n          </span>\n          <button\n            type="button"\n            class="', '"\n            onClick=', "\n          >\n            ", '\n          </button>\n          <input\n            id="toastuiImageFileInput"\n            type="file"\n            accept="image/*"\n            onChange=', "\n            ref=", '\n          />\n        </div>\n        <label for="toastuiAltTextInput">', '</label>\n        <input\n          id="toastuiAltTextInput"\n          type="text"\n          ref=', '\n        />\n        <div class="', '">\n          <button type="button" class="', '" onClick=', ">\n            ", '\n          </button>\n          <button type="button" class="', '" onClick=', ">\n            ", "\n          </button>\n        </div>\n      </div>\n    "], ['\n      <div aria-label="', '">\n        <', " tabs=", " activeTab=", " onClick=", ' />\n        <div style="display:', '">\n          <label for="toastuiImageUrlInput">', '</label>\n          <input\n            id="toastuiImageUrlInput"\n            type="text"\n            ref=', '\n          />\n        </div>\n        <div style="display:', ';position: relative;">\n          <label for="toastuiImageFileInput">', '</label>\n          <span\n            class="', "", '"\n            onClick=', "\n            onSelectstart=", "\n          >\n            ", '\n          </span>\n          <button\n            type="button"\n            class="', '"\n            onClick=', "\n          >\n            ", '\n          </button>\n          <input\n            id="toastuiImageFileInput"\n            type="file"\n            accept="image/*"\n            onChange=', "\n            ref=", '\n          />\n        </div>\n        <label for="toastuiAltTextInput">', '</label>\n        <input\n          id="toastuiAltTextInput"\n          type="text"\n          ref=', '\n        />\n        <div class="', '">\n          <button type="button" class="', '" onClick=', ">\n            ", '\n          </button>\n          <button type="button" class="', '" onClick=', ">\n            ", "\n          </button>\n        </div>\n      </div>\n    "])), i18n.get("Insert image"), Tabs, this.tabs, activeTab, this.toggleTab, activeTab === "url" ? "block" : "none", i18n.get("Image URL"), function(el2) {
        return _this.refs.url = el2;
      }, activeTab === "file" ? "block" : "none", i18n.get("Select image file"), cls("file-name"), file ? " has-file" : fileNameElClassName, this.showFileSelectBox, this.preventSelectStart, file ? file.name : i18n.get("No file"), cls("file-select-button"), this.showFileSelectBox, i18n.get("Choose a file"), this.changeFile, function(el2) {
        return _this.refs.file = el2;
      }, i18n.get("Description"), function(el2) {
        return _this.refs.altText = el2;
      }, cls("button-container"), cls("close-button"), this.props.hidePopup, i18n.get("Cancel"), cls("ok-button"), this.execCommand, i18n.get("OK"));
    };
    return ImagePopupBody2;
  })(Component)
);
var templateObject_1$e;
var LinkPopupBody = (
  /** @class */
  (function(_super) {
    __extends$1(LinkPopupBody2, _super);
    function LinkPopupBody2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.execCommand = function() {
        var linkUrlEl = _this.refs.url;
        var linkTextEl = _this.refs.text;
        removeClass_1(linkUrlEl, "wrong");
        removeClass_1(linkTextEl, "wrong");
        if (linkUrlEl.value.length < 1) {
          addClass_1(linkUrlEl, "wrong");
          return;
        }
        var checkLinkText = isUndefined_1(_this.props.initialValues.linkUrl);
        if (checkLinkText && linkTextEl.value.length < 1) {
          addClass_1(linkTextEl, "wrong");
          return;
        }
        _this.props.execCommand("addLink", {
          linkUrl: linkUrlEl.value,
          linkText: linkTextEl.value
        });
      };
      return _this;
    }
    LinkPopupBody2.prototype.initialize = function() {
      var _a = this.props.initialValues, linkUrl = _a.linkUrl, linkText = _a.linkText;
      var linkUrlEl = this.refs.url;
      var linkTextEl = this.refs.text;
      removeClass_1(linkUrlEl, "wrong");
      removeClass_1(linkTextEl, "wrong", "disabled");
      linkTextEl.removeAttribute("disabled");
      if (linkUrl) {
        addClass_1(linkTextEl, "disabled");
        linkTextEl.setAttribute("disabled", "disabled");
      }
      linkUrlEl.value = linkUrl || "";
      linkTextEl.value = linkText || "";
    };
    LinkPopupBody2.prototype.mounted = function() {
      this.initialize();
    };
    LinkPopupBody2.prototype.updated = function(prevProps) {
      if (!prevProps.show && this.props.show) {
        this.initialize();
      }
    };
    LinkPopupBody2.prototype.render = function() {
      var _this = this;
      return html(templateObject_1$d || (templateObject_1$d = __makeTemplateObject(['\n      <div aria-label="', '">\n        <label for="toastuiLinkUrlInput">', '</label>\n        <input\n          id="toastuiLinkUrlInput"\n          type="text"\n          ref=', '\n        />\n        <label for="toastuiLinkTextInput">', '</label>\n        <input\n          id="toastuiLinkTextInput"\n          type="text"\n          ref=', '\n        />\n        <div class="', '">\n          <button type="button" class="', '" onClick=', ">\n            ", '\n          </button>\n          <button type="button" class="', '" onClick=', ">\n            ", "\n          </button>\n        </div>\n      </div>\n    "], ['\n      <div aria-label="', '">\n        <label for="toastuiLinkUrlInput">', '</label>\n        <input\n          id="toastuiLinkUrlInput"\n          type="text"\n          ref=', '\n        />\n        <label for="toastuiLinkTextInput">', '</label>\n        <input\n          id="toastuiLinkTextInput"\n          type="text"\n          ref=', '\n        />\n        <div class="', '">\n          <button type="button" class="', '" onClick=', ">\n            ", '\n          </button>\n          <button type="button" class="', '" onClick=', ">\n            ", "\n          </button>\n        </div>\n      </div>\n    "])), i18n.get("Insert link"), i18n.get("URL"), function(el2) {
        return _this.refs.url = el2;
      }, i18n.get("Link text"), function(el2) {
        return _this.refs.text = el2;
      }, cls("button-container"), cls("close-button"), this.props.hidePopup, i18n.get("Cancel"), cls("ok-button"), this.execCommand, i18n.get("OK"));
    };
    return LinkPopupBody2;
  })(Component)
);
var templateObject_1$d;
var CELL_WIDTH = 20;
var CELL_HEIGHT = 20;
var MIN_ROW_INDEX = 5;
var MAX_ROW_INDEX = 14;
var MIN_COL_INDEX = 5;
var MAX_COL_INDEX = 9;
var MIN_ROW_SELECTION_INDEX = 1;
var MIN_COL_SELECTION_INDEX = 1;
var BORDER_WIDTH = 1;
var TablePopupBody = (
  /** @class */
  (function(_super) {
    __extends$1(TablePopupBody2, _super);
    function TablePopupBody2(props) {
      var _this = _super.call(this, props) || this;
      _this.extendSelectionRange = function(_a) {
        var pageX = _a.pageX, pageY = _a.pageY;
        var x = pageX - _this.offsetRect.left;
        var y = pageY - _this.offsetRect.top;
        var range2 = _this.getSelectionRangeByOffset(x, y);
        _this.setState(__assign$1({}, range2));
      };
      _this.execCommand = function() {
        _this.props.execCommand("addTable", {
          rowCount: _this.state.rowIdx + 1,
          columnCount: _this.state.colIdx + 1
        });
      };
      _this.state = {
        rowIdx: -1,
        colIdx: -1
      };
      return _this;
    }
    TablePopupBody2.prototype.getDescription = function() {
      return this.state.colIdx === -1 ? "" : this.state.colIdx + 1 + " x " + (this.state.rowIdx + 1);
    };
    TablePopupBody2.prototype.getBoundByRange = function(colIdx, rowIdx) {
      return {
        width: (colIdx + 1) * CELL_WIDTH,
        height: (rowIdx + 1) * CELL_HEIGHT
      };
    };
    TablePopupBody2.prototype.getRangeByOffset = function(x, y) {
      return {
        colIdx: Math.floor(x / CELL_WIDTH),
        rowIdx: Math.floor(y / CELL_HEIGHT)
      };
    };
    TablePopupBody2.prototype.getTableRange = function() {
      var _a = this.state, orgColIdx = _a.colIdx, orgRowIdx = _a.rowIdx;
      var colIdx = Math.max(orgColIdx, MIN_COL_INDEX);
      var rowIdx = Math.max(orgRowIdx, MIN_ROW_INDEX);
      if (orgColIdx >= MIN_COL_INDEX && colIdx < MAX_COL_INDEX) {
        colIdx += 1;
      }
      if (orgRowIdx >= MIN_ROW_INDEX && rowIdx < MAX_ROW_INDEX) {
        rowIdx += 1;
      }
      return { colIdx: colIdx + 1, rowIdx: rowIdx + 1 };
    };
    TablePopupBody2.prototype.getSelectionAreaBound = function() {
      var _a = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), width = _a.width, height = _a.height;
      if (!width && !height) {
        return { display: "none" };
      }
      return { width: width - BORDER_WIDTH, height: height - BORDER_WIDTH, display: "block" };
    };
    TablePopupBody2.prototype.getSelectionRangeByOffset = function(x, y) {
      var range2 = this.getRangeByOffset(x, y);
      range2.rowIdx = Math.min(Math.max(range2.rowIdx, MIN_ROW_SELECTION_INDEX), MAX_ROW_INDEX);
      range2.colIdx = Math.min(Math.max(range2.colIdx, MIN_COL_SELECTION_INDEX), MAX_COL_INDEX);
      return range2;
    };
    TablePopupBody2.prototype.updated = function() {
      if (!this.props.show) {
        this.setState({ colIdx: -1, rowIdx: -1 });
      } else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {
        var _a = this.refs.tableEl.getBoundingClientRect(), left = _a.left, top_1 = _a.top;
        this.offsetRect = {
          left: window.pageXOffset + left,
          top: window.pageYOffset + top_1
        };
      }
    };
    TablePopupBody2.prototype.createTableArea = function(tableRange) {
      var colIdx = tableRange.colIdx, rowIdx = tableRange.rowIdx;
      var rows = [];
      for (var i = 0; i < rowIdx; i += 1) {
        var cells = [];
        for (var j = 0; j < colIdx; j += 1) {
          var cellClassNames = "" + cls("table-cell") + (i > 0 ? "" : " header");
          cells.push(html(templateObject_1$c || (templateObject_1$c = __makeTemplateObject(['<div class="', '"></div>'], ['<div class="', '"></div>'])), cellClassNames));
        }
        rows.push(html(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), cls("table-row"), cells));
      }
      return html(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), cls("table"), rows);
    };
    TablePopupBody2.prototype.render = function() {
      var _this = this;
      var tableRange = this.getTableRange();
      var selectionAreaBound = this.getSelectionAreaBound();
      return html(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject(['\n      <div aria-label="', '">\n        <div\n          class="', '"\n          ref=', "\n          onMousemove=", "\n          onClick=", "\n        >\n          ", '\n          <div class="', '" style=', '></div>\n        </div>\n        <p class="', '">', "</p>\n      </div>\n    "], ['\n      <div aria-label="', '">\n        <div\n          class="', '"\n          ref=', "\n          onMousemove=", "\n          onClick=", "\n        >\n          ", '\n          <div class="', '" style=', '></div>\n        </div>\n        <p class="', '">', "</p>\n      </div>\n    "])), i18n.get("Insert table"), cls("table-selection"), function(el2) {
        return _this.refs.tableEl = el2;
      }, this.extendSelectionRange, this.execCommand, this.createTableArea(tableRange), cls("table-selection-layer"), selectionAreaBound, cls("table-description"), this.getDescription());
    };
    return TablePopupBody2;
  })(Component)
);
var templateObject_1$c;
var templateObject_2$6;
var templateObject_3$2;
var templateObject_4$1;
var CustomPopupBody = (
  /** @class */
  (function(_super) {
    __extends$1(CustomPopupBody2, _super);
    function CustomPopupBody2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CustomPopupBody2.prototype.mounted = function() {
      this.refs.el.appendChild(this.props.body);
    };
    CustomPopupBody2.prototype.updated = function(prevProps) {
      this.refs.el.replaceChild(this.props.body, prevProps.body);
    };
    CustomPopupBody2.prototype.render = function() {
      var _this = this;
      return html(templateObject_1$b || (templateObject_1$b = __makeTemplateObject(["<div ref=", "></div>"], ["<div ref=", "></div>"])), function(el2) {
        return _this.refs.el = el2;
      });
    };
    return CustomPopupBody2;
  })(Component)
);
var templateObject_1$b;
function createToolbarItemInfo(type) {
  return isString_1(type) ? createDefaultToolbarItemInfo(type) : type;
}
function createScrollSyncToolbarItem() {
  var label = document.createElement("label");
  var checkbox = document.createElement("input");
  var toggleSwitch = document.createElement("span");
  label.className = "scroll-sync active";
  checkbox.type = "checkbox";
  checkbox.checked = true;
  toggleSwitch.className = "switch";
  var onMounted = function(execCommand2) {
    return checkbox.addEventListener("change", function(ev) {
      var checked = ev.target.checked;
      if (checked) {
        addClass_1(label, "active");
      } else {
        removeClass_1(label, "active");
      }
      execCommand2("toggleScrollSync", { active: checked });
    });
  };
  label.appendChild(checkbox);
  label.appendChild(toggleSwitch);
  return {
    name: "scrollSync",
    el: label,
    onMounted
  };
}
function createDefaultToolbarItemInfo(type) {
  var info;
  switch (type) {
    case "heading":
      info = {
        name: "heading",
        className: "heading",
        tooltip: i18n.get("Headings"),
        state: "heading"
      };
      break;
    case "bold":
      info = {
        name: "bold",
        className: "bold",
        command: "bold",
        tooltip: i18n.get("Bold"),
        state: "strong"
      };
      break;
    case "italic":
      info = {
        name: "italic",
        className: "italic",
        command: "italic",
        tooltip: i18n.get("Italic"),
        state: "emph"
      };
      break;
    case "strike":
      info = {
        name: "strike",
        className: "strike",
        command: "strike",
        tooltip: i18n.get("Strike"),
        state: "strike"
      };
      break;
    case "hr":
      info = {
        name: "hr",
        className: "hrline",
        command: "hr",
        tooltip: i18n.get("Line"),
        state: "thematicBreak"
      };
      break;
    case "quote":
      info = {
        name: "quote",
        className: "quote",
        command: "blockQuote",
        tooltip: i18n.get("Blockquote"),
        state: "blockQuote"
      };
      break;
    case "ul":
      info = {
        name: "ul",
        className: "bullet-list",
        command: "bulletList",
        tooltip: i18n.get("Unordered list"),
        state: "bulletList"
      };
      break;
    case "ol":
      info = {
        name: "ol",
        className: "ordered-list",
        command: "orderedList",
        tooltip: i18n.get("Ordered list"),
        state: "orderedList"
      };
      break;
    case "task":
      info = {
        name: "task",
        className: "task-list",
        command: "taskList",
        tooltip: i18n.get("Task"),
        state: "taskList"
      };
      break;
    case "table":
      info = {
        name: "table",
        className: "table",
        tooltip: i18n.get("Insert table"),
        state: "table"
      };
      break;
    case "image":
      info = {
        name: "image",
        className: "image",
        tooltip: i18n.get("Insert image")
      };
      break;
    case "link":
      info = {
        name: "link",
        className: "link",
        tooltip: i18n.get("Insert link")
      };
      break;
    case "code":
      info = {
        name: "code",
        className: "code",
        command: "code",
        tooltip: i18n.get("Code"),
        state: "code"
      };
      break;
    case "codeblock":
      info = {
        name: "codeblock",
        className: "codeblock",
        command: "codeBlock",
        tooltip: i18n.get("Insert CodeBlock"),
        state: "codeBlock"
      };
      break;
    case "indent":
      info = {
        name: "indent",
        className: "indent",
        command: "indent",
        tooltip: i18n.get("Indent"),
        state: "indent"
      };
      break;
    case "outdent":
      info = {
        name: "outdent",
        className: "outdent",
        command: "outdent",
        tooltip: i18n.get("Outdent"),
        state: "outdent"
      };
      break;
    case "scrollSync":
      info = createScrollSyncToolbarItem();
      break;
    case "more":
      info = {
        name: "more",
        className: "more",
        tooltip: i18n.get("More")
      };
      break;
  }
  if (info.name !== "scrollSync") {
    info.className += " " + cls("toolbar-icons");
  }
  return info;
}
function createPopupInfo(type, payload) {
  var el2 = payload.el, pos = payload.pos, popup = payload.popup, initialValues = payload.initialValues;
  switch (type) {
    case "heading":
      return {
        render: function(props) {
          return html(templateObject_1$a || (templateObject_1$a = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), HeadingPopupBody, props);
        },
        className: cls("popup-add-heading"),
        fromEl: el2,
        pos
      };
    case "link":
      return {
        render: function(props) {
          return html(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), LinkPopupBody, props);
        },
        className: cls("popup-add-link"),
        fromEl: el2,
        pos,
        initialValues
      };
    case "image":
      return {
        render: function(props) {
          return html(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), ImagePopupBody, props);
        },
        className: cls("popup-add-image"),
        fromEl: el2,
        pos
      };
    case "table":
      return {
        render: function(props) {
          return html(templateObject_4 || (templateObject_4 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), TablePopupBody, props);
        },
        className: cls("popup-add-table"),
        fromEl: el2,
        pos
      };
    case "customPopupBody":
      if (!popup) {
        return null;
      }
      return __assign$1({ render: function(props) {
        return html(templateObject_5 || (templateObject_5 = __makeTemplateObject(["<", " ...", " body=", " />"], ["<", " ...", " body=", " />"])), CustomPopupBody, props, popup.body);
      }, fromEl: el2, pos }, popup);
    default:
      return null;
  }
}
function setGroupState(group) {
  group.hidden = group.length === group.filter(function(info) {
    return info.hidden;
  }).length;
}
function groupToolbarItems(toolbarItems, hiddenScrollSync) {
  var toggleScrollSyncState = function(item2) {
    item2.hidden = item2.name === "scrollSync" && hiddenScrollSync;
    return item2;
  };
  return toolbarItems.reduce(function(acc, item2) {
    acc.push(item2.map(function(type) {
      return toggleScrollSyncState(createToolbarItemInfo(type));
    }));
    var group = acc[(acc.length || 1) - 1];
    if (group) {
      setGroupState(group);
    }
    return acc;
  }, []);
}
function toggleScrollSync(toolbarItems, hiddenScrollSync) {
  toolbarItems.forEach(function(group) {
    group.forEach(function(item2) {
      return item2.hidden = item2.name === "scrollSync" && hiddenScrollSync;
    });
    setGroupState(group);
  });
}
var templateObject_1$a;
var templateObject_2$5;
var templateObject_3$1;
var templateObject_4;
var templateObject_5;
var MARGIN_FROM_RIGHT_SIDE = 20;
var Popup = (
  /** @class */
  (function(_super) {
    __extends$1(Popup2, _super);
    function Popup2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.handleMousedown = function(ev) {
        if (!closest(ev.target, "." + cls("popup")) && !closest(ev.target, _this.props.info.fromEl)) {
          _this.props.hidePopup();
        }
      };
      return _this;
    }
    Popup2.prototype.mounted = function() {
      document.addEventListener("mousedown", this.handleMousedown);
      this.props.eventEmitter.listen("closePopup", this.props.hidePopup);
    };
    Popup2.prototype.beforeDestroy = function() {
      document.removeEventListener("mousedown", this.handleMousedown);
    };
    Popup2.prototype.updated = function(prevProps) {
      var _a = this.props, show = _a.show, info = _a.info;
      if (show && info.pos && prevProps.show !== show) {
        var popupPos = __assign$1({}, info.pos);
        var offsetWidth = this.refs.el.offsetWidth;
        var toolbarEl = closest(this.refs.el, "." + cls("toolbar"));
        var toolbarOffsetWidth = toolbarEl.offsetWidth;
        if (popupPos.left + offsetWidth >= toolbarOffsetWidth) {
          popupPos.left = toolbarOffsetWidth - offsetWidth - MARGIN_FROM_RIGHT_SIDE;
        }
        if (!shallowEqual(this.state.popupPos, popupPos)) {
          this.setState({ popupPos });
        }
      }
    };
    Popup2.prototype.render = function() {
      var _this = this;
      var _a = this.props, info = _a.info, show = _a.show, hidePopup = _a.hidePopup, eventEmitter = _a.eventEmitter, execCommand2 = _a.execCommand;
      var _b = info || {}, _c = _b.className, className = _c === void 0 ? "" : _c, style = _b.style, render2 = _b.render, _d = _b.initialValues, initialValues = _d === void 0 ? {} : _d;
      var popupStyle = __assign$1(__assign$1({ display: show ? "block" : "none" }, style), this.state.popupPos);
      return html(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject(['\n      <div\n        class="', " ", '"\n        style=', "\n        ref=", '\n        aria-role="dialog"\n      >\n        <div class="', '">\n          ', "\n        </div>\n      </div>\n    "], ['\n      <div\n        class="', " ", '"\n        style=', "\n        ref=", '\n        aria-role="dialog"\n      >\n        <div class="', '">\n          ', "\n        </div>\n      </div>\n    "])), cls("popup"), className, popupStyle, function(el2) {
        return _this.refs.el = el2;
      }, cls("popup-body"), render2 && render2({ eventEmitter, show, hidePopup, execCommand: execCommand2, initialValues }));
    };
    return Popup2;
  })(Component)
);
var templateObject_1$9;
var TOOLTIP_INDENT = 6;
function connectHOC(WrappedComponent) {
  return (
    /** @class */
    (function(_super) {
      __extends$1(ButtonHOC, _super);
      function ButtonHOC(props) {
        var _this = _super.call(this, props) || this;
        _this.showTooltip = function(el2) {
          var tooltip = _this.props.item.tooltip;
          if (!_this.props.disabled && tooltip) {
            var bound = _this.getBound(el2);
            var left = bound.left + TOOLTIP_INDENT + "px";
            var top_1 = bound.top + TOOLTIP_INDENT + "px";
            css_1(_this.props.tooltipRef.current, { display: "block", left, top: top_1 });
            _this.props.tooltipRef.current.querySelector(".text").textContent = tooltip;
          }
        };
        _this.hideTooltip = function() {
          css_1(_this.props.tooltipRef.current, "display", "none");
        };
        _this.state = { active: false, disabled: props.disabled };
        _this.addEvent();
        return _this;
      }
      ButtonHOC.prototype.addEvent = function() {
        var _this = this;
        var _a = this.props, item2 = _a.item, eventEmitter = _a.eventEmitter;
        if (item2.state) {
          eventEmitter.listen("changeToolbarState", function(_a2) {
            var _b;
            var toolbarState = _a2.toolbarState;
            var _c = (_b = toolbarState[item2.state]) !== null && _b !== void 0 ? _b : {}, active = _c.active, disabled = _c.disabled;
            _this.setState({ active: !!active, disabled: disabled !== null && disabled !== void 0 ? disabled : _this.props.disabled });
          });
        }
      };
      ButtonHOC.prototype.getBound = function(el2) {
        var _a = getTotalOffset(el2, closest(el2, "." + cls("toolbar"))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;
        return { left: offsetLeft, top: el2.offsetHeight + offsetTop };
      };
      ButtonHOC.prototype.render = function() {
        return html(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject(["\n        <", "\n          ...", "\n          active=", "\n          showTooltip=", "\n          hideTooltip=", "\n          getBound=", "\n          disabled=", "\n        />\n      "], ["\n        <", "\n          ...", "\n          active=", "\n          showTooltip=", "\n          hideTooltip=", "\n          getBound=", "\n          disabled=", "\n        />\n      "])), WrappedComponent, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);
      };
      return ButtonHOC;
    })(Component)
  );
}
var templateObject_1$8;
var DEFAULT_WIDTH = 80;
var ToolbarButtonComp = (
  /** @class */
  (function(_super) {
    __extends$1(ToolbarButtonComp2, _super);
    function ToolbarButtonComp2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.showTooltip = function() {
        _this.props.showTooltip(_this.refs.el);
      };
      _this.execCommand = function() {
        var _a = _this.props, item2 = _a.item, execCommand2 = _a.execCommand, setPopupInfo = _a.setPopupInfo, getBound = _a.getBound, eventEmitter = _a.eventEmitter;
        var command = item2.command, name = item2.name, popup = item2.popup;
        if (command) {
          execCommand2(command);
        } else {
          var popupName = popup ? "customPopupBody" : name;
          var initialValues = eventEmitter.emit("query", "getPopupInitialValues", { popupName })[0];
          var info = createPopupInfo(popupName, {
            el: _this.refs.el,
            pos: getBound(_this.refs.el),
            popup,
            initialValues
          });
          if (info) {
            setPopupInfo(info);
          }
        }
      };
      return _this;
    }
    ToolbarButtonComp2.prototype.mounted = function() {
      this.setItemWidth();
    };
    ToolbarButtonComp2.prototype.updated = function(prevProps) {
      if (prevProps.item.name !== this.props.item.name) {
        this.setItemWidth();
      }
    };
    ToolbarButtonComp2.prototype.setItemWidth = function() {
      var _a = this.props, setItemWidth = _a.setItemWidth, item2 = _a.item;
      if (setItemWidth) {
        setItemWidth(item2.name, getOuterWidth(this.refs.el) + (item2.hidden ? DEFAULT_WIDTH : 0));
      }
    };
    ToolbarButtonComp2.prototype.render = function() {
      var _this = this;
      var _a = this.props, hideTooltip = _a.hideTooltip, disabled = _a.disabled, item2 = _a.item, active = _a.active;
      var style = __assign$1({ display: item2.hidden ? "none" : null }, item2.style);
      var classNames = "" + (item2.className || "") + (active ? " active" : "");
      return html(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject(["\n      <button\n        ref=", '\n        type="button"\n        style=', "\n        class=", "\n        onClick=", "\n        onMouseover=", "\n        onMouseout=", "\n        disabled=", "\n        aria-label=", "\n      >\n        ", "\n      </button>\n    "], ["\n      <button\n        ref=", '\n        type="button"\n        style=', "\n        class=", "\n        onClick=", "\n        onMouseover=", "\n        onMouseout=", "\n        disabled=", "\n        aria-label=", "\n      >\n        ", "\n      </button>\n    "])), function(el2) {
        return _this.refs.el = el2;
      }, style, classNames, this.execCommand, this.showTooltip, hideTooltip, !!disabled, item2.text || item2.tooltip || "", item2.text || "");
    };
    return ToolbarButtonComp2;
  })(Component)
);
var ToolbarButton = connectHOC(ToolbarButtonComp);
var templateObject_1$7;
var CustomToolbarItemComp = (
  /** @class */
  (function(_super) {
    __extends$1(CustomToolbarItemComp2, _super);
    function CustomToolbarItemComp2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.showTooltip = function() {
        _this.props.showTooltip(_this.refs.el);
      };
      _this.showPopup = function() {
        var info = createPopupInfo("customPopupBody", {
          el: _this.refs.el,
          pos: _this.props.getBound(_this.refs.el),
          popup: _this.props.item.popup
        });
        if (info) {
          _this.props.setPopupInfo(info);
        }
      };
      return _this;
    }
    CustomToolbarItemComp2.prototype.mounted = function() {
      var _a = this.props, setItemWidth = _a.setItemWidth, item2 = _a.item;
      this.refs.el.appendChild(item2.el);
      if (setItemWidth) {
        setItemWidth(item2.name, getOuterWidth(this.refs.el));
      }
      if (item2.onMounted) {
        item2.onMounted(this.props.execCommand);
      }
    };
    CustomToolbarItemComp2.prototype.updated = function(prevProps) {
      var _a;
      var _b = this.props, item2 = _b.item, active = _b.active, disabled = _b.disabled;
      if (prevProps.active !== active || prevProps.disabled !== disabled) {
        (_a = item2.onUpdated) === null || _a === void 0 ? void 0 : _a.call(item2, { active, disabled });
      }
    };
    CustomToolbarItemComp2.prototype.render = function() {
      var _this = this;
      var _a = this.props, disabled = _a.disabled, item2 = _a.item;
      var style = { display: item2.hidden ? "none" : "inline-block" };
      var getListener = function(listener) {
        return disabled ? null : listener;
      };
      return html(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject(["\n      <div\n        ref=", "\n        style=", "\n        class=", "\n        onClick=", "\n        onMouseover=", "\n        onMouseout=", "\n      ></div>\n    "], ["\n      <div\n        ref=", "\n        style=", "\n        class=", "\n        onClick=", "\n        onMouseover=", "\n        onMouseout=", "\n      ></div>\n    "])), function(el2) {
        return _this.refs.el = el2;
      }, style, cls("toolbar-item-wrapper"), getListener(this.showPopup), getListener(this.showTooltip), getListener(this.props.hideTooltip));
    };
    return CustomToolbarItemComp2;
  })(Component)
);
var CustomToolbarItem = connectHOC(CustomToolbarItemComp);
var templateObject_1$6;
var ToolbarGroup = (
  /** @class */
  (function(_super) {
    __extends$1(ToolbarGroup2, _super);
    function ToolbarGroup2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ToolbarGroup2.prototype.render = function() {
      var _this = this;
      var _a = this.props, group = _a.group, hiddenDivider = _a.hiddenDivider;
      var groupStyle = group.hidden ? { display: "none" } : null;
      var dividerStyle = hiddenDivider ? { display: "none" } : null;
      return html(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject(['\n      <div class="', '" style=', ">\n        ", '\n        <div class="', '" style=', "></div>\n      </div>\n    "], [
        '\n      <div class="',
        '" style=',
        ">\n        ",
        '\n        <div class="',
        '" style=',
        "></div>\n      </div>\n    "
      ])), cls("toolbar-group"), groupStyle, group.map(function(item2) {
        var Comp = item2.el ? CustomToolbarItem : ToolbarButton;
        return html(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["<", " key=", " ...", " item=", " />"], ["<", " key=", " ...", " item=", " />"])), Comp, item2.name, _this.props, item2);
      }), cls("toolbar-divider"), dividerStyle);
    };
    return ToolbarGroup2;
  })(Component)
);
var templateObject_1$5;
var templateObject_2$4;
var POPUP_INDENT = 4;
var DropdownToolbarButtonComp = (
  /** @class */
  (function(_super) {
    __extends$1(DropdownToolbarButtonComp2, _super);
    function DropdownToolbarButtonComp2(props) {
      var _this = _super.call(this, props) || this;
      _this.handleClickDocument = function(_a) {
        var target2 = _a.target;
        if (!closest(target2, "." + cls("dropdown-toolbar")) && !closest(target2, ".more")) {
          _this.setState({ showDropdown: false, dropdownPos: null });
        }
      };
      _this.showTooltip = function() {
        _this.props.showTooltip(_this.refs.el);
      };
      _this.state = { showDropdown: false, dropdownPos: null };
      return _this;
    }
    DropdownToolbarButtonComp2.prototype.getBound = function() {
      var rect2 = this.props.getBound(this.refs.el);
      rect2.top += POPUP_INDENT;
      return __assign$1(__assign$1({}, rect2), { left: null, right: 10 });
    };
    DropdownToolbarButtonComp2.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    };
    DropdownToolbarButtonComp2.prototype.updated = function() {
      if (this.state.showDropdown && !this.state.dropdownPos) {
        this.setState({ dropdownPos: this.getBound() });
      }
    };
    DropdownToolbarButtonComp2.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    };
    DropdownToolbarButtonComp2.prototype.render = function() {
      var _this = this;
      var _a = this.state, showDropdown = _a.showDropdown, dropdownPos = _a.dropdownPos;
      var _b = this.props, disabled = _b.disabled, item2 = _b.item, items = _b.items, hideTooltip = _b.hideTooltip;
      var visibleItems = items.filter(function(dropdownItem) {
        return !dropdownItem.hidden;
      });
      var groupStyle = visibleItems.length ? null : { display: "none" };
      var dropdownStyle = showDropdown ? null : { display: "none" };
      return html(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject(['\n      <div class="', '" style=', ">\n        <button\n          ref=", '\n          type="button"\n          class=', "\n          onClick=", "\n          onMouseover=", "\n          onMouseout=", "\n          disabled=", '\n        ></button>\n        <div\n          class="', '"\n          style=', "\n          ref=", "\n        >\n          ", "\n        </div>\n      </div>\n    "], [
        '\n      <div class="',
        '" style=',
        ">\n        <button\n          ref=",
        '\n          type="button"\n          class=',
        "\n          onClick=",
        "\n          onMouseover=",
        "\n          onMouseout=",
        "\n          disabled=",
        '\n        ></button>\n        <div\n          class="',
        '"\n          style=',
        "\n          ref=",
        "\n        >\n          ",
        "\n        </div>\n      </div>\n    "
      ])), cls("toolbar-group"), groupStyle, function(el2) {
        return _this.refs.el = el2;
      }, item2.className, function() {
        return _this.setState({ showDropdown: true });
      }, this.showTooltip, hideTooltip, disabled, cls("dropdown-toolbar"), __assign$1(__assign$1({}, dropdownStyle), dropdownPos), function(el2) {
        return _this.refs.dropdownEl = el2;
      }, visibleItems.length ? visibleItems.map(function(group, index3) {
        var _a2;
        return html(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject(["\n                  <", "\n                    group=", "\n                    hiddenDivider=", "\n                    ...", "\n                  />\n                "], [
          "\n                  <",
          "\n                    group=",
          "\n                    hiddenDivider=",
          "\n                    ...",
          "\n                  />\n                "
        ])), ToolbarGroup, group, index3 === visibleItems.length - 1 || ((_a2 = visibleItems[index3 + 1]) === null || _a2 === void 0 ? void 0 : _a2.hidden), _this.props);
      }) : null);
    };
    return DropdownToolbarButtonComp2;
  })(Component)
);
var DropdownToolbarButton = connectHOC(DropdownToolbarButtonComp);
var templateObject_1$4;
var templateObject_2$3;
var INLINE_PADDING = 50;
var Toolbar = (
  /** @class */
  (function(_super) {
    __extends$1(Toolbar2, _super);
    function Toolbar2(props) {
      var _this = _super.call(this, props) || this;
      _this.toggleTab = function(_, activeTab) {
        var eventEmitter = _this.props.eventEmitter;
        if (_this.state.activeTab !== activeTab) {
          var event_1 = activeTab === "write" ? "changePreviewTabWrite" : "changePreviewTabPreview";
          eventEmitter.emit(event_1);
          _this.setState({ activeTab });
        }
      };
      _this.setItemWidth = function(name, width) {
        _this.itemWidthMap[name] = width;
      };
      _this.setPopupInfo = function(popupInfo) {
        _this.setState({ showPopup: true, popupInfo });
      };
      _this.openPopup = function(popupName, initialValues) {
        if (initialValues === void 0) {
          initialValues = {};
        }
        var el2 = _this.refs.el.querySelector("." + cls("toolbar-group") + " ." + popupName);
        if (el2) {
          var _a = getTotalOffset(el2, closest(el2, "." + cls("toolbar"))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;
          var info = createPopupInfo(popupName, {
            el: el2,
            pos: { left: offsetLeft, top: el2.offsetHeight + offsetTop },
            initialValues
          });
          if (info) {
            _this.setPopupInfo(info);
          }
        }
      };
      _this.hidePopup = function() {
        if (_this.state.showPopup) {
          _this.setState({ showPopup: false });
        }
      };
      _this.execCommand = function(command, payload) {
        var eventEmitter = _this.props.eventEmitter;
        eventEmitter.emit("command", command, payload);
        _this.hidePopup();
      };
      _this.tabs = [
        { name: "write", text: "Write" },
        { name: "preview", text: "Preview" }
      ];
      _this.itemWidthMap = {};
      _this.initialItems = groupToolbarItems(props.toolbarItems || [], _this.hiddenScrollSync());
      _this.state = {
        items: _this.initialItems,
        dropdownItems: [],
        showPopup: false,
        popupInfo: {},
        activeTab: "write"
      };
      _this.tooltipRef = { current: null };
      _this.resizeObserver = new index2(function() {
        return _this.handleResize();
      });
      _this.addEvent();
      return _this;
    }
    Toolbar2.prototype.insertToolbarItem = function(indexList, item2) {
      var groupIndex = indexList.groupIndex, itemIndex = indexList.itemIndex;
      var group = this.initialItems[groupIndex];
      item2 = createToolbarItemInfo(item2);
      if (group) {
        group.splice(itemIndex, 0, item2);
      } else {
        this.initialItems.push([item2]);
      }
      this.setState(this.classifyToolbarItems());
    };
    Toolbar2.prototype.removeToolbarItem = function(name) {
      var _this = this;
      forEachArray_1(this.initialItems, function(group) {
        var found2 = false;
        forEachArray_1(group, function(item2, index3) {
          if (item2.name === name) {
            found2 = true;
            group.splice(index3, 1);
            _this.setState(_this.classifyToolbarItems());
            return false;
          }
          return true;
        });
        return !found2;
      });
    };
    Toolbar2.prototype.addEvent = function() {
      var _this = this;
      var eventEmitter = this.props.eventEmitter;
      this.handleResize = throttle_1(function() {
        _this.setState({ items: _this.initialItems, dropdownItems: [] });
        _this.setState(_this.classifyToolbarItems());
      }, 200);
      eventEmitter.listen("openPopup", this.openPopup);
    };
    Toolbar2.prototype.appendTooltipToRoot = function() {
      var tooltip = '<div class="' + cls("tooltip") + '" style="display:none">\n        <div class="arrow"></div>\n        <span class="text"></span>\n      </div>';
      this.tooltipRef.current = createElementWith(tooltip, this.refs.el);
    };
    Toolbar2.prototype.hiddenScrollSync = function() {
      return this.props.editorType === "wysiwyg" || this.props.previewStyle === "tab";
    };
    Toolbar2.prototype.movePrevItemToDropdownToolbar = function(itemIndex, items, group, dropdownGroup) {
      var moveItem = function(targetGroup) {
        var item2 = targetGroup.pop();
        if (item2) {
          dropdownGroup.push(item2);
        }
      };
      if (itemIndex > 1) {
        moveItem(group);
      } else {
        var prevGroup = last$1(items);
        if (prevGroup) {
          moveItem(prevGroup);
        }
      }
    };
    Toolbar2.prototype.classifyToolbarItems = function() {
      var _this = this;
      var totalWidth = 0;
      var clientWidth = this.refs.el.clientWidth;
      var divider = this.refs.el.querySelector("." + cls("toolbar-divider"));
      var dividerWidth = divider ? getOuterWidth(divider) : 0;
      var items = [];
      var dropdownItems = [];
      var moved = false;
      this.initialItems.forEach(function(initialGroup, groupIndex) {
        var group = [];
        var dropdownGroup = [];
        initialGroup.forEach(function(item2, itemIndex) {
          if (!item2.hidden) {
            totalWidth += _this.itemWidthMap[item2.name];
            if (totalWidth > clientWidth - INLINE_PADDING) {
              if (!moved) {
                _this.movePrevItemToDropdownToolbar(itemIndex, items, group, dropdownGroup);
                moved = true;
              }
              dropdownGroup.push(item2);
            } else {
              group.push(item2);
            }
          }
        });
        if (group.length) {
          setGroupState(group);
          items.push(group);
        }
        if (dropdownGroup.length) {
          setGroupState(dropdownGroup);
          dropdownItems.push(dropdownGroup);
        }
        if (groupIndex < _this.state.items.length - 1) {
          totalWidth += dividerWidth;
        }
      });
      return { items, dropdownItems };
    };
    Toolbar2.prototype.mounted = function() {
      if (this.props.previewStyle === "tab") {
        this.props.eventEmitter.emit("changePreviewTabWrite", true);
      }
      this.setState(this.classifyToolbarItems());
      this.appendTooltipToRoot();
      this.resizeObserver.observe(this.refs.el);
    };
    Toolbar2.prototype.updated = function(prevProps) {
      var _a = this.props, editorType = _a.editorType, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter;
      var changedStyle = previewStyle !== prevProps.previewStyle;
      var changedType = editorType !== prevProps.editorType;
      if (changedStyle || changedType) {
        toggleScrollSync(this.initialItems, this.hiddenScrollSync());
        var newState = this.classifyToolbarItems();
        if (changedStyle || previewStyle === "tab" && editorType === "markdown") {
          eventEmitter.emit("changePreviewTabWrite");
          newState.activeTab = "write";
        }
        this.setState(newState);
      }
    };
    Toolbar2.prototype.beforeDestroy = function() {
      window.removeEventListener("resize", this.handleResize);
      this.resizeObserver.disconnect();
      removeNode$1(this.tooltipRef.current);
    };
    Toolbar2.prototype.render = function() {
      var _this = this;
      var _a = this.props, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter, editorType = _a.editorType;
      var _b = this.state, popupInfo = _b.popupInfo, showPopup = _b.showPopup, activeTab = _b.activeTab, items = _b.items, dropdownItems = _b.dropdownItems;
      var props = {
        eventEmitter,
        tooltipRef: this.tooltipRef,
        disabled: editorType === "markdown" && previewStyle === "tab" && activeTab === "preview",
        execCommand: this.execCommand,
        setPopupInfo: this.setPopupInfo
      };
      var toolbarStyle = previewStyle === "tab" ? { borderTopLeftRadius: 0 } : null;
      return html(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject(['\n      <div class="', '">\n        <div\n          class="', '"\n          style="display: ', '"\n        >\n          <', " tabs=", " activeTab=", " onClick=", ' />\n        </div>\n        <div\n          class="', '"\n          ref=', "\n          style=", "\n        >\n          ", "\n          <", "\n            item=", "\n            items=", "\n            ...", "\n          />\n        </div>\n        <", "\n          info=", "\n          show=", "\n          eventEmitter=", "\n          hidePopup=", "\n          execCommand=", "\n        />\n      </div>\n    "], [
        '\n      <div class="',
        '">\n        <div\n          class="',
        '"\n          style="display: ',
        '"\n        >\n          <',
        " tabs=",
        " activeTab=",
        " onClick=",
        ' />\n        </div>\n        <div\n          class="',
        '"\n          ref=',
        "\n          style=",
        "\n        >\n          ",
        "\n          <",
        "\n            item=",
        "\n            items=",
        "\n            ...",
        "\n          />\n        </div>\n        <",
        "\n          info=",
        "\n          show=",
        "\n          eventEmitter=",
        "\n          hidePopup=",
        "\n          execCommand=",
        "\n        />\n      </div>\n    "
      ])), cls("toolbar"), cls("md-tab-container"), editorType === "wysiwyg" || previewStyle === "vertical" ? "none" : "block", Tabs, this.tabs, activeTab, this.toggleTab, cls("defaultUI-toolbar"), function(el2) {
        return _this.refs.el = el2;
      }, toolbarStyle, items.map(function(group, index3) {
        var _a2;
        return html(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject(["\n              <", "\n                group=", "\n                hiddenDivider=", "\n                setItemWidth=", "\n                ...", "\n              />\n            "], ["\n              <", "\n                group=", "\n                hiddenDivider=", "\n                setItemWidth=", "\n                ...", "\n              />\n            "])), ToolbarGroup, group, index3 === items.length - 1 || ((_a2 = items[index3 + 1]) === null || _a2 === void 0 ? void 0 : _a2.hidden), _this.setItemWidth, props);
      }), DropdownToolbarButton, createToolbarItemInfo("more"), dropdownItems, props, Popup, popupInfo, showPopup, eventEmitter, this.hidePopup, this.execCommand);
    };
    return Toolbar2;
  })(Component)
);
var templateObject_1$3;
var templateObject_2$2;
var ContextMenu = (
  /** @class */
  (function(_super) {
    __extends$1(ContextMenu2, _super);
    function ContextMenu2(props) {
      var _this = _super.call(this, props) || this;
      _this.handleClickDocument = function(ev) {
        if (!closest(ev.target, "." + cls("context-menu"))) {
          _this.setState({ pos: null });
        }
      };
      _this.state = {
        pos: null,
        menuGroups: []
      };
      _this.addEvent();
      return _this;
    }
    ContextMenu2.prototype.addEvent = function() {
      var _this = this;
      this.props.eventEmitter.listen("contextmenu", function(_a) {
        var pos = _a.pos, menuGroups = _a.menuGroups;
        _this.setState({ pos, menuGroups });
      });
    };
    ContextMenu2.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    };
    ContextMenu2.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    };
    ContextMenu2.prototype.getMenuGroupElements = function() {
      var _this = this;
      var _a = this.state, pos = _a.pos, menuGroups = _a.menuGroups;
      return pos ? menuGroups.reduce(function(acc, group) {
        var menuItem = [];
        group.forEach(function(_a2) {
          var label = _a2.label, _b = _a2.className, className = _b === void 0 ? false : _b, disabled = _a2.disabled, onClick = _a2.onClick;
          var handleClick = function() {
            if (!disabled) {
              onClick();
              _this.setState({ pos: null });
            }
          };
          menuItem.push(html(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject(["\n                <li\n                  onClick=", '\n                  class="menu-item', '"\n                  aria-role="menuitem"\n                >\n                  <span class="', '">', "</span>\n                </li>\n              "], ["\n                <li\n                  onClick=", '\n                  class="menu-item', '"\n                  aria-role="menuitem"\n                >\n                  <span class="', '">', "</span>\n                </li>\n              "])), handleClick, disabled ? " disabled" : "", className, label));
        });
        acc.push(html(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject(['<ul class="menu-group">\n              ', "\n            </ul>"], ['<ul class="menu-group">\n              ', "\n            </ul>"])), menuItem));
        return acc;
      }, []) : [];
    };
    ContextMenu2.prototype.render = function() {
      var style = __assign$1({ display: this.state.pos ? "block" : "none" }, this.state.pos);
      return html(templateObject_3 || (templateObject_3 = __makeTemplateObject(['<div class="', '" style=', ' aria-role="menu">\n      ', "\n    </div>"], ['<div class="', '" style=', ' aria-role="menu">\n      ', "\n    </div>"])), cls("context-menu"), style, this.getMenuGroupElements());
    };
    return ContextMenu2;
  })(Component)
);
var templateObject_1$2;
var templateObject_2$1;
var templateObject_3;
var Layout = (
  /** @class */
  (function(_super) {
    __extends$1(Layout2, _super);
    function Layout2(props) {
      var _this = _super.call(this, props) || this;
      _this.changeMode = function(editorType2) {
        if (editorType2 !== _this.state.editorType) {
          _this.setState({ editorType: editorType2 });
        }
      };
      _this.changePreviewStyle = function(previewStyle2) {
        if (previewStyle2 !== _this.state.previewStyle) {
          _this.setState({ previewStyle: previewStyle2 });
        }
      };
      _this.hide = function() {
        _this.setState({ hide: true });
      };
      _this.show = function() {
        _this.setState({ hide: false });
      };
      var editorType = props.editorType, previewStyle = props.previewStyle;
      _this.state = {
        editorType,
        previewStyle,
        hide: false
      };
      _this.addEvent();
      return _this;
    }
    Layout2.prototype.mounted = function() {
      var _a = this.props.slots, wwEditor = _a.wwEditor, mdEditor = _a.mdEditor, mdPreview = _a.mdPreview;
      this.refs.wwContainer.appendChild(wwEditor);
      this.refs.mdContainer.insertAdjacentElement("afterbegin", mdEditor);
      this.refs.mdContainer.appendChild(mdPreview);
    };
    Layout2.prototype.insertToolbarItem = function(indexList, item2) {
      this.toolbar.insertToolbarItem(indexList, item2);
    };
    Layout2.prototype.removeToolbarItem = function(name) {
      this.toolbar.removeToolbarItem(name);
    };
    Layout2.prototype.render = function() {
      var _this = this;
      var _a = this.props, eventEmitter = _a.eventEmitter, hideModeSwitch = _a.hideModeSwitch, toolbarItems = _a.toolbarItems, theme = _a.theme;
      var _b = this.state, hide = _b.hide, previewStyle = _b.previewStyle, editorType = _b.editorType;
      var displayClassName = hide ? " hidden" : "";
      var editorTypeClassName = cls(editorType === "markdown" ? "md-mode" : "ww-mode");
      var previewClassName = cls("md") + "-" + previewStyle + "-style";
      var themeClassName = cls([theme !== "light", theme + " "]);
      return html(templateObject_2 || (templateObject_2 = __makeTemplateObject(['\n      <div\n        class="', "", "", '"\n        ref=', "\n      >\n        <", "\n          ref=", "\n          eventEmitter=", "\n          previewStyle=", "\n          toolbarItems=", "\n          editorType=", '\n        />\n        <div\n          class="', " ", '"\n          ref=', '\n        >\n          <div class="', '">\n            <div\n              class="', " ", '"\n              ref=', '\n            >\n              <div class="', '"></div>\n            </div>\n            <div\n              class="', '"\n              ref=', "\n            />\n          </div>\n        </div>\n        ", "\n        <", " eventEmitter=", " />\n      </div>\n    "], [
        '\n      <div\n        class="',
        "",
        "",
        '"\n        ref=',
        "\n      >\n        <",
        "\n          ref=",
        "\n          eventEmitter=",
        "\n          previewStyle=",
        "\n          toolbarItems=",
        "\n          editorType=",
        '\n        />\n        <div\n          class="',
        " ",
        '"\n          ref=',
        '\n        >\n          <div class="',
        '">\n            <div\n              class="',
        " ",
        '"\n              ref=',
        '\n            >\n              <div class="',
        '"></div>\n            </div>\n            <div\n              class="',
        '"\n              ref=',
        "\n            />\n          </div>\n        </div>\n        ",
        "\n        <",
        " eventEmitter=",
        " />\n      </div>\n    "
      ])), themeClassName, cls("defaultUI"), displayClassName, function(el2) {
        return _this.refs.el = el2;
      }, Toolbar, function(toolbar) {
        return _this.toolbar = toolbar;
      }, eventEmitter, previewStyle, toolbarItems, editorType, cls("main"), editorTypeClassName, function(el2) {
        return _this.refs.editorSection = el2;
      }, cls("main-container"), cls("md-container"), previewClassName, function(el2) {
        return _this.refs.mdContainer = el2;
      }, cls("md-splitter"), cls("ww-container"), function(el2) {
        return _this.refs.wwContainer = el2;
      }, !hideModeSwitch && html(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["<", " eventEmitter=", " editorType=", " />"], ["<", " eventEmitter=", " editorType=", " />"])), Switch, eventEmitter, editorType), ContextMenu, eventEmitter);
    };
    Layout2.prototype.addEvent = function() {
      var eventEmitter = this.props.eventEmitter;
      eventEmitter.listen("hide", this.hide);
      eventEmitter.listen("show", this.show);
      eventEmitter.listen("changeMode", this.changeMode);
      eventEmitter.listen("changePreviewStyle", this.changePreviewStyle);
    };
    return Layout2;
  })(Component)
);
var templateObject_1$1;
var templateObject_2;
var ToastUIEditor = (
  /** @class */
  (function(_super) {
    __extends$1(ToastUIEditor2, _super);
    function ToastUIEditor2(options) {
      var _a;
      var _this = _super.call(this, options) || this;
      var layoutComp;
      var destroy4 = render(_this.options.el, html(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n        <", "\n          ref=", "\n          eventEmitter=", "\n          slots=", "\n          hideModeSwitch=", "\n          toolbarItems=", "\n          previewStyle=", "\n          editorType=", "\n          theme=", "\n        />\n      "], ["\n        <", "\n          ref=", "\n          eventEmitter=", "\n          slots=", "\n          hideModeSwitch=", "\n          toolbarItems=", "\n          previewStyle=", "\n          editorType=", "\n          theme=", "\n        />\n      "])), Layout, function(layout) {
        return layoutComp = layout;
      }, _this.eventEmitter, _this.getEditorElements(), _this.options.hideModeSwitch, _this.options.toolbarItems, _this.options.previewStyle, _this.options.initialEditType, _this.options.theme));
      _this.setMinHeight(_this.options.minHeight);
      _this.setHeight(_this.options.height);
      _this.defaultUI = {
        insertToolbarItem: layoutComp.insertToolbarItem.bind(layoutComp),
        removeToolbarItem: layoutComp.removeToolbarItem.bind(layoutComp),
        destroy: destroy4
      };
      (_a = _this.pluginInfo.toolbarItems) === null || _a === void 0 ? void 0 : _a.forEach(function(toolbarItem) {
        var groupIndex = toolbarItem.groupIndex, itemIndex = toolbarItem.itemIndex, item2 = toolbarItem.item;
        _this.defaultUI.insertToolbarItem({ groupIndex, itemIndex }, item2);
      });
      _this.eventEmitter.emit("loadUI", _this);
      return _this;
    }
    ToastUIEditor2.factory = function(options) {
      return options.viewer ? new ToastUIEditorViewer(options) : new ToastUIEditor2(options);
    };
    ToastUIEditor2.prototype.insertToolbarItem = function(indexInfo, item2) {
      this.defaultUI.insertToolbarItem(indexInfo, item2);
    };
    ToastUIEditor2.prototype.removeToolbarItem = function(itemName) {
      this.defaultUI.removeToolbarItem(itemName);
    };
    ToastUIEditor2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.defaultUI.destroy();
    };
    return ToastUIEditor2;
  })(ToastUIEditorCore)
);
var templateObject_1;
ToastUIEditorCore.setLanguage(["en", "en-US"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Write",
  Preview: "Preview",
  Headings: "Headings",
  Paragraph: "Paragraph",
  Bold: "Bold",
  Italic: "Italic",
  Strike: "Strike",
  Code: "Inline code",
  Line: "Line",
  Blockquote: "Blockquote",
  "Unordered list": "Unordered list",
  "Ordered list": "Ordered list",
  Task: "Task",
  Indent: "Indent",
  Outdent: "Outdent",
  "Insert link": "Insert link",
  "Insert CodeBlock": "Insert codeBlock",
  "Insert table": "Insert table",
  "Insert image": "Insert image",
  Heading: "Heading",
  "Image URL": "Image URL",
  "Select image file": "Select image file",
  "Choose a file": "Choose a file",
  "No file": "No file",
  Description: "Description",
  OK: "OK",
  More: "More",
  Cancel: "Cancel",
  File: "File",
  URL: "URL",
  "Link text": "Link text",
  "Add row to up": "Add row to up",
  "Add row to down": "Add row to down",
  "Add column to left": "Add column to left",
  "Add column to right": "Add column to right",
  "Remove row": "Remove row",
  "Remove column": "Remove column",
  "Align column to left": "Align column to left",
  "Align column to center": "Align column to center",
  "Align column to right": "Align column to right",
  "Remove table": "Remove table",
  "Would you like to paste as table?": "Would you like to paste as table?",
  "Text color": "Text color",
  "Auto scroll enabled": "Auto scroll enabled",
  "Auto scroll disabled": "Auto scroll disabled",
  "Choose language": "Choose language"
});

// ../../node_modules/.pnpm/@toast-ui+react-editor@3.1.10_react@18.2.0/node_modules/@toast-ui/react-editor/dist/esm/index.js
var import_toastui_editor_viewer = __toESM(require_toastui_editor_viewer());
var extendStatics2 = function(d, b) {
  extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics2(d, b);
};
function __extends2(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign3 = function() {
  __assign3 = Object.assign || function __assign4(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var default_1 = (
  /** @class */
  (function(_super) {
    __extends2(default_12, _super);
    function default_12() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rootEl = import_react.default.createRef();
      return _this;
    }
    default_12.prototype.getRootElement = function() {
      return this.rootEl.current;
    };
    default_12.prototype.getInstance = function() {
      return this.editorInst;
    };
    default_12.prototype.getBindingEventNames = function() {
      var _this = this;
      return Object.keys(this.props).filter(function(key) {
        return /^on[A-Z][a-zA-Z]+/.test(key);
      }).filter(function(key) {
        return _this.props[key];
      });
    };
    default_12.prototype.bindEventHandlers = function(props) {
      var _this = this;
      this.getBindingEventNames().forEach(function(key) {
        var eventName = key[2].toLowerCase() + key.slice(3);
        _this.editorInst.off(eventName);
        _this.editorInst.on(eventName, props[key]);
      });
    };
    default_12.prototype.getInitEvents = function() {
      var _this = this;
      return this.getBindingEventNames().reduce(function(acc, key) {
        var eventName = key[2].toLowerCase() + key.slice(3);
        acc[eventName] = _this.props[key];
        return acc;
      }, {});
    };
    default_12.prototype.componentDidMount = function() {
      this.editorInst = new ToastUIEditor(__assign3(__assign3({ el: this.rootEl.current }, this.props), { events: this.getInitEvents() }));
    };
    default_12.prototype.shouldComponentUpdate = function(nextProps) {
      var instance = this.getInstance();
      var height = nextProps.height, previewStyle = nextProps.previewStyle;
      if (height && this.props.height !== height) {
        instance.setHeight(height);
      }
      if (previewStyle && this.props.previewStyle !== previewStyle) {
        instance.changePreviewStyle(previewStyle);
      }
      this.bindEventHandlers(nextProps);
      return false;
    };
    default_12.prototype.render = function() {
      return import_react.default.createElement("div", { ref: this.rootEl });
    };
    return default_12;
  })(import_react.default.Component)
);
var ViewerComponent = (
  /** @class */
  (function(_super) {
    __extends2(ViewerComponent2, _super);
    function ViewerComponent2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rootEl = import_react.default.createRef();
      return _this;
    }
    ViewerComponent2.prototype.getRootElement = function() {
      return this.rootEl.current;
    };
    ViewerComponent2.prototype.getInstance = function() {
      return this.viewerInst;
    };
    ViewerComponent2.prototype.getBindingEventNames = function() {
      var _this = this;
      return Object.keys(this.props).filter(function(key) {
        return /^on[A-Z][a-zA-Z]+/.test(key);
      }).filter(function(key) {
        return _this.props[key];
      });
    };
    ViewerComponent2.prototype.bindEventHandlers = function(props) {
      var _this = this;
      this.getBindingEventNames().forEach(function(key) {
        var eventName = key[2].toLowerCase() + key.slice(3);
        _this.viewerInst.off(eventName);
        _this.viewerInst.on(eventName, props[key]);
      });
    };
    ViewerComponent2.prototype.getInitEvents = function() {
      var _this = this;
      return this.getBindingEventNames().reduce(function(acc, key) {
        var eventName = key[2].toLowerCase() + key.slice(3);
        acc[eventName] = _this.props[key];
        return acc;
      }, {});
    };
    ViewerComponent2.prototype.componentDidMount = function() {
      this.viewerInst = new import_toastui_editor_viewer.default(__assign3(__assign3({ el: this.rootEl.current }, this.props), { events: this.getInitEvents() }));
    };
    ViewerComponent2.prototype.shouldComponentUpdate = function(nextProps) {
      this.bindEventHandlers(nextProps);
      return false;
    };
    ViewerComponent2.prototype.render = function() {
      return import_react.default.createElement("div", { ref: this.rootEl });
    };
    return ViewerComponent2;
  })(import_react.default.Component)
);

// ../../node_modules/.pnpm/@glideapps+glide-data-grid-cells@6.0.3_@types+react@18.2.45_lodash@4.17.21_marked@14.0._89412ac46c393934239288dc902f8fd2/node_modules/@glideapps/glide-data-grid-cells/dist/esm/cells/article-cell-editor.js
var Wrapper = styled_default("div")({
  name: "Wrapper",
  class: "gdg-w1hnqk7o",
  propsAsIs: false
});
var ArticleCellEditor = (p) => {
  const [tempValue, setTempValue] = React2.useState(p.value.data.markdown);
  const onKeyDown = React2.useCallback((e) => {
    e.stopPropagation();
  }, []);
  const onSave = React2.useCallback(() => {
    p.onFinishedEditing({
      ...p.value,
      data: {
        ...p.value.data,
        markdown: tempValue
      }
    });
  }, [p, tempValue]);
  const onClose = React2.useCallback(() => {
    p.onFinishedEditing(void 0);
  }, [p]);
  if (p.value.readonly) {
    return React2.createElement(Wrapper, {
      id: "gdg-markdown-readonly",
      onKeyDown,
      style: {
        height: "75vh",
        padding: "35px"
      }
    }, React2.createElement(ViewerComponent, {
      initialValue: p.value.data.markdown,
      usageStatistics: false
    }));
  }
  return React2.createElement(Wrapper, {
    id: "gdg-markdown-wysiwyg",
    onKeyDown
  }, React2.createElement(default_1, {
    initialEditType: "wysiwyg",
    autofocus: true,
    initialValue: p.value.data.markdown,
    hideModeSwitch: true,
    onChange: setTempValue,
    height: "75vh",
    usageStatistics: false,
    toolbarItems: [["heading", "bold", "italic", "strike"], ["hr", "quote"], ["ul", "ol", "task", "indent", "outdent"], ["table", "link"], ["code", "codeblock"]]
  }), React2.createElement("div", {
    className: "gdg-footer"
  }, React2.createElement("button", {
    className: "gdg-close-button",
    onClick: onClose
  }, "Close"), React2.createElement("button", {
    className: "gdg-save-button",
    onClick: onSave
  }, "Save")));
};
var article_cell_editor_default = ArticleCellEditor;
export {
  article_cell_editor_default as default
};
//# sourceMappingURL=article-cell-editor-43YPH7WC.js.map
